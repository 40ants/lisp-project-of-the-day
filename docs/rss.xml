<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>path-parse</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0122-path-parse.html</link>
            <description>&lt;p&gt;This is a small utility library by Fernando Borretti. The only function it has is &lt;code&gt;PATH&lt;/code&gt; variable parsing. But it does it really well.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Path-parse&lt;/code&gt; works on Windows and Unix (OSX):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (path-parse:path)

(#P&amp;quot;/Users/art/.roswell/bin/&amp;quot;
 #P&amp;quot;/Users/art/.bin/&amp;quot;
 #P&amp;quot;/Users/art/.dotfiles/bin/&amp;quot;
 #P&amp;quot;/usr/local/bin/&amp;quot;
 #P&amp;quot;/usr/bin/&amp;quot;
 #P&amp;quot;/bin/&amp;quot;
 #P&amp;quot;/usr/sbin/&amp;quot;
 #P&amp;quot;/sbin/&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it for today. Tomorrow I&apos;ll try to find something more interesting!&lt;/p&gt;
</description>
            <pubDate>Mon, 06 Jul 2020 21:06:02 +0300</pubDate>
        </item>
        <item>
            <title>cl-skip-list</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0121-cl-skip-list.html</link>
            <description>&lt;p&gt;I found this library a few weeks ago. It implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Skip_list&quot;&gt;Skip List&lt;/a&gt; data structure. Which is a lock-free and has &lt;code&gt;O(log n)&lt;/code&gt; for lookup, insert and delete operations.&lt;/p&gt;
&lt;p&gt;I wondered if this library will have a better performance in situation when you have to access a dictionary from multiple threads?&lt;/p&gt;
&lt;p&gt;Here is a simple benchmark. We ll create 10 threads and do 10 millions lookup of a value in the dictionary filled by 6600 symbols from the keywords package.&lt;/p&gt;
&lt;p&gt;I&apos;m testing on SBCL 2.0.2 with &lt;code&gt;(declaim (optimize (debug 1) (speed 3)))&lt;/code&gt; options running on the Macbook with 12 cores.&lt;/p&gt;
&lt;p&gt;Let&apos;s run this benchmark using a standard Common Lisp hash table and a lock:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((hash (make-hash-table))
                 (lock (bt:make-lock))
                 (num-operations 10000000)
                 (num-threads 10))
             (do-external-symbols (s :keyword)
               (setf (gethash s hash)
                     (symbol-name s)))
             (setf (gethash :foo hash)
                   &amp;quot;FOO&amp;quot;)
             ;; Now it is time to define a worker function
             (flet ((worker ()
                      (loop with result = nil
                            repeat num-operations
                            do (bt:with-lock-held (lock)
                                 (setf result
                                       (gethash :foo hash)))
                            finally (return result))))
               ;; We&amp;#039;ll create N workers and measure a total time required to finish them all
               (let* ((started-at (get-internal-real-time))
                      (workers (loop repeat num-threads
                                     collect (bt:make-thread #&amp;#039;worker))))
                 (loop for worker in workers
                       do (bt:join-thread worker))
                 ;; Calculate the total time
                 (/ (- (get-internal-real-time) started-at)
                    internal-time-units-per-second))))
2399/100 (23.99)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And now a lock free version using cl-skip-list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((hash (cl-skip-list:make-skip-list :key-equal #&amp;#039;eql))
                 (num-operations 10000000)
                 (num-threads 10))
             (do-external-symbols (s :keyword)
               (cl-skip-list:skip-list-add hash
                                           s
                                           (symbol-name s)))
             (unless (cl-skip-list:skip-list-lookup hash :foo)
               (cl-skip-list:skip-list-add hash
                                           :foo
                                           &amp;quot;FOO&amp;quot;))
             ;; Now it is time to define a worker function
             (flet ((worker ()
                      (loop with result = nil
                            repeat num-operations
                            do (setf result
                                     (cl-skip-list:skip-list-lookup hash :foo))
                            finally (return result))))
               ;; We&amp;#039;ll create N workers and measure a total time required to finish them all
               (let* ((started-at (get-internal-real-time))
                      (workers (loop repeat num-threads
                                     collect (bt:make-thread #&amp;#039;worker))))
                 (loop for worker in workers
                       do (bt:join-thread worker))
                 ;; Calculate the total time
                 (/ (- (get-internal-real-time) started-at)
                    internal-time-units-per-second))))
45799/1000 (45.799)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you see, the version with a lock is twice faster: 46 seconds against 24.&lt;/p&gt;
&lt;p&gt;Are there any reasons to use a lock-free data structure if it does not get you any speed gains?&lt;/p&gt;
</description>
            <pubDate>Sun, 05 Jul 2020 12:39:11 +0300</pubDate>
        </item>
        <item>
            <title>make-hash</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0120-make-hash.html</link>
            <description>&lt;p&gt;This is the most comprehensive library for making hash tables I&apos;ve already seen! And it has wonderful documentation with lots of examples!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make-hash&lt;/code&gt; allows to create hash tables in multiple ways, from different kinds of data structures and even using functions for data transformation. For example, you can create a hash by reading rows from the database.&lt;/p&gt;
&lt;p&gt;I&apos;ll show you only a few examples I especially liked.&lt;/p&gt;
&lt;p&gt;First one is creation hash from a sequence while counting each item. Using this, we can easily count how many times each character is used in a text:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (make-hash:make-hash
            :init-format :keybag
            :initial-contents &amp;quot;Alice loves Bob&amp;quot;)
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 11 {1008943083}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-hash-table *)
#{
  #\A 1
  #\l 2
  #\i 1
  #\c 1
  #\e 2
  #\  2
  #\o 2
  #\v 1
  #\s 1
  #\B 1
  #\b 1
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the next example, we&apos;ll make a smaller hash table from another one while selecting data by keys:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((full-data
                   (make-hash:make-hash
                    :initial-contents
                    &amp;#039;(:foo 1
                      :bar 2
                      :bazz 3
                      :blah 4
                      :minor 5))))
             (make-hash:make-hash
              :init-format :keys
              :init-data full-data
              :initial-contents &amp;#039;(:bar :minor)))
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 2 {10060F6123}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-hash-table *)
#{
   :BAR 2
   :MINOR 5
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And here is how we can build a hash from a data returned by a function. We only need a closure which will return rows of data as values and will return nil at the end.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun make-rows-iterator ()
             ;; This list will allow us to simulate
             ;; the data storage:
             (let ((rows &amp;#039;((bob 42)
                           (alice 25)
                           (mike 30)
                           (julia 27))))
               (lambda ()
                 (let ((row (car rows)))
                   (setf rows
                         (cdr rows))
                   (values (first row) ;; This is a key
                           (second row))))))

POFTHEDAY&amp;gt; (make-hash:make-hash
            :init-format :function
            :initial-contents (make-rows-iterator))
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 4 {10086FF8E3}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-hash-table *)
#{
  BOB 42
  ALICE 25
  MIKE 30
  JULIA 27
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;make-hash&lt;/code&gt; also provides a configurable reader macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(install-hash-reader ())  ; default settings and options
#{:a 1 :b 2 :c 3 :d 4}   
       

(install-hash-reader &amp;#039;(:init-format :pairs)
  :use-dispatch t
  :open-char #\[ :close-char #\])
#[&amp;#039;(:a . 1) &amp;#039;(:b . 2) &amp;#039;(:c . 3) &amp;#039;(:d . 4)] 
       

(install-hash-reader &amp;#039;(:init-format :lists)
  :use-dispatch nil
  :open-char #\{ :close-char #\})
{&amp;#039;(:a 1) &amp;#039;(:b 2) &amp;#039;(:c 3) &amp;#039;(:d 4)}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You will find more examples and instructions on how to define your own initialization formats in the library&apos;s documentation:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/genovese/make-hash&quot;&gt;https://github.com/genovese/make-hash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let&apos;s thank the #poftheday challenge for the chance to discover such cool Common Lisp library!&lt;/p&gt;
</description>
            <pubDate>Sat, 04 Jul 2020 23:15:08 +0300</pubDate>
        </item>
        <item>
            <title>bourbaki</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0119-bourbaki.html</link>
            <description>&lt;p&gt;This is the system for verifying formal mathematical proofs. As I didn&apos;t use math since the high school and lack time to dive into the lengthy documentation :(&lt;/p&gt;
&lt;p&gt;Here is the code snippet from the example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Declare the wff type
(symkind &amp;quot;WFF&amp;quot;)

;; The implication symbol
(prim wff &amp;quot;-&amp;gt;&amp;quot; (wff ![x y]))

;; the axioms
(ax &amp;quot;ax1&amp;quot; (wff ![A B])
  (ass [-&amp;gt; A -&amp;gt; B A]))
(ax &amp;quot;ax2&amp;quot; (wff ![A B C])
  (ass [-&amp;gt; -&amp;gt; A -&amp;gt; B C -&amp;gt; -&amp;gt; A B -&amp;gt; A C]))

;; the rule of inference (modus ponens)
(ax &amp;quot;ax-mp&amp;quot; (wff ![A B])
  (hypo [A] [-&amp;gt; A B])
  (ass [B]))

;; theorem: identity law for &amp;#039;-&amp;gt;&amp;#039;
;; compare with id1 in set.mm
(th &amp;quot;id&amp;quot; (wff &amp;quot;A&amp;quot;)
  (ass [-&amp;gt; A A])
  (proof
    [ax1 A [-&amp;gt; A A]]
    [ax2 A [-&amp;gt; A A] A]
    [ax-mp [-&amp;gt; A -&amp;gt; -&amp;gt; A A A]
           [-&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]]
    [ax1 A A]
    [ax-mp [-&amp;gt; A -&amp;gt; A A] [-&amp;gt; A A]]))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you eval it in the &lt;code&gt;REPL&lt;/code&gt;, then you can verify it and output some information:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;BOURBAKI-USER&amp;gt; (print-theorem !id)
Theorem id:
Variables: A
Distinct variable conditions: 
Hypotheses: 
Assertion: [-&amp;gt; A A]
Proof:
ax1 [A][-&amp;gt; A A]
ax2 [A][-&amp;gt; A A][A]
ax-mp [-&amp;gt; A -&amp;gt; -&amp;gt; A A A][-&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]
ax1 [A][A]
ax-mp [-&amp;gt; A -&amp;gt; A A][-&amp;gt; A A]

BOURBAKI-USER&amp;gt; (show-proof !id)
Proof for id:
ax1 =&amp;gt; [-&amp;gt; A -&amp;gt; -&amp;gt; A A A]
ax2 =&amp;gt; [-&amp;gt; -&amp;gt; A -&amp;gt; -&amp;gt; A A A -&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]
ax-mp =&amp;gt; [-&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]
ax1 =&amp;gt; [-&amp;gt; A -&amp;gt; A A]
ax-mp =&amp;gt; [-&amp;gt; A A]

BOURBAKI-USER&amp;gt; (verify !id)
Theorem: &amp;quot;ax1&amp;quot;
Theorem: &amp;quot;ax2&amp;quot;
Theorem: &amp;quot;ax-mp&amp;quot;
Theorem: &amp;quot;id&amp;quot;
T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Bourbaki has a very good documentation. If you are interested in math libraries and don&apos;t know how to spend this weekend - enjoy it:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.quicklisp.org/beta/UNOFFICIAL/docs/bourbaki/doc/bourbaki-3.7.pdf&quot;&gt;https://www.quicklisp.org/beta/UNOFFICIAL/docs/bourbaki/doc/bourbaki-3.7.pdf&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Fri, 03 Jul 2020 21:52:13 +0300</pubDate>
        </item>
        <item>
            <title>cl-tui</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0118-cl-tui.html</link>
            <description>&lt;p&gt;This system is an experimental user interface library for the console. It uses &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0061-cl-charms.html&quot;&gt;cl-charms&lt;/a&gt; under the hood, to call &lt;code&gt;ncurses&lt;/code&gt;. The library is not in Quicklisp yet but is installable from &lt;a href=&quot;https://ultralisp.org&quot;&gt;https://ultralisp.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It contains a few examples. I&apos;ve modified one to implement a simple chat-like interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;text&apos;&gt;&amp;#x250C;&amp;#x2500;&amp;#x2500;Online&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2510;
&amp;#x2502;Bob               &amp;#x2502;
&amp;#x2502;Alice             &amp;#x2502;
&amp;#x2502;Peter             &amp;#x2502;
&amp;#x2502;Lisper 313373     &amp;#x2502;23:08:46 Enter some text.
&amp;#x2502;                  &amp;#x2502;23:08:46 Esc to quit
&amp;#x2502;                  &amp;#x2502;23:08:52 Hello Lisp World!
&amp;#x2502;                  &amp;#x2502;23:09:05 This is a simple chat using
&amp;#x2502;                  &amp;#x2502;23:09:16 cl-tui and charms.
&amp;#x2514;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2518;&amp;gt; Input box&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;cl-tui&lt;/code&gt; allows defining frames which can be stacked together. And you can write text inside the frame. Hope, there will be more primitives for other GUI elements like buttons text inputs, forms etc.&lt;/p&gt;
&lt;p&gt;Here are pieces of the example. First, I defined a &quot;roster&quot; and a function to render it inside a frame. This function also draws a border around:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defvar *roster* &amp;#039;(&amp;quot;Bob&amp;quot;
                   &amp;quot;Alice&amp;quot;
                   &amp;quot;Peter&amp;quot;
                   &amp;quot;Lisper 313373&amp;quot;))

(defun draw-roster (&amp;amp;key frame)
  (draw-box frame)
  (put-text frame 0 3 &amp;quot;Online&amp;quot;)
  
  (loop for name in *roster*
        for row upfrom 1
        do (put-text frame row 1 name)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next part is the code defining the application&apos;s layout. It is constructed from nested frames of different types. There is a frame for our roster, a frame to display chat log and to get user&apos;s input:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(define-frame main (container-frame :split-type :horizontal) :on :root)

(define-frame roster (simple-frame :render #&amp;#039;draw-roster) :on main :w 20)

(define-frame chat (container-frame :split-type :vertical) :on main)

(define-frame log (log-frame) :on chat)

;; Edit-frame implements a single-line text editor.
;; It will misbehave if its height is not 1.
(define-frame input (edit-frame :prompt &amp;quot;&amp;gt; &amp;quot;) :on chat :h 1)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We also need two functions to add users input into the chat window and to process keystrokes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defun finish-input ()
  ;; Get text from edit-frame
  (let ((text (get-text &amp;#039;input)))
    ;; Append it to the log-frame
    (append-line &amp;#039;log text)
    ;; And clear the text in edit-frame
    (clear-text &amp;#039;input)))


(defun start ()
  (with-screen ()
    (append-line &amp;#039;log &amp;quot;Enter some text.&amp;quot;)
    (append-line &amp;#039;log &amp;quot;Esc to quit&amp;quot;)
    (loop
      (refresh)
      (let ((key (read-key)))
        (case key
          ;; Esc and Newline are handled here
          (#\Esc (return))
          (#\Newline (finish-input))
          (:key-up (cl-tui:scroll-log &amp;#039;log 1))
          (:key-down (cl-tui:scroll-log &amp;#039;log -1))
          ;; Everything else is sent to the edit-frame.
          (t (handle-key &amp;#039;input key)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is all the app.&lt;/p&gt;
&lt;p&gt;Checkout &lt;a href=&quot;https://github.com/naryl/cl-tui&quot;&gt;the repository&lt;/a&gt;. There you&apos;ll find more examples!&lt;/p&gt;
&lt;p&gt;For those, who are interested in using &lt;code&gt;ncurses&lt;/code&gt;, here are reviews of the two lower-level libraries:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0059-cl-ncurses.html&quot;&gt;cl-ncurses&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0061-cl-charms.html&quot;&gt;cl-charms&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
            <pubDate>Thu, 02 Jul 2020 23:21:18 +0300</pubDate>
        </item>
        <item>
            <title>clack-pretend</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0117-clack-pretend.html</link>
            <description>&lt;p&gt;This is the last middleware in our Clack/Lack series. What does it do? It helps during website development remembering last requests you did from the browser and allowing to replay them from the REPL.&lt;/p&gt;
&lt;p&gt;Clack-pretend interposes itself into a Lack middlewares chain. To define the app you need to use a special builder macro and to specify at which point requests and responses should be captured:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (clack-pretend:pretend-builder (:insert 2)
               :accesslog
               :session
               (lambda (env)
                 (let* ((path (getf env :path-info))
                        (query (getf env :query-string))
                        (message (format nil &amp;quot;Path: ~A, query: ~A&amp;quot;
                                         path query)))
                   (format t &amp;quot;Processing request:~%  ~A~%&amp;quot;
                           message)
                   &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                     (&amp;quot;Hello world!&amp;quot;))))))
*APP*
POFTHEDAY&amp;gt; (defparameter *server*
             (clack:clackup *app*
                            :port 8000))
Hunchentoot server is started.
Listening on 127.0.0.1:8000.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now I&apos;ll make a request using &lt;code&gt;curl&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[poftheday] curl -v &amp;#039;http://localhost:8000/some/route?foo=Bar&amp;#039;
&amp;gt; GET /some/route?foo=Bar HTTP/1.1
&amp;gt; Host: localhost:8000
&amp;gt; User-Agent: curl/7.54.0
&amp;gt; Accept: */*
&amp;gt; 
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Date: Wed, 01 Jul 2020 19:23:12 GMT
&amp;lt; Server: Hunchentoot 1.2.38
&amp;lt; Transfer-Encoding: chunked
&amp;lt; Content-Type: text/plain
&amp;lt; Set-Cookie: lack.session=0d629e3a1d2681d99c40f7b2086ec97d53e2b884; path=/; expires=Sat, 31 Dec 2140 14:45:27 GMT&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And we can look up what was the last request:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack-pretend:last-input)
(:LACK.SESSION.OPTIONS
 (:ID &amp;quot;0d629e3a1d2681d99c40f7b2086ec97d53e2b884&amp;quot;
  :NEW-SESSION T :CHANGE-ID NIL :EXPIRE NIL)
 :LACK.SESSION #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 0 {1005EB8A03}&amp;gt;
 :REQUEST-METHOD :GET
 :SCRIPT-NAME &amp;quot;&amp;quot;
 :PATH-INFO &amp;quot;/some/route&amp;quot;
 :SERVER-NAME &amp;quot;localhost&amp;quot;
 :SERVER-PORT 8000
 :SERVER-PROTOCOL :HTTP/1.1
 :REQUEST-URI &amp;quot;/some/route?foo=Bar&amp;quot;
 :URL-SCHEME &amp;quot;http&amp;quot;
 :REMOTE-ADDR &amp;quot;127.0.0.1&amp;quot;
 :REMOTE-PORT 53671
 :QUERY-STRING &amp;quot;foo=Bar&amp;quot;
 :RAW-BODY #&amp;lt;FLEXI-STREAMS:FLEXI-IO-STREAM {1005EB6FD3}&amp;gt;
 :CONTENT-LENGTH NIL
 :CONTENT-TYPE NIL
 :CLACK.STREAMING T
 :CLACK.IO #&amp;lt;CLACK.HANDLER.HUNCHENTOOT::CLIENT {1005EB7043}&amp;gt;
 :HEADERS #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 3 {1005EB72C3}&amp;gt;
 :QUERY-PARAMETERS ((&amp;quot;foo&amp;quot; . &amp;quot;Bar&amp;quot;)))

POFTHEDAY&amp;gt; (rutils:hash-table-to-alist
            (getf * :headers))
((&amp;quot;host&amp;quot; . &amp;quot;localhost:8000&amp;quot;)
 (&amp;quot;user-agent&amp;quot; . &amp;quot;curl/7.54.0&amp;quot;)
 (&amp;quot;accept&amp;quot; . &amp;quot;*/*&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now it is time to replay the request from the REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack-pretend:run-pretend)
Processing request:
  Path: /some/route, query: foo=Bar
(200 (:CONTENT-TYPE &amp;quot;text/plain&amp;quot;) (&amp;quot;Hello world!&amp;quot;))

;; You can override path to check, it with the same
;; headers and session:
POFTHEDAY&amp;gt; (clack-pretend:run-pretend
            :path-info &amp;quot;/other/path&amp;quot;)
Processing request:
  Path: /other/path, query: foo=Bar
(200 (:CONTENT-TYPE &amp;quot;text/plain&amp;quot;) (&amp;quot;Hello world!&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Seems, &lt;code&gt;clack-pretend&lt;/code&gt; is a great addition for web development with Clack.&lt;/p&gt;
&lt;p&gt;It will be interesting to improve it to store not only the last N successful requests but also to store requests resulting unhandled error. This way you&apos;ll be able to replay errors your users experience in production!&lt;/p&gt;
</description>
            <pubDate>Wed, 01 Jul 2020 22:32:39 +0300</pubDate>
        </item>
        <item>
            <title>clack-static-asset-middleware</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0115-clack-static-asset-middleware.html</link>
            <description>&lt;p&gt;This middleware in some sense like a builtin &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0110-lack-middleware-static.html&quot;&gt;lack-middleware-static&lt;/a&gt;, reviewed last week.&lt;/p&gt;
&lt;p&gt;The difference is that this middleware is more suitable for production because implements an infinite cache TTL for static assets.&lt;/p&gt;
&lt;p&gt;An infinite cache TTL trick is useful when you want to speed up your website loading. Here is how it works.&lt;/p&gt;
&lt;p&gt;Your server returns &lt;code&gt;Cache-Control&lt;/code&gt; HTTP header and set static files TTL to some large value like a year to make it cached for a long long period of time.&lt;/p&gt;
&lt;p&gt;But how to expire this cache if you will need to update CSS or JavaScript on your site?&lt;/p&gt;
&lt;p&gt;The only way is to change the URL. This is what &lt;code&gt;lack-middleware-static&lt;/code&gt; does for you. It calculates MD5 hash from the file&apos;s content and makes it a part of the URL.&lt;/p&gt;
&lt;p&gt;When the content of the static file is changed, its URL changed as well. Browser notices that change and reloads the content.&lt;/p&gt;
&lt;p&gt;Middleware provides a special tag for &lt;a href=&quot;https://github.com/mmontone/djula&quot;&gt;Djula&lt;/a&gt; template language. Setting up templates for djula is out of thescope of this post and we&apos;ll use &lt;code&gt;busted-uri-for-path&lt;/code&gt; instead, to create a path to a file including a cache hash.&lt;/p&gt;
&lt;p&gt;First, we need to start our server and configure the middleware. Pay attention to the &lt;code&gt;probe-file&lt;/code&gt; call. Root should be an absolute pathname. With relative pathname, you&apos;ll get a wrong result :(&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (funcall
             clack-static-asset-middleware:*clack-static-asset-middleware*
             (lambda (env)
               (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil
                                   &amp;quot;Access this file: ~A&amp;quot;
                                   (clack-static-asset-middleware:busted-uri-for-path

                                    &amp;quot;site.css&amp;quot;)))))
             :path &amp;quot;static/&amp;quot;
             :root (probe-file &amp;quot;static-files/&amp;quot;))
            :port 9004)
Hunchentoot server is started.
Listening on 127.0.0.1:9004.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can access our index page to get the static&apos;s URL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:9004/&amp;quot;)
&amp;quot;Access this file: /static/site_ebb4fccbf8e0590b0fcf44c3748af88d.css&amp;quot;
200&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pay attention to the file&apos;s suffix. It is an md5 hash from file&apos;s content. This sum is calculated when you start the application. If you&apos;ll change the file, during the next deploy another md5 hash will be generated and browser will reload its content.&lt;/p&gt;
&lt;p&gt;If we&apos;ll access this file, the server will respond with &lt;code&gt;Cache-Control&lt;/code&gt; header and set the TTL to 1 year:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:9004/static/site_ebb4fccbf8e0590b0fcf44c3748af88d.css&amp;quot;)
&amp;quot;body {font-size: 10px;}&amp;quot;
200 (8 bits, #xC8, #o310, #b11001000)
#&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 8 {1001E58473}&amp;gt;
#&amp;lt;QURI.URI.HTTP:URI-HTTP http://localhost:9004/static/site_ebb4fccbf8e0590b0fcf44c3748af88d.css&amp;gt;
#&amp;lt;SB-SYS:FD-STREAM for &amp;quot;socket 127.0.0.1:53729, peer: 127.0.0.1:9004&amp;quot; {1001E37873}&amp;gt;

POFTHEDAY&amp;gt; (rutils:hash-table-to-alist #v56:2)
((&amp;quot;date&amp;quot; . &amp;quot;Tue, 30 Jun 2020 19:39:55 GMT&amp;quot;)
 (&amp;quot;server&amp;quot; . &amp;quot;Hunchentoot 1.3.0&amp;quot;)
 (&amp;quot;accept-ranges&amp;quot; . &amp;quot;bytes&amp;quot;)
 (&amp;quot;last-modified&amp;quot; . &amp;quot;Tue, 30 Jun 2020 19:15:56 GMT&amp;quot;)
 (&amp;quot;vary&amp;quot; . &amp;quot;Accept-Encoding&amp;quot;)
 (&amp;quot;cache-control&amp;quot; . &amp;quot;public, max-age=31556926&amp;quot;)
 (&amp;quot;content-length&amp;quot; . &amp;quot;23&amp;quot;)
 (&amp;quot;content-type&amp;quot; . &amp;quot;text/css; charset=utf-8&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow we&apos;ll review the last Clack&apos;s middleware. I found only 3 of them on the Quicklisp. If you know about other middlewares, let me know and we&apos;ll continue our journey to the world of web development with Clack!&lt;/p&gt;
</description>
            <pubDate>Tue, 30 Jun 2020 22:57:55 +0300</pubDate>
        </item>
        <item>
            <title>clack-errors</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0114-clack-errors.html</link>
            <description>&lt;p&gt;This is the Clack middleware which adds a nicely rendered error page for your website. It pretends to be a clone of the RoR&apos;s &lt;a href=&quot;https://github.com/BetterErrors/better_errors&quot;&gt;better_errors&lt;/a&gt; library but has only a limited number of features.&lt;/p&gt;
&lt;p&gt;Clack-errors is able to show a backtrace and content of the &lt;code&gt;env&lt;/code&gt; variable. But it does not allow you to inspect the variables of stack frames and does not show HTTP headers.&lt;/p&gt;
&lt;p&gt;It has a demo application which can be loaded as &lt;code&gt;:clack-errors-demo&lt;/code&gt; ASDF system.&lt;/p&gt;
&lt;p&gt;If you&apos;ll do a &lt;code&gt;(clack-errors-demo:start)&lt;/code&gt; it will start a webserver on the 8000 port.&lt;/p&gt;
&lt;p&gt;Access the &lt;a href=&quot;http://localhost:8001/error&quot;&gt;http://localhost:8001/error&lt;/a&gt; URL to see the page like this:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0114/clack-errors.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;You can customize the behaviour of the middleware by two options: &lt;code&gt;:debug&lt;/code&gt; and &lt;code&gt;:prod-render&lt;/code&gt;. &lt;code&gt;:debug&lt;/code&gt; is &lt;code&gt;t&lt;/code&gt; by default and if you set it to the &lt;code&gt;nil&lt;/code&gt;, middleware will not show backtrace. It will call &lt;code&gt;:prod-render&lt;/code&gt; function instead.&lt;/p&gt;
&lt;p&gt;Also, you might override some internal variables like &lt;code&gt;+dev-template+&lt;/code&gt;, &lt;code&gt;*dev-css-path*&lt;/code&gt;, etc. But it is better to send a pull-request which will allow redefining dev renderer.&lt;/p&gt;
&lt;p&gt;Personally, I&apos;m don&apos;t see the need in such middleware in the Common Lisp web application, because you have much better backtrace inspection tool in the SLIME or other IDE.&lt;/p&gt;
</description>
            <pubDate>Mon, 29 Jun 2020 21:21:47 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-csrf</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0113-lack-middleware-csrf.html</link>
            <description>&lt;p&gt;This lack middleware provides some level of security for your webapp, preventing a &lt;a href=&quot;https://owasp.org/www-community/attacks/csrf&quot;&gt;CSRF attacks&lt;/a&gt;. It has a function &lt;code&gt;csrf-html-tag&lt;/code&gt; which returns a hidden &lt;code&gt;input&lt;/code&gt; element to embed into a form.&lt;/p&gt;
&lt;p&gt;The input stores a special token. Middleware saves this token into the current session and ensures the user sends this token in the following requests. If he doesn&apos;t, a 400 status code will be returned.&lt;/p&gt;
&lt;p&gt;Let&apos;s take our yesterday&apos;s app and make it more secure!&lt;/p&gt;
&lt;p&gt;First, we need to rewrite our main application to make it render a login form with CSRF token. Pay attention to how does it call a &lt;code&gt;csrf-html-tag&lt;/code&gt; function at the end.&lt;/p&gt;
&lt;p&gt;If you are going to develop an application with a lots of forms, then it is good idea to define a macro which will apply CSRF protection automatically.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun main (env)
             (let* ((session (getf env :lack.session))
                    (login (gethash :login session)))
               (cond
                 (login
                  (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                        (list (format nil &amp;quot;Welcome, ~A!&amp;quot;
                                      login))))
                 (t
                  (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                        (list (format nil &amp;quot;
&amp;lt;form method=\&amp;quot;POST\&amp;quot; action=\&amp;quot;/login\&amp;quot;&amp;gt;
  &amp;lt;input type=\&amp;quot;text\&amp;quot; name=\&amp;quot;login\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  &amp;lt;input type=\&amp;quot;password\&amp;quot; name=\&amp;quot;password\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  ~A
&amp;lt;/form&amp;gt;
&amp;quot;
                          (lack.middleware.csrf:csrf-html-tag session))))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;All other apps remain the same, we only need to build the whole app including the &lt;code&gt;csrf&lt;/code&gt; middleware.&lt;/p&gt;
&lt;p&gt;This middleware should go after the &lt;code&gt;:session&lt;/code&gt; middleware, because it depends on it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             :session
             :csrf
             (:mount &amp;quot;/login&amp;quot; &amp;#039;login)
             (:mount &amp;quot;/logout&amp;quot; &amp;#039;logout)
             &amp;#039;main)
            :port 8091)
Hunchentoot server is started.
Listening on 127.0.0.1:8091.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is how our form is rendered. Note a &quot;hidden&quot; input at the end of the form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8091/&amp;quot;)
&amp;quot;
&amp;lt;form method=\&amp;quot;POST\&amp;quot; action=\&amp;quot;/login\&amp;quot;&amp;gt;
  &amp;lt;input type=\&amp;quot;text\&amp;quot; name=\&amp;quot;login\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  &amp;lt;input type=\&amp;quot;password\&amp;quot; name=\&amp;quot;password\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  &amp;lt;input type=\&amp;quot;hidden\&amp;quot; name=\&amp;quot;_csrf_token\&amp;quot; value=\&amp;quot;8de1c8a47\&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we try to do a &lt;code&gt;POST&lt;/code&gt; request without the token, we&apos;ll receive a 400 error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (handler-case
               (dex:post &amp;quot;http://localhost:8091/login&amp;quot;
                         :content &amp;#039;((&amp;quot;login&amp;quot; . &amp;quot;bob&amp;quot;)
                                    (&amp;quot;password&amp;quot; . &amp;quot;$ecret&amp;quot;))
                         :headers &amp;#039;((:cookie . &amp;quot;lack.session=75bccc&amp;quot;)))
             (dexador:http-request-failed (c)
               (values (dexador:response-status c)
                       (dexador:response-body c))))
400
&amp;quot;Bad Request: invalid CSRF token&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using the code we&apos;ll be able to log in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:post &amp;quot;http://localhost:8091/login&amp;quot;
                     :content &amp;#039;((&amp;quot;login&amp;quot; . &amp;quot;bob&amp;quot;)
                                (&amp;quot;password&amp;quot; . &amp;quot;$ecret&amp;quot;)
                                (&amp;quot;_csrf_token&amp;quot; . &amp;quot;8de1c8a47&amp;quot;))
                     :headers &amp;#039;((:cookie . &amp;quot;lack.session=75bccc&amp;quot;)))
&amp;quot;Dear Bob, you welcome!&amp;quot;
200&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The middleware also has a few settings.&lt;/p&gt;
&lt;p&gt;You can set &lt;code&gt;:session-key&lt;/code&gt; to a value other than &lt;code&gt;_csrf_token&lt;/code&gt;. But this changes only a token&apos;s key inside the session. Form field&apos;s name remains the &lt;code&gt;_csrf_token&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Other option is &lt;code&gt;:one-time&lt;/code&gt;. Set it to true if you want to remove a token from the session after the first successful &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;PATCH&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And finally, you can define your own handler for the error page and pass it as &quot;:block-app&quot;. It should be a usual Clack app.&lt;/p&gt;
</description>
            <pubDate>Sun, 28 Jun 2020 22:31:02 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-session</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0112-lack-middleware-session.html</link>
            <description>&lt;p&gt;This middleware makes your app stateful and allows to associate some information with the current user.&lt;/p&gt;
&lt;p&gt;There are two abstractions behind Lack sessions - state and store.&lt;/p&gt;
&lt;p&gt;State object defines how to keep track of a session. Lack includes only one type of state class. It keeps state id in the browser&apos;s cookies.&lt;/p&gt;
&lt;p&gt;Store object defines where to store data, associated with a state. There are three store classes in the Lack. The default stores data in memory, using a hash table. There are also &lt;code&gt;dbi&lt;/code&gt; and &lt;code&gt;redis&lt;/code&gt; stores.&lt;/p&gt;
&lt;p&gt;Now let&apos;s create an app that allows a user to login in and logout.&lt;/p&gt;
&lt;p&gt;First, we need an app for logging it checks the password as we did in yesterday&apos;s &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0111-lack-middleware-auth-basic.html&quot;&gt;post on basic auth&lt;/a&gt;. If the password is correct, we&apos;ll put a user&apos;s login into a session&apos;s hash:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun login (env)
             (let* ((params (getf env :body-parameters))
                    (login (alexandria:assoc-value
                            params
                            &amp;quot;login&amp;quot; :test #&amp;#039;string=))
                    (password (alexandria:assoc-value
                               params
                               &amp;quot;password&amp;quot; :test #&amp;#039;string=))
                    (session (getf env
                                   :lack.session)))
               (cond
                 ((and (string= login
                                &amp;quot;bob&amp;quot;)
                       (string= password
                                &amp;quot;$ecret&amp;quot;))
                  (setf (gethash :login
                                 session)
                        login)
                  &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                    (&amp;quot;Dear Bob, you welcome!&amp;quot;)))
                 (t
                  &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                    (&amp;quot;Wrong password!&amp;quot;))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, we need a function to logout. It set&apos;s a special flag to let middleware know that all session data should be wiped from the store:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun logout (env)
             (setf (getf (getf env :lack.session.options)
                         :expire)
                   t)
             &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
               (&amp;quot;Now you are logged our&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The main app will use data from the session and will show a welcome message if the user is authenticated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun main (env)
             (let* ((session (getf env :lack.session))
                    (login (gethash :login session)))
               (cond
                 (login
                  (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                        (list (format nil &amp;quot;Welcome, ~A!&amp;quot;
                                      login))))
                 (t
                  &amp;#039;(403 (:content-type &amp;quot;text/plain&amp;quot;)
                        (&amp;quot;Access denied&amp;quot;))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally, we need to combine these apps using &lt;code&gt;mount&lt;/code&gt; middleware (it was &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0109-lack-middleware-mount.html&quot;&gt;reviewed a few days ago&lt;/a&gt;) and slap the &lt;code&gt;session&lt;/code&gt; middleware on it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             :session
             (:mount &amp;quot;/login&amp;quot; &amp;#039;login)
             (:mount &amp;quot;/logout&amp;quot; &amp;#039;logout)
             &amp;#039;main)
            :port 8089)
Hunchentoot server is started.
Listening on 127.0.0.1:8089.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s try to log in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8090/&amp;quot;))
&amp;quot;Access denied&amp;quot;

POFTHEDAY&amp;gt; (multiple-value-bind (response code headers)
               (dex:post &amp;quot;http://localhost:8090/login&amp;quot;
                         :content &amp;#039;((&amp;quot;login&amp;quot; . &amp;quot;bob&amp;quot;)
                                    (&amp;quot;password&amp;quot; . &amp;quot;$ecret&amp;quot;)))
             (values response code
                     (rutils:hash-table-to-alist headers)))
&amp;quot;Dear Bob, you welcome!&amp;quot;
200
((&amp;quot;date&amp;quot; . &amp;quot;Sat, 27 Jun 2020 20:47:13 GMT&amp;quot;)
 (&amp;quot;server&amp;quot; . &amp;quot;Hunchentoot 1.2.38&amp;quot;)
 (&amp;quot;transfer-encoding&amp;quot; . &amp;quot;chunked&amp;quot;)
 (&amp;quot;content-type&amp;quot; . &amp;quot;text/plain&amp;quot;)
 (&amp;quot;set-cookie&amp;quot;
  &amp;quot;lack.session=b10c66; path=/; expires=Fri, 23 Dec 2140 17:24:51 GMT&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The server returned the &quot;set-cookie&quot; header. Usually, the browser will pass this cookie content during the following requests. We&apos;ll emulate this behavior to make a request to the main app:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((headers &amp;#039;((:cookie . &amp;quot;lack.session=b10c66&amp;quot;))))
             (values (dex:get &amp;quot;http://localhost:8090/&amp;quot;
                              :headers headers)))
&amp;quot;Welcome, bob!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally, we&apos;ll check how does log out will work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((headers &amp;#039;((:cookie . &amp;quot;lack.session=b10c66&amp;quot;))))
             (values (dex:post &amp;quot;http://localhost:8090/logout&amp;quot;
                               :headers headers)))
&amp;quot;Now you are logged out&amp;quot;

POFTHEDAY&amp;gt; (let ((headers &amp;#039;((:cookie . &amp;quot;lack.session=b10c66&amp;quot;))))
             (dex:get &amp;quot;http://localhost:8090/&amp;quot;
                              :headers headers))
&amp;quot;Access denied&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;See!? We&apos;ve built a simple web application using Lack micro-framework! Add something like Spinneret to render HTML and &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/03/0021-lass.html&quot;&gt;Lass&lt;/a&gt; + &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0071-parenscript.html&quot;&gt;Parenscript&lt;/a&gt; to render CSS and JS and we&apos;ll have a full-fledged webapp!&lt;/p&gt;
</description>
            <pubDate>Sat, 27 Jun 2020 23:59:57 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-auth-basic</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0111-lack-middleware-auth-basic.html</link>
            <description>&lt;p&gt;This Lack middleware is also undocumented, but it is short enough to understand from sources how to configure it.&lt;/p&gt;
&lt;p&gt;When configuring this middleware, you should pass it a function which accepts username and password and returns a &lt;code&gt;t&lt;/code&gt; if the password is correct. Also, this function may return a user object as a second value. Returned user or original username from the HTTP header will be added to the environment plist as &lt;code&gt;:remote-user&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil
                                   &amp;quot;Hello ~A!&amp;quot;
                                   (getf env :remote-user))))))

POFTHEDAY&amp;gt; (defun auth (user pass)
             (when (and (string= user &amp;quot;bob&amp;quot;)
                        (string= pass &amp;quot;$ecret&amp;quot;))
               (values t
                       &amp;quot;Bob The Admin&amp;quot;)))

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:auth-basic :authenticator #&amp;#039;auth)
             *app*)
            :port 8080)
Hunchentoot server is started.
Listening on 127.0.0.1:8080.

POFTHEDAY&amp;gt; (handler-case (dex:get &amp;quot;http://localhost:8080/foo/bar&amp;quot;)
             (error (condition)
               (values (dex:response-status condition)
                       (dex:response-body condition))))
401 (9 bits, #x191)
&amp;quot;Authorization required&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8080/foo/bar&amp;quot;
                    :basic-auth &amp;#039;(&amp;quot;bob&amp;quot; . &amp;quot;$ecret&amp;quot;))
&amp;quot;Hello Bob The Admin!&amp;quot;
200&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. Very simple, isn&apos;t it?&lt;/p&gt;
&lt;p&gt;But please, don&apos;t hardcode passwords in the sources as I did :)&lt;/p&gt;
</description>
            <pubDate>Fri, 26 Jun 2020 20:53:29 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-static</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0110-lack-middleware-static.html</link>
            <description>&lt;p&gt;This middleware can be used to serve files from a directory. However, I don&apos;t recommend using it for production because it should be inefficient because a few lambdas are created on each request.&lt;/p&gt;
&lt;p&gt;The middleware should be parametrized with two arguments: &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;root&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;path&lt;/code&gt; is a prefix from the URL. The &lt;code&gt;root&lt;/code&gt; is the root directory on the local filesystem. For example, if &lt;code&gt;root&lt;/code&gt; is &lt;code&gt;/tmp/files/&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;/static/&lt;/code&gt; then for URL &lt;code&gt;http://my-site.com/static/some/file.txt&lt;/code&gt; Lack will return content of the &lt;code&gt;/tmp/files/some/file.txt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is a small example, showing how does it work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lambda (env)
               &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                 (&amp;quot;A main app&amp;#039;s response&amp;quot;))))

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:static
              ;; This is a path of URL
              ;; to serve static files
              :path &amp;quot;/static/&amp;quot;
              ;; from this directory
              ;; on the filesystem
              :root #P&amp;quot;./static-files/&amp;quot;)
             *app*)
            :port 8082)
Hunchentoot server is started.
Listening on 127.0.0.1:8082.

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8082/static/the-file.txt&amp;quot;))
&amp;quot;My static file&amp;quot;

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8082/static/missing.txt&amp;quot;))
; Debugger entered on #&amp;lt;DEXADOR.ERROR:HTTP-REQUEST-NOT-FOUND {100B944133}&amp;gt;

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8082/other/path&amp;quot;))
&amp;quot;A main app&amp;#039;s response&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you can pass a function as a &lt;code&gt;path&lt;/code&gt; argument. This way some sort of filtering may be done. The function should return another path and you probably will need to remove a prefix from it.&lt;/p&gt;
&lt;p&gt;For example, if we want to serve only a &lt;code&gt;css&lt;/code&gt; files from the &lt;code&gt;static-files&lt;/code&gt; directory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (alexandria:write-string-into-file
            &amp;quot;Some secret README&amp;quot;
            #P&amp;quot;static-files/README.txt&amp;quot;)

POFTHEDAY&amp;gt; (alexandria:write-string-into-file
            &amp;quot;Just CSS file&amp;quot;
            #P&amp;quot;static-files/the.css&amp;quot;)

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:static
              ;; This is a function to filter filename
              ;; of the served static files:
              :path (lambda (original-path)
                      ;; When this function returns nil,
                      ;; the request is passed to the main application.
                      (when (and (str:ends-with-p &amp;quot;.css&amp;quot;
                                                  original-path)
                                 (str:starts-with-p &amp;quot;/static/&amp;quot;
                                                    original-path))
                        ;; you need to rewrite the path manually:
                        (subseq original-path 7)))
              ;; from this directory
              ;; on the filesystem
              :root #P&amp;quot;./static-files/&amp;quot;)
             *app*)
            :port 8085)
Hunchentoot server is started.
Listening on 127.0.0.1:8085.

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8085/static/the.css&amp;quot;)
&amp;quot;Just CSS file&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8085/static/README.txt&amp;quot;)
&amp;quot;A main app&amp;#039;s response&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is no any way to return 404 or 403 error in this case. This should be done on the main app&apos;s level.&lt;/p&gt;
&lt;p&gt;That is it for today. Tomorrow we&apos;ll how to protect your app with basic auth!&lt;/p&gt;
</description>
            <pubDate>Thu, 25 Jun 2020 21:15:21 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-mount</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0109-lack-middleware-mount.html</link>
            <description>&lt;p&gt;We continue to review Lack&apos;s middlewares and this one gives you the ability to route requests to different apps depending on the path.&lt;/p&gt;
&lt;p&gt;Here is a quick example. We want to plug a &lt;code&gt;blog&lt;/code&gt; and &lt;code&gt;admin&lt;/code&gt; into our main app:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *main-app*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil &amp;quot;~A~%This is main app!&amp;quot;
                                   (getf env :path-info))))))

POFTHEDAY&amp;gt; (defparameter *blog*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil &amp;quot;~A~%The Blog.&amp;quot;
                                   (getf env :path-info))))))

POFTHEDAY&amp;gt; (defparameter *admin*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil &amp;quot;~A~%Administration interface.&amp;quot;
                                   (getf env :path-info))))))

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:mount &amp;quot;/blog&amp;quot; *blog*)
             (:mount &amp;quot;/admin&amp;quot; *admin*)
             *main-app*)
            :port 8044)
Hunchentoot server is started.
Listening on 127.0.0.1:8044.

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8044/some/page&amp;quot;)
&amp;quot;/some/page
This is main app!&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8044/blog/post-1&amp;quot;)
&amp;quot;/post-1
The Blog.&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8044/admin/blog/posts?id=1&amp;quot;)
&amp;quot;/blog/posts
Administration interface.&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pay attention to paths, returned as the first line of each response. It is relative to the mount point. This middleware rewrites the path so that an app can be mounted with any prefix.&lt;/p&gt;
&lt;p&gt;That is it for today. Tomorrow we&apos;ll see how we can serve static with Lack.&lt;/p&gt;
</description>
            <pubDate>Wed, 24 Jun 2020 22:50:22 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-backtrace</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0108-lack-middleware-backtrace.html</link>
            <description>&lt;p&gt;You might consider this a cheating, but I really want to review all Lack middlewares regardless most of them are from the same &lt;code&gt;Lack&lt;/code&gt; project. These middlewares are loadable as separate ASDF systems.&lt;/p&gt;
&lt;p&gt;The problem of Lack middlewares is that they are not documented.&lt;/p&gt;
&lt;p&gt;This middleware will output a backtrace and all request parameters to the stream or a file.&lt;/p&gt;
&lt;p&gt;If you are using &lt;code&gt;clack:clackup&lt;/code&gt; function to start your app, it will apply a &lt;code&gt;backtrace&lt;/code&gt; middleware to it, unless &lt;code&gt;:use-default-middlewares nil&lt;/code&gt; argument was given. Without configuration, all backtraces will be written to &lt;code&gt;*error-output*&lt;/code&gt; stream.&lt;/p&gt;
&lt;p&gt;Let&apos;s see how does it work!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lambda (env)
               (declare (ignorable env))
               (error &amp;quot;Oh my God!&amp;quot;)))
*APP*
POFTHEDAY&amp;gt; (clack:clackup *app*
                          :port 8085)
Hunchentoot server is started.
Listening on 127.0.0.1:8085.

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8085/foo/bar&amp;quot;))
Backtrace for: #&amp;lt;SB-THREAD:THREAD &amp;quot;hunchentoot-worker-127.0.0.1:56469&amp;quot; RUNNING {1007707373}&amp;gt;
0: ((LAMBDA NIL :IN UIOP/IMAGE:PRINT-BACKTRACE))
1: ((FLET &amp;quot;THUNK&amp;quot; :IN UIOP/STREAM:CALL-WITH-SAFE-IO-SYNTAX))
2: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #&amp;lt;CLOSURE (FLET &amp;quot;THUNK&amp;quot; :IN UIOP/STREAM:CALL-WITH-SAFE-IO-SYNTAX) {D85A24B}&amp;gt;)
3: (UIOP/STREAM:CALL-WITH-SAFE-IO-SYNTAX #&amp;lt;CLOSURE (LAMBDA NIL :IN UIOP/IMAGE:PRINT-BACKTRACE) {100791B9EB}&amp;gt; :PACKAGE :CL)
4: (UIOP/IMAGE:PRINT-CONDITION-BACKTRACE #&amp;lt;SIMPLE-ERROR &amp;quot;Oh my God!&amp;quot; {100791B943}&amp;gt; :STREAM #&amp;lt;SYNONYM-STREAM :SYMBOL SLYNK::*CURRENT-ERROR-OUTPUT* {1001541093}&amp;gt; :COUNT NIL)
5: (LACK.MIDDLEWARE.BACKTRACE::PRINT-ERROR #&amp;lt;SIMPLE-ERROR &amp;quot;Oh my God!&amp;quot; {100791B943}&amp;gt; (:REQUEST-METHOD :GET :SCRIPT-NAME &amp;quot;&amp;quot; :PATH-INFO &amp;quot;/foo/bar&amp;quot; :SERVER-NAME &amp;quot;localhost&amp;quot; :SERVER-PORT 8085 :SERVER-PROTOCOL :HTTP/1.1 ...) #&amp;lt;SYNONYM-STREAM :SYMBOL SLYNK::*CURRENT-ERROR-OUTPUT* {1001541093}&amp;gt;)
6: ((FLET LACK.MIDDLEWARE.BACKTRACE::OUTPUT-BACKTRACE :IN &amp;quot;/Users/art/projects/lisp/lisp-project-of-the-day/.qlot/dists/ultralisp/software/fukamachi-lack-20200524065357/src/middleware/backtrace.lisp&amp;quot;) #&amp;lt;SIMPLE-ERROR &amp;quot;Oh my God!&amp;quot; {100791B943}&amp;gt; (:REQUEST-METHOD :GET :SCRIPT-NAME &amp;quot;&amp;quot; :PATH-INFO &amp;quot;/foo/bar&amp;quot; :SERVER-NAME &amp;quot;localhost&amp;quot; :SERVER-PORT 8085 :SERVER-PROTOCOL :HTTP/1.1 ...))
...
31: (SB-THREAD::NEW-LISP-THREAD-TRAMPOLINE #&amp;lt;SB-THREAD:THREAD &amp;quot;hunchentoot-worker-127.0.0.1:56469&amp;quot; RUNNING {1007707373}&amp;gt; NIL #&amp;lt;CLOSURE (LABELS BORDEAUX-THREADS::%BINDING-DEFAULT-SPECIALS-WRAPPER :IN BORDEAUX-THREADS::BINDING-DEFAULT-SPECIALS) {100770731B}&amp;gt; NIL)
32: (&amp;quot;foreign function: call_into_lisp&amp;quot;)
33: (&amp;quot;foreign function: new_thread_trampoline&amp;quot;)
Above backtrace due to this condition:
Oh my God!

Request:
    REQUEST-METHOD: :GET
    SCRIPT-NAME: &amp;quot;&amp;quot;
    PATH-INFO: &amp;quot;/foo/bar&amp;quot;
    SERVER-NAME: &amp;quot;localhost&amp;quot;
    SERVER-PORT: 8085
    SERVER-PROTOCOL: :HTTP/1.1
    REQUEST-URI: &amp;quot;/foo/bar&amp;quot;
    URL-SCHEME: &amp;quot;http&amp;quot;
    REMOTE-ADDR: &amp;quot;127.0.0.1&amp;quot;
    REMOTE-PORT: 56469
    QUERY-STRING: NIL
    RAW-BODY: #&amp;lt;FLEXI-STREAMS:FLEXI-IO-STREAM {100791B313}&amp;gt;
    CONTENT-LENGTH: 0
    CONTENT-TYPE: NIL
    CLACK.STREAMING: T
    CLACK.IO: #&amp;lt;CLACK.HANDLER.HUNCHENTOOT::CLIENT {100791B363}&amp;gt;
    HEADERS:
        user-agent: &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
        host: &amp;quot;localhost:8085&amp;quot;
        accept: &amp;quot;*/*&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The problem here is that I did not receive a 500 error. An interactive debugger popped up instead and HTTP request finished with a timeout. To solve this problem, we need to pass a &lt;code&gt;:debug nil&lt;/code&gt; argument to &lt;code&gt;clackup&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(clack:clackup *app*
               :port 8085
               :debug nil)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we&apos;ll try other configuration of this backtrace middleware.&lt;/p&gt;
&lt;p&gt;To write output to the file, you need to specify the output option. It can be either a string or a pathname:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:backtrace :output &amp;quot;/tmp/errors.log&amp;quot;)
             *app*)
            :port 8089
            :debug nil
            ;; If you don&amp;#039;t turn off this,
            ;; backtrace also will be written to the
            ;; *error-output*.
            :use-default-middlewares nil)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you can pass as the output a variable pointing to the stream:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:backtrace :output *trace-output*)
             *app*)
            :port 8090
            :debug nil
            :use-default-middlewares nil)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another interesting option is &lt;code&gt;:result-on-error&lt;/code&gt;. It can be a function or a list with the response data. This way we can return a customized error response:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:backtrace :output &amp;quot;/tmp/errors.log&amp;quot;
                         :result-on-error
                         &amp;#039;(500 (:content-type &amp;quot;text/plain&amp;quot;)
                           (&amp;quot;Stay patient. &amp;quot;
                            &amp;quot;We already fixing this error in the REPL&amp;quot;)))
             *app*)
            :port 8092
            :debug nil
            :use-default-middlewares nil)

POFTHEDAY&amp;gt; (handler-case (dex:get &amp;quot;http://localhost:8092/foo/bar&amp;quot;)
             (error (condition)
               condition))

#&amp;lt;DEXADOR.ERROR:HTTP-REQUEST-INTERNAL-SERVER-ERROR {1009B3BA03}&amp;gt;

POFTHEDAY&amp;gt; (dexador:response-status *)
500
POFTHEDAY&amp;gt; (dexador:response-body **)
&amp;quot;Stay patient. We already fixing this error in the REPL&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Specifying a function as an error handler allows you to render an error response using information from the unhandled condition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun make-error-response (condition)
             (list 500 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                   (list (format nil
                                 &amp;quot;Unhandled error: ~A&amp;quot;
                                 condition))))

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:backtrace :output &amp;quot;/tmp/errors.log&amp;quot;
                         :result-on-error
                         #&amp;#039;make-error-response)
             *app*)
            :port 8093
            :use-default-middlewares nil)

POFTHEDAY&amp;gt; (handler-case (dex:get &amp;quot;http://localhost:8093/foo/bar&amp;quot;)
             (error (condition)
               (values (dex:response-status condition)
                       (dex:response-body condition))))
500
&amp;quot;Unhandled error: Oh my God!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice, I didn&apos;t specify a &lt;code&gt;:debug nil&lt;/code&gt; argument for &lt;code&gt;clackup&lt;/code&gt;. When you are using &lt;code&gt;:result-on-error&lt;/code&gt; argument on backtrace middleware, it will return a response before the lisp debugger will have a chance to pop up.&lt;/p&gt;
&lt;p&gt;If you want to invoke debugger in some cases, you can call a &lt;code&gt;(invoke-debugger condition)&lt;/code&gt; somewhere inside &lt;code&gt;make-error-response&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;Yesterday we&apos;ll review some other Lack&apos;s middleware.&lt;/p&gt;
</description>
            <pubDate>Tue, 23 Jun 2020 23:15:52 +0300</pubDate>
        </item>
        <item>
            <title>lack</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0107-lack.html</link>
            <description>&lt;p&gt;&lt;code&gt;Lack&lt;/code&gt; is a library, used by &lt;code&gt;Clack&lt;/code&gt; to compose web apps from middlewares.&lt;/p&gt;
&lt;p&gt;Yesterday &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0106-lack-middleware-accesslog.html&quot;&gt;we&apos;ve used&lt;/a&gt; the &lt;code&gt;lack-middleware-accesslog&lt;/code&gt; system to log every request to our webapp. But app configuration was not convenient. &lt;code&gt;Lack&lt;/code&gt; provides a macro to compose an application from middlewares:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lack:builder
              ;; middlewares
              :accesslog
              ;; the app
              (lambda (env)
                (declare (ignorable env))
                &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                  (&amp;quot;Hello, World&amp;quot;)))))

POFTHEDAY&amp;gt; (clack:clackup *app*
                          :port 8080)
Hunchentoot server is started.
Listening on 127.0.0.1:8080.

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8080/foo/bar&amp;quot;))
127.0.0.1 - [22/Jun/2020:22:15:23 +03:00] &amp;quot;GET /foo/bar HTTP/1.1&amp;quot;
         200 12 &amp;quot;-&amp;quot; &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can pass a middleware as a keyword or as a s-exp. In the slatter case, all values except the first one, will be passed to the middleware functions.&lt;/p&gt;
&lt;p&gt;This way a middleware can be configured. Here is for example, how we can replace a logging function to use &lt;code&gt;log4cl&lt;/code&gt; (by the way, remind me to tell you about &lt;code&gt;log4cl&lt;/code&gt;, it is wonderful!):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lack:builder
              ;; middlewares
              (:accesslog :logger
                          (lambda (message)
                            (log:info message)))
              ;; the app
              (lambda (env)
                (declare (ignorable env))
                &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                  (&amp;quot;Hello, World&amp;quot;)))))

POFTHEDAY&amp;gt; (clack:clackup *app*
                          :port 8081)

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8081/foo/bar&amp;quot;))

 &amp;lt;INFO&amp;gt; [22:38:06] poftheday () -
  POFTHEDAY::MESSAGE: &amp;quot;127.0.0.1 - [22/Jun/2020:22:38:06 +03:00] 
                \&amp;quot;GET /foo/bar HTTP/1.1\&amp;quot; 200 12 \&amp;quot;-\&amp;quot;
                \&amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0\&amp;quot;&amp;quot;
  
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Multiple middlewares can be passed to the &lt;code&gt;lack:builder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When we are specifying the middleware&apos;s name as a keyword, lack tries to search a middleware function using &lt;code&gt;lack.util:find-middleware&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lack.util:find-middleware :accesslog)

#&amp;lt;FUNCTION (LAMBDA (LACK.MIDDLEWARE.ACCESSLOG::APP &amp;amp;KEY :LOGGER :FORMATTER)
             :IN
             &amp;quot;/Users/art/projects/lisp/lisp-project-of-the-day/.qlot/dists/\
  ultralisp/software/fukamachi-lack-20200524065357/src/middleware/accesslog.lisp&amp;quot;)
  {22D1F6CB}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you intend to create an opensource library providing &lt;code&gt;Lack&lt;/code&gt; middleware and want this discovery work for it, then you have to follow these rules.&lt;/p&gt;
&lt;p&gt;Your system has to define a package prefixed with &lt;code&gt;LACK.MIDDLEWARE.&lt;/code&gt; And it should export a variable with name matched to the pattern &lt;code&gt;*LACK-MIDDLEWARE-...*&lt;/code&gt;. This variable should be bound to a middleware function.&lt;/p&gt;
&lt;p&gt;For example, access log middleware defines the &lt;code&gt;LACK.MIDDLEWARE.ACCESSLOG:*LACK-MIDDLEWARE-ACCESSLOG*&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;Another interesting feature, I didn&apos;t cover yet the ability to write an app which delays it&apos;s response or stream it back. Luckily, these kinds of applications &lt;a href=&quot;https://github.com/fukamachi/lack#delayed-response-and-streaming-body&quot;&gt;are covered by&lt;/a&gt; &lt;code&gt;Lack&lt;/code&gt;&apos;s documentation.&lt;/p&gt;
&lt;p&gt;Tomorrow, we&apos;ll look at some &lt;code&gt;Lack&apos;s&lt;/code&gt; middleware.&lt;/p&gt;
</description>
            <pubDate>Mon, 22 Jun 2020 22:32:36 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-accesslog</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0106-lack-middleware-accesslog.html</link>
            <description>&lt;p&gt;Yesterday, I&apos;ve showed you how does Clack work. A web app is a function which returns a list with the response or a function which should return create such list pass it to the provided callback.&lt;/p&gt;
&lt;p&gt;Now we&apos;ll add a logging to our app with the &lt;code&gt;lack-middleware-accesslog&lt;/code&gt; system.&lt;/p&gt;
&lt;p&gt;To do this, we must wrap our app&apos;s function into another function like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Now we&amp;#039;ll create a simple app:
POFTHEDAY&amp;gt; (defparameter *app*
             (lambda (env)
               &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                 (&amp;quot;Hello, World&amp;quot;))))

;; And wrap it into the middleware:
POFTHEDAY&amp;gt; (defparameter *app-with-access-log*
             (funcall lack.middleware.accesslog:*lack-middleware-accesslog*
                      *app*))

;; Now it&amp;#039;s time to start our app:
POFTHEDAY&amp;gt; (clack:clackup *app-with-access-log*
                          :port 8000)

Woo server is started.
Listening on 127.0.0.1:8000.

;; And to make a test request:
POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8000/&amp;quot;))
127.0.0.1 - [21/Jun/2020:22:50:52 +03:00] &amp;quot;GET / HTTP/1.1&amp;quot; 
  200 12 &amp;quot;-&amp;quot; &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Look how a log message was printed to the STDOUT.&lt;/p&gt;
&lt;p&gt;Now let&apos;s see how does this middleware works. Here is its content. It is a little bit complicated because the middleware needs to handle cases when an app returns a function instead of the normal response:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defparameter *lack-middleware-accesslog*
  (let ((no-body &amp;#039;#:no-body))
    (lambda (app &amp;amp;key
              (logger
               (lambda (output) (format t &amp;quot;~&amp;amp;~A~%&amp;quot; output)))
              (formatter #&amp;#039;default-formatter))
      (lambda (env)
        (funcall-with-cb
         app env
         (lambda (res)
           (funcall logger
                    (funcall formatter env res (now)))
           res)))))
  &amp;quot;Middleware for logging requests&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I&apos;ll show you a simpler version of this logging middleware:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Here is the middleware:
POFTHEDAY&amp;gt; (defun simple-logging (app)
             (lambda (env)
               (let ((response
                       (funcall app env)))
                 (format t &amp;quot;~A ~A -&amp;gt; ~A~%&amp;quot;
                         (getf env :request-method)
                         (getf env :path-info)
                         (car response))
                 response)))

;; And this is an example how we can apply it to our app:
POFTHEDAY&amp;gt; (defparameter *app-with-simple-log*
             (simple-logging *app*))

POFTHEDAY&amp;gt; (clack:clackup *app-with-simple-log*
                          :port 8000)
Hunchentoot server is started.
Listening on 127.0.0.1:8000.

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8000/&amp;quot;))
GET / -&amp;gt; 200
&amp;quot;Hello, World&amp;quot;

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8000/foo/bar&amp;quot;))
GET /foo/bar -&amp;gt; 200
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow we&apos;ll try the better way to apply middlewares to a Clack app.&lt;/p&gt;
</description>
            <pubDate>Sun, 21 Jun 2020 23:20:42 +0300</pubDate>
        </item>
        <item>
            <title>clack</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0105-clack.html</link>
            <description>&lt;p&gt;Today we begin our sprint around Fukamachi&apos;s web tools and will start from the Clack.&lt;/p&gt;
&lt;p&gt;Clack is an intermediate layer between the real webserver and your application code. It unifies requests parsing and you don&apos;t need to rewrite an app if you&apos;ll decide to run your app under another webserver.&lt;/p&gt;
&lt;p&gt;Today it supports FCGI, Hunchentoot, Toot, Woo, Wookie. Woo and Wookie are asynchronous and can be used to serve hundreds of simultaneous connections.&lt;/p&gt;
&lt;p&gt;Another interesting feature of Clack is that application is the only a lambda function. Because of this, the application code can be wrapped with middlewares. There are a number of middlewares: for logging, handling errors, serving static files, etc.&lt;/p&gt;
&lt;p&gt;Here is an example of the simplest app. A function should return a list of status-code, headers plist and the content. The content should be a list of strings, a vector of bytes or pathname:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *server*
             (clack:clackup
              (lambda (env)
                (declare (ignore env))
                &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                  (&amp;quot;Hello, Lisp World!&amp;quot;)))
              :port 8000))
Hunchentoot server is started.
Listening on 127.0.0.1:8000.

POFTHEDAY&amp;gt; (nth-value 0
             (dex:get &amp;quot;http://localhost:8000&amp;quot;))
&amp;quot;Hello, Lisp World!&amp;quot;

POFTHEDAY&amp;gt; (clack:stop *server*)
T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Compare this with plain Hunchentoot application:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (hunchentoot:define-easy-handler (say-yo :uri &amp;quot;/&amp;quot;) ()
             (setf (hunchentoot:content-type*)
                   &amp;quot;text/plain&amp;quot;)
             &amp;quot;Hello Lisp World&amp;quot;)

POFTHEDAY&amp;gt; (hunchentoot:start
            (make-instance &amp;#039;hunchentoot:easy-acceptor
                           :port 8002))

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8002/&amp;quot;
                    :headers &amp;#039;((&amp;quot;Custom-Header&amp;quot; . &amp;quot;Hello&amp;quot;)))
127.0.0.1 - [2020-06-20 20:58:04] &amp;quot;GET / HTTP/1.1&amp;quot; 200 16 &amp;quot;-&amp;quot; 
            &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
&amp;quot;Hello Lisp World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Clack version is more coherent. All request parameters are in one place and it is obvious how to return a status code or the headers.&lt;/p&gt;
&lt;p&gt;Here is the content of the env var passed by the Clack to the application function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; For this request:
POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8000/some/path&amp;quot;
                    :headers &amp;#039;((&amp;quot;Custom-Header&amp;quot; . &amp;quot;Hello&amp;quot;)))

;; This plist will be passed as env argument
;; to the function:
(:REQUEST-METHOD :GET
 :SCRIPT-NAME &amp;quot;&amp;quot;
 :PATH-INFO &amp;quot;/some/path&amp;quot;
 :SERVER-NAME &amp;quot;localhost&amp;quot;
 :SERVER-PORT 8000
 :SERVER-PROTOCOL :HTTP/1.1
 :REQUEST-URI &amp;quot;/some/path&amp;quot;
 :URL-SCHEME &amp;quot;http&amp;quot;
 :REMOTE-ADDR &amp;quot;127.0.0.1&amp;quot;
 :REMOTE-PORT 51325
 :QUERY-STRING NIL
 :RAW-BODY #&amp;lt;FLEXI-STREAMS:FLEXI-IO-STREAM {1009183813}&amp;gt;
 :CONTENT-LENGTH 0
 :CONTENT-TYPE NIL
 :CLACK.STREAMING T
 :CLACK.IO #&amp;lt;CLACK.HANDLER.HUNCHENTOOT::CLIENT {1009183863}&amp;gt;
 :HEADERS #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 4 {1009183AE3}&amp;gt;)

;; And here is the content of the HEADERS:
POFTHEDAY&amp;gt; (rutils:print-hash-table
            (getf * :headers))
#{EQUAL
  &amp;quot;user-agent&amp;quot; &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
  &amp;quot;host&amp;quot; &amp;quot;localhost:8000&amp;quot;
  &amp;quot;accept&amp;quot; &amp;quot;*/*&amp;quot;
  &amp;quot;custom-header&amp;quot; &amp;quot;Hello&amp;quot;
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow we&apos;ll review a Clack middleware and see how to apply to the app.&lt;/p&gt;
</description>
            <pubDate>Sat, 20 Jun 2020 21:12:07 +0300</pubDate>
        </item>
        <item>
            <title>pcall</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0104-pcall.html</link>
            <description>&lt;p&gt;This library contains a few primitives for parallel code execution. It is like a baby lparallel.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PCall&lt;/code&gt; provides a thread pool, few macro to execute and wait parallel task and a thread-safe Queue.&lt;/p&gt;
&lt;p&gt;Here is a simple demo which runs two tasks in parallel and then executes a body. A digit on each line is a number of seconds elapsed since the form was evaluated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((started-at (get-universal-time)))
             (flet ((info (message &amp;amp;rest args)
                      (let ((seconds-since-start
                              (- (get-universal-time)
                                  started-at)))
                        (format t &amp;quot;~A: ~A~%&amp;quot;
                                seconds-since-start
                                (apply #&amp;#039;format nil message
                                       args)))))
               (pcall:plet ((foo (progn (info &amp;quot;Creating Foo&amp;quot;)
                                        (sleep 5)
                                        (info &amp;quot;Foo was created&amp;quot;)
                                        :foo-result))
                            (bar (progn (info &amp;quot;Creating Bar&amp;quot;)
                                        (sleep 3)
                                        (info &amp;quot;Bar was created&amp;quot;)
                                    :bar-result)))
                 (info &amp;quot;Plet&amp;#039;s body is executed immediately.&amp;quot;)
                 (info &amp;quot;And it will wait for the result when you access the value.&amp;quot;)
                 (info &amp;quot;Here is the Bar&amp;#039;s value: ~S&amp;quot;
                       bar)
                 (info &amp;quot;Task foo still executing in the background.&amp;quot;)
                 (info &amp;quot;Here is the Foo&amp;#039;s value: ~S&amp;quot;
                       foo))))
0: Plet&amp;#039;s body is executed immediately.
0: And it will wait for the result when you access the value.
0: Creating Bar
0: Creating Foo
3: Bar was created
3: Here is the Bar&amp;#039;s value: :BAR-RESULT
3: Task foo still executing in the background.
5: Foo was created
5: Here is the Foo&amp;#039;s value: :FOO-RESULT&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are a few more interesting functions allowing to execute and wait for tasks. And a thread-safe queue can be loaded using the standalone system &lt;code&gt;pcall-queue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PCall&lt;/code&gt; can be useful when you don&apos;t need such a sophisticated tool as lparallel and just want to use thread pool or queue.&lt;/p&gt;
&lt;p&gt;If you are interested in trying &lt;code&gt;PCall&lt;/code&gt;, read it&apos;s &lt;a href=&quot;http://marijn.haverbeke.nl/pcall/&quot;&gt;docs here&lt;/a&gt; because it is not hosted on the GitHub and Quickdocs.org does not show it&apos;s docs either.&lt;/p&gt;
</description>
            <pubDate>Fri, 19 Jun 2020 23:16:06 +0300</pubDate>
        </item>
        <item>
            <title>trivial-tco</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0103-trivial-tco.html</link>
            <description>&lt;p&gt;This library could be considered as a &lt;a href=&quot;http://portability.cl/&quot;&gt;portability layer&lt;/a&gt; for tail call optimization.&lt;/p&gt;
&lt;p&gt;When I first found it, I decided it implements a TCO for implementations which do not support it by doing a trampolining trick &lt;a href=&quot;https://macropy3.readthedocs.io/en/latest/tco.html#trampolining&quot;&gt;like this&lt;/a&gt;. But I was wrong.&lt;/p&gt;
&lt;p&gt;It does ensure the proper declaration is used on implementations which support a proper TCO and signals warning or error on others.&lt;/p&gt;
&lt;p&gt;Here is an example on SBCL, which supports TCO only if &lt;code&gt;speed&lt;/code&gt; declared to be greater or equal to &lt;code&gt;debug&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (declaim (optimize (debug 3) (speed 1))

POFTHEDAY&amp;gt; (labels ((sum-aux (acc x)
                        (if (zerop x)
                            acc
                            (sum-aux (+ acc x) (- x 1))))
                      (sum (n)
                        (sum-aux 0 n)))
               (sum 1000000))
Control stack guard page temporarily disabled: proceed with caution
; Debugger entered on #&amp;lt;SB-KERNEL::CONTROL-STACK-EXHAUSTED {1004F12E73}&amp;gt;
[1] POFTHEDAY&amp;gt; 
; Evaluation aborted on #&amp;lt;SB-KERNEL::CONTROL-STACK-EXHAUSTED {1004F12E73}&amp;gt;

POFTHEDAY&amp;gt; (tco:with-tail-call-optimization ()
             (labels ((sum-aux (acc x)
                        (if (zerop x)
                            acc
                            (sum-aux (+ acc x) (- x 1))))
                      (sum (n)
                        (sum-aux 0 n)))
               (sum 1000000)))
500000500000 (39 bits, #x746A5A2920)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This macro gets expanded into:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(let ()
  (declare (optimize (speed 3)))
  (labels ((sum-aux (acc x)
             (if (zerop x)
                 acc
                 (sum-aux (+ acc x) (- x 1))))
           (sum (n)
             (sum-aux 0 n)))
    (sum 1000000)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. Use this library, if you want to employ a tail call and want to ensure they a properly optimized by your Lisp implementation.&lt;/p&gt;
&lt;p&gt;Maybe &lt;a href=&quot;https://0branch.com/notes/tco-cl.html&quot;&gt;this article&lt;/a&gt; by Marc Simpson will be interesting for you. It investigates which Common Lisp implementations have a proper TCO implementation.&lt;/p&gt;
</description>
            <pubDate>Fri, 19 Jun 2020 00:35:23 +0300</pubDate>
        </item>
        <item>
            <title>lass-flexbox</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0102-lass-flexbox.html</link>
            <description>&lt;p&gt;This is an addon to the &lt;code&gt;lass&lt;/code&gt; library, reviewed in &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/03/0021-lass.html&quot;&gt;#0021 post&lt;/a&gt;. &lt;code&gt;Lass-flexbox&lt;/code&gt; adds to &lt;code&gt;lass&lt;/code&gt; an ability to expand Flexbox CSS properties into browser-specific vendor prefixes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lass:compile-and-write
            &amp;#039;(.container :flexbox
              (.item :align-self &amp;quot;center&amp;quot;)))
&amp;quot;.container{
    display: -webkit-box;
    display: -webkit-flex;
    display: -moz-flex;
    display: -ms-flexbox;
    display: flex;
}

.container .item{
    -webkit-align-self: center;
    -moz-align-self: center;
    -ms-flex-item-align: center;
    align-self: center;
}&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I found a great &lt;a href=&quot;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&quot;&gt;illustrated article&lt;/a&gt; on how does Flexbox works and now we&apos;ll try to reproduce some layout from this article:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (format t &amp;quot;&amp;lt;style&amp;gt;~A&amp;lt;/style&amp;gt;
                      &amp;lt;div class=\&amp;quot;example\&amp;quot;&amp;gt;
                        &amp;lt;div class=\&amp;quot;item\&amp;quot;&amp;gt;One&amp;lt;/div&amp;gt;
                        &amp;lt;div class=\&amp;quot;item\&amp;quot;&amp;gt;Two&amp;lt;/div&amp;gt;
                        &amp;lt;div class=\&amp;quot;item\&amp;quot;&amp;gt;Three&amp;lt;/div&amp;gt;
                      &amp;lt;/div&amp;gt;
                     &amp;quot;
                   (lass:compile-and-write
                    &amp;#039;(.example
                      :flexbox
                      :align-items &amp;quot;flex-end&amp;quot;
                      :justify-content &amp;quot;space-around&amp;quot;
                      :border 1px solid gray
                      (.item :margin 0.5rem
                             :padding 0.5rem)
                      ((:and .item (:nth-child 1))
                       :background lime
                       :flex 1
                       :height 30px)
                      ((:and .item (:nth-child 2))
                       :background orange
                       :flex 2
                       :height 70px)
                      ((:and .item (:nth-child 3))
                       :background purple
                       :flex 3
                       :height 50px))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This lisp code will generate us these CSS and HTML:&lt;/p&gt;
&lt;h4&gt;Code&lt;/h4&gt;&lt;pre&gt;&lt;code class=&apos;html :render&apos;&gt;&amp;lt;style&amp;gt;.example{
    display: -webkit-box;
    display: -webkit-flex;
    display: -moz-flex;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-align: end;
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    -moz-align-items: flex-end;
    align-items: flex-end;
    -ms-flex-pack: distribute;
    -webkit-justify-content: space-around;
    -moz-justify-content: space-around;
    justify-content: space-around;
    border: 1px solid gray;
}

.example .item{
    margin: 0.5rem;
    padding: 0.5rem;
}

.example .item:nth-child(1){
    background: lime;
    flex: 1;
    height: 30px;
}

.example .item:nth-child(2){
    background: orange;
    flex: 2;
    height: 70px;
}

.example .item:nth-child(3){
    background: purple;
    flex: 3;
    height: 50px;
}&amp;lt;/style&amp;gt;

&amp;lt;div class=&amp;quot;example&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;One&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;Two&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;Three&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;Result&lt;/h4&gt;&lt;style&gt;.example{
    display: -webkit-box;
    display: -webkit-flex;
    display: -moz-flex;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-align: end;
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    -moz-align-items: flex-end;
    align-items: flex-end;
    -ms-flex-pack: distribute;
    -webkit-justify-content: space-around;
    -moz-justify-content: space-around;
    justify-content: space-around;
    border: 1px solid gray;
}

.example .item{
    margin: 0.5rem;
    padding: 0.5rem;
}

.example .item:nth-child(1){
    background: lime;
    flex: 1;
    height: 30px;
}

.example .item:nth-child(2){
    background: orange;
    flex: 2;
    height: 70px;
}

.example .item:nth-child(3){
    background: purple;
    flex: 3;
    height: 50px;
}&lt;/style&gt;

&lt;div class=&quot;example&quot;&gt;
  &lt;div class=&quot;item&quot;&gt;One&lt;/div&gt;
  &lt;div class=&quot;item&quot;&gt;Two&lt;/div&gt;
  &lt;div class=&quot;item&quot;&gt;Three&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Exciting, isn&apos;t it!?&lt;/p&gt;
</description>
            <pubDate>Wed, 17 Jun 2020 20:25:01 +0300</pubDate>
        </item>
    </channel>
</rss>