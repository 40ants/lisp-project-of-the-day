<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>cl-qprint</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0152-cl-qprint.html</link>
            <description>&lt;p&gt;This small library implements a &lt;a href=&quot;https://tools.ietf.org/html/rfc2045#section-6.7&quot;&gt;Quoted-Printable&lt;/a&gt; encoding algorithm suitable to use in multipart emails.&lt;/p&gt;
&lt;p&gt;In this example, we&apos;ll encode a string into the quoted-printable and then back into the Lisp string. &lt;code&gt;CL-QPrint&lt;/code&gt; encodes bytes. That is why I&apos;m using &lt;a href=&quot;http://quickdocs.org/babel/&quot;&gt;babel&lt;/a&gt; here:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (babel:string-to-octets
            &amp;quot;Hello World! &amp;#x41F;&amp;#x440;&amp;#x438;&amp;#x432;&amp;#x435;&amp;#x442; &amp;#x41C;&amp;#x438;&amp;#x440;!&amp;quot;)
#(72 101 108 108 111 32 87 111 114 108 100 33
  32 208 159 209 128 208 184 208 178 208 181
  209 130 32 208 156 208 184 209 128 33)

POFTHEDAY&amp;gt; (cl-qprint:encode *)
&amp;quot;Hello=20World!=20=D0=9F=D1=80=D0=B8=D0=B2=D0=B5=D1=82=20=D0=9C=D0=B8=D1=80!&amp;quot;

;; Now we can transfer this text through the wire
;; and to decode it on other end:

POFTHEDAY&amp;gt; (cl-qprint:decode *)
#(72 101 108 108 111 32 87 111 114 108 100 33
  32 208 159 209 128 208 184 208 178 208 181
  209 130 32 208 156 208 184 209 128 33)

POFTHEDAY&amp;gt; (babel:octets-to-string *)
&amp;quot;Hello World! &amp;#x41F;&amp;#x440;&amp;#x438;&amp;#x432;&amp;#x435;&amp;#x442; &amp;#x41C;&amp;#x438;&amp;#x440;!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This encoding can be used in multipart emails instead of &lt;code&gt;base64&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It is especially useful for texts, containing a large amount of ASCII symbols. This could be source codes where some comments use international symbols.&lt;/p&gt;
</description>
            <pubDate>Wed, 05 Aug 2020 23:28:15 +0300</pubDate>
        </item>
        <item>
            <title>deeds</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0151-deeds.html</link>
            <description>&lt;p&gt;This is library by &lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@Shinmera&lt;/a&gt;. It implements a message-passing protocol.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;deeds&lt;/code&gt; you are sending events of some class to the handlers.&lt;/p&gt;
&lt;p&gt;Handlers are much like methods, but with additional abilities. For example, here is the handler which filters and process only messages containing &quot;Hello&quot;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (deeds:define-handler (foo deeds:info-event) (event message)
             :filter &amp;#039;(search &amp;quot;Hello&amp;quot; message)
             (format t &amp;quot;GREETING: ~A~%&amp;quot; message))

POFTHEDAY&amp;gt; (deeds:do-issue deeds:info-event :message &amp;quot;Blah&amp;quot;)
#&amp;lt;DEEDS:INFO-EVENT 2020.08.04 21:36:08 :ORIGIN #&amp;lt;PACKAGE &amp;quot;POFTHEDAY&amp;quot;&amp;gt; {1006D0A7E3}&amp;gt;

POFTHEDAY&amp;gt; (deeds:do-issue deeds:info-event :message &amp;quot;Hello Bob!&amp;quot;)
#&amp;lt;DEEDS:INFO-EVENT 2020.08.04 21:36:14 :ORIGIN #&amp;lt;PACKAGE &amp;quot;POFTHEDAY&amp;quot;&amp;gt; {1006D3F833}&amp;gt;
GREETING: Hello Bob!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pay attention, we see output only after the second &lt;code&gt;do-issue&lt;/code&gt; call. And it goes after the information about &lt;code&gt;DEEDS:INFO-EVENT&lt;/code&gt;, which is the result of the &lt;code&gt;do-issue&lt;/code&gt; form.&lt;/p&gt;
&lt;p&gt;All events are handled in a separate thread.&lt;/p&gt;
&lt;p&gt;You also can define your own classes for events. They should inherit from &lt;code&gt;deeds:event&lt;/code&gt; because they carry &quot;origin&quot; slot. This slot is filled by the Lisp package where the event was fired.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass my-message (deeds:event)
             ())

POFTHEDAY&amp;gt; (defclass special-message (my-message)
             ())

POFTHEDAY&amp;gt; (deeds:define-handler (foo my-message) (event)
             (format t &amp;quot;My message handled!~%&amp;quot;))

POFTHEDAY&amp;gt; (deeds:define-handler (bar special-message) (event)
             (format t &amp;quot;Special message handled!~%&amp;quot;))


POFTHEDAY&amp;gt; (deeds:do-issue my-message)
My message handled!

;; Both handlers will match because of class inheritance:
POFTHEDAY&amp;gt; (deeds:do-issue special-message)
Special message handled!
My message handled!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also other cool features, covered by &lt;a href=&quot;https://github.com/Shinmera/deeds&quot;&gt;the documentation&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are interested in Common Lisp library for message passing, read about two other systems, reviewed in the #poftheday series:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/07/0130-cl-events.html&quot;&gt;cl-events&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/07/0131-piping.html&quot;&gt;piping&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
            <pubDate>Tue, 04 Aug 2020 22:09:53 +0300</pubDate>
        </item>
        <item>
            <title>cl-speedy-queue</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0150-cl-speedy-queue.html</link>
            <description>&lt;p&gt;This system implements a non-consing queue. Internally it uses a simple vector to organize a circular buffer. First two elements of the buffer are reserved for start and end pointers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *q*
             (cl-speedy-queue:make-queue 10))

POFTHEDAY&amp;gt; *q*
#(2 2 #:EMPTY 0 0 0 0 0 0 0 0 0)

POFTHEDAY&amp;gt; (cl-speedy-queue:enqueue :a *q*)
:A

POFTHEDAY&amp;gt; (cl-speedy-queue:enqueue :b *q*)
:B

POFTHEDAY&amp;gt; (cl-speedy-queue:enqueue :c *q*)
:C

POFTHEDAY&amp;gt; *q*
#(2 5 :A :B :C 0 0 0 0 0 0 0)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When an item is extracted from the queue, the left pointer is moved to the right:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-speedy-queue:dequeue *q*)
:A
POFTHEDAY&amp;gt; *q*
#(3 5 :A :B :C 0 0 0 0 0 0 0)
POFTHEDAY&amp;gt; (cl-speedy-queue:dequeue *q*)
:B
POFTHEDAY&amp;gt; *q*
#(4 5 :A :B :C 0 0 0 0 0 0 0)
POFTHEDAY&amp;gt; (cl-speedy-queue:dequeue *q*)
:C
POFTHEDAY&amp;gt; *q*
#(5 5 :A :B :C #:EMPTY 0 0 0 0 0 0)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also a few other functions in the API: to check queue&apos;s length, to peek the next item, etc. A queue can signal conditions if it is empty or full and you are trying to do something wrong.&lt;/p&gt;
&lt;p&gt;This data structure is not thread-safe. Use locks if share queue between threads.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cl-speedy-queue&lt;/code&gt; is really fast. Queue and deque operations take about 7.5 nanoseconds:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (time (loop with q = (cl-speedy-queue:make-queue 10)
                       repeat 1000000000
                       do (cl-speedy-queue:enqueue :foo q)
                          (cl-speedy-queue:dequeue q)))
Evaluation took:
  7.588 seconds of real time
  7.573354 seconds of total run time (7.554277 user, 0.019077 system)
  99.80% CPU
  16,755,940,604 processor cycles
  0 bytes consed&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To compare, here is the test of Python&apos;s standard &lt;code&gt;SimpleQueue&lt;/code&gt;. It takes 226 nanoseconds:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;python&apos;&gt;In [10]: from queue import SimpleQueue

In [11]: def test(q, n):
    ...:     while n &amp;gt; 0:
    ...:         q.put(1)
    ...:         q.get()
    ...:         n -= 1
    ...:

In [12]: %time test(SimpleQueue(), 1000000000)
CPU times: user 3min 46s, sys: 605 ms, total: 3min 47s
Wall time: 3min 48s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Python also has another standard structure for queues - &lt;code&gt;deque&lt;/code&gt;. It is slightly faster than &lt;code&gt;SimpleQueue&lt;/code&gt; but still 18 times slower than Common Lisp&apos;s &lt;code&gt;cl-speedy-queue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It takes 141 nanoseconds to make put/get operations with &lt;code&gt;deque&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;python&apos;&gt;In [22]: from collections import deque

In [23]: def test(q, n):
    ...:     while n &amp;gt; 0:
    ...:         q.append(1)
    ...:         q.popleft()
    ...:         n -= 1

In [25]: %time test(deque(), 1000000000)
CPU times: user 2min 21s, sys: 330 ms, total: 2min 22s
Wall time: 2min 22s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By the way, Python&apos;s deque is written in C:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/python/cpython/blob/master/Modules/_collectionsmodule.c#L206&quot;&gt;https://github.com/python/cpython/blob/master/Modules/_collectionsmodule.c#L206&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Mon, 03 Aug 2020 23:44:34 +0300</pubDate>
        </item>
        <item>
            <title>cl-stream</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0149-cl-stream.html</link>
            <description>&lt;p&gt;This system defines a new streams API for CL. It is still WIP, but something already works. For example, there is how we can make a stream to read numbers from a vector:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *s*
             (cl-stream:sequence-input-stream #(1 2 3)))

;; Standard read function does not work:
POFTHEDAY&amp;gt; (read *s*)
; Debugger entered on #&amp;lt;SB-PCL::NO-APPLICABLE-METHOD-ERROR {1002EAA433}&amp;gt;

;; But cl-stream provides it&amp;#039;s own methods:
POFTHEDAY&amp;gt; (cl-stream:read *s*)
1
NIL

POFTHEDAY&amp;gt; (cl-stream:read *s*)
2
NIL

POFTHEDAY&amp;gt; (cl-stream:read *s*)
3
NIL

POFTHEDAY&amp;gt; (cl-stream:read *s*)
NIL
:EOF&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The same calls work for strings:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *s*
             (cl-stream:sequence-input-stream &amp;quot;Lisp&amp;quot;))

POFTHEDAY&amp;gt; (cl-stream:read *s*)
#\L
NIL

POFTHEDAY&amp;gt; (cl-stream:read *s*)
#\i
NIL

POFTHEDAY&amp;gt; (cl-stream:read *s*)
#\s
NIL

POFTHEDAY&amp;gt; (cl-stream:read *s*)
#\p
NIL

POFTHEDAY&amp;gt; (cl-stream:read *s*)
NIL
:EOF&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I also tried to use class for output to the sequence but seems it is incomplete. Some methods are missing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *s*
             (make-instance &amp;#039;cl-stream:sequence-output-stream
                            :element-type &amp;#039;integer))
*S*

POFTHEDAY&amp;gt; (cl-stream:sequence-output-stream-sequence *s*)
; Debugger entered on #&amp;lt;SB-PCL::NO-APPLICABLE-METHOD-ERROR {100802EEC3}&amp;gt;
[1] POFTHEDAY&amp;gt; 
; Evaluation aborted on #&amp;lt;SB-PCL::NO-APPLICABLE-METHOD-ERROR {100802EEC3}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also an interesting but not implemented idea to support blocking/non-blocking stream API calls.&lt;/p&gt;
&lt;p&gt;This library was changed a year ago, and probably the author lost interest in improving it. What do you think, does Common Lisp needs an alternative streams API?&lt;/p&gt;
</description>
            <pubDate>Sun, 02 Aug 2020 23:42:23 +0300</pubDate>
        </item>
        <item>
            <title>modf</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0148-modf.html</link>
            <description>&lt;p&gt;This system provides a macro which acts like &lt;code&gt;setf&lt;/code&gt; but does not change original data-structure. It will be useful if you want to write the code in a functional style, without side-effects:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *foo*
             &amp;#039;(#(1 2 3 4 5)
               #(6 7 8)
               #(9)))

POFTHEDAY&amp;gt; (defparameter *bar*
             (modf:modf (aref (second *foo*)
                              1)
                        :blah))

POFTHEDAY&amp;gt; *foo*
(#(1 2 3 4 5)
 #(6 7 8)
 #(9))

POFTHEDAY&amp;gt; *bar*
(#(1 2 3 4 5)
 #(6 :BLAH 8)
 #(9))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Resulting data structure can share some parts with the original:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (eq *foo*
               *bar*)
NIL

POFTHEDAY&amp;gt; (eq (first *foo*)
               (first *bar*))
T

POFTHEDAY&amp;gt; (eq (second *foo*)
               (second *bar*))
NIL

POFTHEDAY&amp;gt; (eq (third *foo*)
               (third *bar*))
T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But this does not work for some lisp forms. For example, it is impossible to change plist using &lt;code&gt;getf&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *foo*
             &amp;#039;(:name &amp;quot;Bob&amp;quot;
               :points #(1 2 3 4 5)))

POFTHEDAY&amp;gt; (defparameter *bar*
             (modf:modf (aref (getf *foo*
                                    :points)
                              2)
                        100500))
; Debugger entered on #&amp;lt;SIMPLE-ERROR &amp;quot;How shall I invert GETF?&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Hopefuly, the library can be extended and we might define our own function to modify plists:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (modf:define-modf-function getf 2 (new-val plist key)
             (let ((new-plist (copy-list plist)))
               (setf (getf new-plist key)
                     new-val)
               new-plist))

POFTHEDAY&amp;gt; (defparameter *bar*
             (modf:modf (aref (getf *foo*
                                    :points)
                              2)
                        100500))

POFTHEDAY&amp;gt; *foo*
(:NAME &amp;quot;Bob&amp;quot; :POINTS #(1 2 3 4 5))

POFTHEDAY&amp;gt; *bar*
(:NAME &amp;quot;Bob&amp;quot; :POINTS #(1 2 100500 4 5))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are a few other ways to extend &lt;code&gt;modf&lt;/code&gt;. They are listed in the documentation but there are no examples. But you can find them in the source code.&lt;/p&gt;
</description>
            <pubDate>Sat, 01 Aug 2020 20:40:32 +0300</pubDate>
        </item>
        <item>
            <title>graylex</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0147-graylex.html</link>
            <description>&lt;p&gt;This system provides a way to extract tokens from streams. This can be useful when working with data, received from the network or to read large files from disk.&lt;/p&gt;
&lt;p&gt;Here is the example of a simple parser:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (with-input-from-string (input &amp;quot;001, 110, 101&amp;quot;)
             (loop with lexer = (make-instance &amp;#039;graylex:lexer-input-stream
                                               :stream input
                                               :rules &amp;#039;((&amp;quot;0&amp;quot; . :zero)
                                                        (&amp;quot;1&amp;quot; . :one)
                                                        (&amp;quot;,&amp;quot; . :comma)
                                                        (&amp;quot; &amp;quot; . :space)))
                   for result = (multiple-value-list
                                 (graylex:stream-read-token lexer))
                   for class = (first result)
                   while class
                   collect result))
((:ZERO &amp;quot;0&amp;quot;) (:ZERO &amp;quot;0&amp;quot;) (:ONE &amp;quot;1&amp;quot;) (:COMMA &amp;quot;,&amp;quot;) (:SPACE &amp;quot; &amp;quot;)
 (:ONE &amp;quot;1&amp;quot;) (:ONE &amp;quot;1&amp;quot;) (:ZERO &amp;quot;0&amp;quot;) (:COMMA &amp;quot;,&amp;quot;) (:SPACE &amp;quot; &amp;quot;)
 (:ONE &amp;quot;1&amp;quot;) (:ZERO &amp;quot;0&amp;quot;) (:ONE &amp;quot;1&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can also use regular expressions to define rules:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (with-input-from-string (input &amp;quot;001, 110, 101&amp;quot;)
             (loop with lexer = (make-instance &amp;#039;graylex:lexer-input-stream
                                               :stream input
                                               :rules &amp;#039;((&amp;quot;\\d+&amp;quot; . :number)
                                                        (&amp;quot;,&amp;quot; . :comma)
                                                        (&amp;quot; &amp;quot; . :space)))
                   for result = (multiple-value-list
                                 (graylex:stream-read-token lexer))
                   for class = (first result)
                   while class
                   collect result))
((:NUMBER &amp;quot;001&amp;quot;) (:COMMA &amp;quot;,&amp;quot;) (:SPACE &amp;quot; &amp;quot;)
 (:NUMBER &amp;quot;110&amp;quot;) (:COMMA &amp;quot;,&amp;quot;) (:SPACE &amp;quot; &amp;quot;)
 (:NUMBER &amp;quot;101&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what if you have comma separated fields which can contain a comma if surrounded by double quotes?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (with-input-from-string (input &amp;quot;Google, Bing, \&amp;quot;Bob, Corp\&amp;quot;&amp;quot;)
             (loop with lexer = (make-instance &amp;#039;graylex:lexer-input-stream
                                               :stream input
                                               :rules &amp;#039;((&amp;quot;[^,]*&amp;quot; . :field)
                                                        (&amp;quot;,&amp;quot; . :comma)))
                   for result = (multiple-value-list
                                 (graylex:stream-read-token lexer))
                   for class = (first result)
                   while class
                   collect result))
((:FIELD &amp;quot;Google&amp;quot;) (:COMMA &amp;quot;,&amp;quot;)
 (:FIELD &amp;quot; Bing&amp;quot;) (:COMMA &amp;quot;,&amp;quot;)
 (:FIELD &amp;quot; \&amp;quot;Bob&amp;quot;) (:COMMA &amp;quot;,&amp;quot;) ;; WAT!?
 (:FIELD &amp;quot; Corp\&amp;quot;&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you see, there is a problem because the last field is surrounded by double quotes to quote the comma. To solve this problem, we need to change the rules dynamically. This will require to write a simple state machine:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *field*)
POFTHEDAY&amp;gt; (defvar *field-separator*)
POFTHEDAY&amp;gt; (defvar *quoted-string-start*)
POFTHEDAY&amp;gt; (defvar *quoted-string-end*)

POFTHEDAY&amp;gt; (with-input-from-string (input &amp;quot;Google, Bing, \&amp;quot;Bob, Corp\&amp;quot;&amp;quot;)
             (loop with lexer = (make-instance
                                  &amp;#039;graylex:lexer-input-stream
                                  :stream input
                                  :rules &amp;#039;((&amp;quot; &amp;quot; . :space)
                                           (*field* . :field)
                                           (*field-separator* . :comma)
                                           (*quoted-string-start* . :quoted-string-start)
                                           (*quoted-string-end* . :quoted-string-end)))
                   with in-quoted-string = nil
                   with *field* = &amp;quot;[^\&amp;quot;,][^,]+&amp;quot;
                   with *field-separator* = &amp;quot;,&amp;quot;
                   with *quoted-string-start* = &amp;quot;\&amp;quot;&amp;quot;
                   with *quoted-string-end* = &amp;quot;\&amp;quot;&amp;quot;
                   with tokens = nil
                   for result = (multiple-value-list
                                 (graylex:stream-read-token lexer))
                   for class = (first result)
                   while class
                   do (push result tokens)
                      (when (eq class :quoted-string-start)
                        (if in-quoted-string
                            (setf *field-separator* &amp;quot;,&amp;quot;
                                  *field* &amp;quot;[^\&amp;quot;,][^,]+&amp;quot;
                                  in-quoted-string nil)
                            (setf *field-separator* &amp;quot;&amp;quot;
                                  *field* &amp;quot;[^\&amp;quot;]+&amp;quot;
                                  in-quoted-string t)))
                   finally (return (nreverse tokens))))
((:FIELD &amp;quot;Google&amp;quot;) (:COMMA &amp;quot;,&amp;quot;) (:SPACE &amp;quot; &amp;quot;)
 (:FIELD &amp;quot;Bing&amp;quot;) (:COMMA &amp;quot;,&amp;quot;) (:SPACE &amp;quot; &amp;quot;)
 (:QUOTED-STRING-START &amp;quot;\&amp;quot;&amp;quot;) (:FIELD &amp;quot;Bob, Corp&amp;quot;) (:QUOTED-STRING-START &amp;quot;\&amp;quot;&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here I&apos;m changing rules depending on if we are inside of the quoted string or not.&lt;/p&gt;
</description>
            <pubDate>Fri, 31 Jul 2020 22:41:29 +0300</pubDate>
        </item>
        <item>
            <title>crypto-shortcuts</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0146-crypto-shortcuts.html</link>
            <description>&lt;p&gt;Crypto-shortcuts serves a single purpose - to reduce an amount of headache when you have to encrypt, decrypt or make some kind of hash.&lt;/p&gt;
&lt;p&gt;This &lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@Shinmera&lt;/a&gt;&apos;s library has a &lt;a href=&quot;http://shinmera.github.io/crypto-shortcuts/&quot;&gt;nice documentation&lt;/a&gt;. Today I lack time, so here is the only one example of making a sha256 hash out of string.&lt;/p&gt;
&lt;p&gt;This code which uses plain &lt;code&gt;flexi-streams&lt;/code&gt; and &lt;code&gt;ironclad&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let* ((octets (flexi-streams:string-to-octets
                           &amp;quot;Hello World!&amp;quot;
                           :external-format :utf-8))
                  (digest (ironclad:digest-sequence
                           &amp;#039;ironclad:sha256
                           octets)))
             (ironclad:byte-array-to-hex-string digest))
&amp;quot;7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Compare it with the code, using &lt;code&gt;crypto-shortcuts&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cryptos:sha256 &amp;quot;Hello World!&amp;quot;)
&amp;quot;7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fa3d677284addd200126d9069&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library definitely should be in a toolbox of any common-lisper!&lt;/p&gt;
</description>
            <pubDate>Thu, 30 Jul 2020 22:30:20 +0300</pubDate>
        </item>
        <item>
            <title>utilities.print-items</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0145-utilities.print-items.html</link>
            <description>&lt;p&gt;This is a library by &lt;a href=&quot;https://twitter.com/scymtym&quot;&gt;@scymtym&lt;/a&gt;. It provides a composable way to write &lt;code&gt;print-object&lt;/code&gt; methods for complex class hierarchies.&lt;/p&gt;
&lt;p&gt;It has a &lt;a href=&quot;https://github.com/scymtym/utilities.print-items&quot;&gt;good tutorial&lt;/a&gt;. Just to give you idea for cases where it can be useful, consider you have the following class hierarchy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ((last-seen :initform (local-time:now)
                         :reader user-last-seen)))

POFTHEDAY&amp;gt; (defclass anonymous (user)
             ())

POFTHEDAY&amp;gt; (defclass registered-user (user)
             ((name :initarg :name :reader user-name)))

POFTHEDAY&amp;gt; (defclass admin (registered-user)
             ((privileges :initform nil
                          :initarg :privileges
                          :reader admin-privileges)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;For you want to define a &lt;code&gt;print-object&lt;/code&gt; methods for these objects which outputs all object field, then you&apos;ll have to repeat them all in each method, like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (make-instance &amp;#039;admin
                          :name &amp;quot;Bob&amp;quot;
                          :privileges &amp;#039;(:read-all :add-users))
#&amp;lt;ADMIN {10097677E3}&amp;gt;

POFTHEDAY&amp;gt; (make-instance &amp;#039;registered-user
                          :name &amp;quot;Alla&amp;quot;)
#&amp;lt;REGISTERED-USER {100458FE43}&amp;gt;


POFTHEDAY&amp;gt; (defmethod print-object ((user admin) stream)
             (print-unreadable-object (user stream :type t :identity t)
               (format stream &amp;quot;~A privileges=~A last-seen=~A&amp;quot;
                       (user-name user)
                       (admin-privileges user)
                       (user-last-seen user))))

POFTHEDAY&amp;gt; (defmethod print-object ((user registered-user) stream)
             (print-unreadable-object (user stream :type t :identity t)
               (format stream &amp;quot;~A last-seen=~A&amp;quot;
                       (user-name user)
                       (user-last-seen user))))


POFTHEDAY&amp;gt; (make-instance &amp;#039;registered-user
                          :name &amp;quot;Alla&amp;quot;)
#&amp;lt;REGISTERED-USER Alla last-seen=2020-07-29T16:18:57.595959+03:00 {100489DD43}&amp;gt;

POFTHEDAY&amp;gt; (make-instance &amp;#039;admin
                          :name &amp;quot;Bob&amp;quot;
                          :privileges &amp;#039;(:read-all :add-users))
#&amp;lt;ADMIN Bob privileges=(READ-ALL ADD-USERS) last-seen=2020-07-29T16:17:15.458722+03:00 {10044E9183}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is cumbersome and not composable at all. &lt;code&gt;Utilities.print-items&lt;/code&gt; provides a protocol where each object can report about pieces it owns and a single &lt;code&gt;print-object&lt;/code&gt; method uses this information to output all necessary parts of the object presentation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defmethod print-object ((user user) stream)
             (print-unreadable-object (user stream :type t :identity t)
               (print-items:format-print-items
                stream
                (print-items:print-items user))))


POFTHEDAY&amp;gt; (defmethod print-items:print-items append ((object user))
             `((:last-seen ,(user-last-seen object)
                           &amp;quot;last-seen=~A&amp;quot;)))

POFTHEDAY&amp;gt; (defmethod print-items:print-items append ((object registered-user))
             `((:name ,(user-name object)
                      &amp;quot;~A &amp;quot;
                      ((:before :last-seen)))))

POFTHEDAY&amp;gt; (defmethod print-items:print-items append ((object admin))
             `((:privileges ,(admin-privileges object)
                            &amp;quot;privileges=~A &amp;quot;
                            ((:after :name)
                             (:before :last-seen)))))


POFTHEDAY&amp;gt; (make-instance &amp;#039;registered-user
                          :name &amp;quot;Alla&amp;quot;)
#&amp;lt;REGISTERED-USER Alla last-seen=2020-07-29T16:45:50.711253+03:00 {100441F9C3}&amp;gt;

POFTHEDAY&amp;gt; (make-instance &amp;#039;admin
                          :name &amp;quot;Bob&amp;quot;
                          :privileges &amp;#039;(:read-all :add-users))
#&amp;lt;ADMIN Bob privileges=(READ-ALL ADD-USERS) last-seen=2020-07-29T16:44:27.433569+03:00 {100440A133}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a special mixin class, which can be used instead of custom &lt;code&gt;print-object&lt;/code&gt; method:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (remove-method #&amp;#039;print-object
                          (find-method #&amp;#039;print-object &amp;#039;()
                                       &amp;#039;(user t)))
POFTHEDAY&amp;gt; (make-instance &amp;#039;admin
                          :name &amp;quot;Bob&amp;quot;
                          :privileges &amp;#039;(:read-all :add-users))
#&amp;lt;ADMIN {1004537653}&amp;gt;

POFTHEDAY&amp;gt; (defclass user (print-items:print-items-mixin)
             ((last-seen :initform (local-time:now)
                         :reader user-last-seen)))

POFTHEDAY&amp;gt; (make-instance &amp;#039;admin
                          :name &amp;quot;Bob&amp;quot;
                          :privileges &amp;#039;(:read-all :add-users))
#&amp;lt;ADMIN Bob privileges=(READ-ALL ADD-USERS) last-seen=2020-07-29T16:53:56.089722+03:00 {10073D2FF3}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/scymtym&quot;&gt;@scymtym&lt;/a&gt; did a great job, generalizing this printing facility. Use it when you have deep class hierarchies.&lt;/p&gt;
</description>
            <pubDate>Wed, 29 Jul 2020 21:46:00 +0300</pubDate>
        </item>
        <item>
            <title>scriptl</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0144-scriptl.html</link>
            <description>&lt;p&gt;This system implements a very interesting idea. It makes it very easy to call any lisp function from the command line.&lt;/p&gt;
&lt;p&gt;The cool part of this story is the ability to quickly hack on your functions in the Emacs while calling them from the command line. This can be especially useful in many cases like writing a plugin for &lt;a href=&quot;https://getbitbar.com/&quot;&gt;the BitBar&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScriptL&lt;/code&gt; consists of three parts:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a server, running in your lisp image&lt;/li&gt;&lt;li&gt;a client binary for passing parameters to the server and returning   results&lt;/li&gt;&lt;li&gt;a thin wrapper for each command.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Here is a minimal example to show you how it works.&lt;/p&gt;
&lt;p&gt;The first command starts the server. Second, defines the usual function and third creates a shell script &quot;hello-world&quot; in the current directory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (scriptl:start)

POFTHEDAY&amp;gt; (defun hello-world (&amp;amp;optional (name &amp;quot;Anonymous&amp;quot;))
             (format t &amp;quot;Hello, ~A!~%&amp;quot; name))

POFTHEDAY&amp;gt; (scriptl:make-script &amp;quot;hello-world&amp;quot;
                                &amp;#039;hello-world)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s switch to the command line and call our function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[poftheday] ./hello-world
Hello, Anonymous!

[poftheday] ./hello-world Bob
Hello, Bob!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how the wrapper looks like under the hood:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;text&apos;&gt;[poftheday] cat hello-world
#!/bin/sh
SCRIPTLCOM=&amp;quot;./.qlot/dists/quicklisp/software/
            scriptl-20180228-git/src/scriptlcom/src/scriptlcom&amp;quot;
FUNCTION=&amp;quot;POFTHEDAY::HELLO-WORLD&amp;quot;
ERRORS=&amp;quot;COMMON-LISP::NIL&amp;quot;
SYSTEM=&amp;quot;&amp;quot;

$SCRIPTLCOM --sl-version 2 -E &amp;quot;$ERRORS&amp;quot; -l &amp;quot;$SYSTEM&amp;quot; -f &amp;quot;$FUNCTION&amp;quot; -- &amp;quot;$@&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, it calls &lt;code&gt;scriptlcom&lt;/code&gt; binary, written in C.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ScriptL&lt;/code&gt; server can also be started on a remote machine, but the documentation does not cover this setup.&lt;/p&gt;
&lt;p&gt;Playing with this system I recall where I seen a similar way of calling the server from the command line. It is possible with &lt;code&gt;CL-Gearman&lt;/code&gt;, reviewed in &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0095-cl-gearman.html&quot;&gt;post number 0095&lt;/a&gt;. Gearman has a command-line client but, is more suitable for server-server communication.&lt;/p&gt;
</description>
            <pubDate>Tue, 28 Jul 2020 20:40:04 +0300</pubDate>
        </item>
        <item>
            <title>cl-html-diff</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0143-cl-html-diff.html</link>
            <description>&lt;p&gt;Yesterday I&apos;ve reviewed the &lt;code&gt;cl-difflib&lt;/code&gt; and today I want to show you a library which uses &lt;code&gt;cl-difflib&lt;/code&gt; to compare HTML files. It parses both HTML&apos;s into nodes and compares these node lists:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (html-diff:html-diff
            &amp;quot;
&amp;lt;p&amp;gt;This is the HTML &amp;lt;b&amp;gt;Hello World&amp;lt;/b&amp;gt;:&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second iem&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;quot;
            &amp;quot;
&amp;lt;p&amp;gt;This is the HTML &amp;lt;i&amp;gt;Hello World&amp;lt;/i&amp;gt;:&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;quot;)

;; Result
&amp;quot;
&amp;lt;p&amp;gt;This is the HTML &amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;b&amp;gt;&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;i&amp;gt;&amp;lt;/ins&amp;gt;Hello World&amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/ins&amp;gt;:&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second &amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;iem&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;item&amp;lt;/ins&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;quot;
4 ;; don&amp;#039;t touched nodes
3 ;; replaced nodes
0 ;; inserted nodes
0 ;; deleted nodes&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the result rendered by the browser:&lt;/p&gt;
&lt;h4&gt;Code&lt;/h4&gt;&lt;pre&gt;&lt;code class=&apos;html :render&apos;&gt;&amp;lt;p&amp;gt;This is the HTML &amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;b&amp;gt;&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;i&amp;gt;&amp;lt;/ins&amp;gt;Hello World&amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/ins&amp;gt;:&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second &amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;iem&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;item&amp;lt;/ins&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;Result&lt;/h4&gt;&lt;p&gt;This is the HTML &lt;del class=\&quot;diff\&quot;&gt;&lt;b&gt;&lt;/del&gt;&lt;ins class=\&quot;diff\&quot;&gt;&lt;i&gt;&lt;/ins&gt;Hello World&lt;del class=\&quot;diff\&quot;&gt;&lt;/b&gt;&lt;/del&gt;&lt;ins class=\&quot;diff\&quot;&gt;&lt;/i&gt;&lt;/ins&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;First item&lt;/li&gt;
  &lt;li&gt;Second &lt;del class=\&quot;diff\&quot;&gt;iem&lt;/del&gt;&lt;ins class=\&quot;diff\&quot;&gt;item&lt;/ins&gt;&lt;/li&gt;
  &lt;li&gt;Third item&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;You can see how it highlighted the fixed typo in the &lt;code&gt;item&lt;/code&gt; word, but wasn&apos;t able to figure out how to process changed tag around &quot;Hello World&quot; :(&lt;/p&gt;
&lt;p&gt;Such a library can be used to compare HTML documents rendered by some markup engined. For example, &lt;code&gt;cl-markdown&lt;/code&gt; uses it in its test suite, to compare results produced by CL engine and original Perl version of Markdown.&lt;/p&gt;
</description>
            <pubDate>Tue, 28 Jul 2020 20:15:44 +0300</pubDate>
        </item>
        <item>
            <title>cl-difflib</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0142-cl-difflib.html</link>
            <description>&lt;p&gt;This library is able to compute differences between sequences. For example, if we want to generate a unified diff for two lists of strings, we can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (difflib:unified-diff
            t
            &amp;#039;(&amp;quot;one&amp;quot; &amp;quot;two&amp;quot; &amp;quot;three&amp;quot; &amp;quot;four&amp;quot; &amp;quot;five&amp;quot; &amp;quot;six&amp;quot;)
            &amp;#039;(&amp;quot;one&amp;quot; &amp;quot;three&amp;quot; &amp;quot;four&amp;quot; &amp;quot;seven&amp;quot; &amp;quot;eight&amp;quot;)
            :test-function &amp;#039;equal)

---  
+++  
@@ -1,6 +1,5 @@
 one
-two
 three
 four
-five
-six
+seven
+eight&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is also possible to provide filenames:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (difflib:unified-diff
            t
            &amp;#039;(&amp;quot;one&amp;quot; &amp;quot;two&amp;quot; &amp;quot;three&amp;quot; &amp;quot;four&amp;quot; &amp;quot;five&amp;quot; &amp;quot;six&amp;quot;)
            &amp;#039;(&amp;quot;one&amp;quot; &amp;quot;three&amp;quot; &amp;quot;four&amp;quot; &amp;quot;seven&amp;quot; &amp;quot;eight&amp;quot;)
            :test-function &amp;#039;equal
            :from-file &amp;quot;a.txt&amp;quot;
            :to-file &amp;quot;b.txt&amp;quot;)

--- a.txt 
+++ b.txt 
@@ -1,6 +1,5 @@
 one
-two
 three
 four
-five
-six
+seven
+eight&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a lower-level API. We can make a diff of any objects. Here is an example of how to get a diff of two lists of symbols:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *diff*
             (make-instance &amp;#039;difflib:sequence-matcher
                            :a &amp;#039;(:one :two :three :four :five :six)
                            :b &amp;#039;(:one :three :four :seven :eight)))

POFTHEDAY&amp;gt; (difflib:get-opcodes *diff*)
(#&amp;lt;DIFFLIB:OPCODE :EQUAL   0 1 0 1&amp;gt;
 #&amp;lt;DIFFLIB:OPCODE :DELETE  1 2 1 1&amp;gt;
 #&amp;lt;DIFFLIB:OPCODE :EQUAL   2 4 1 3&amp;gt;
 #&amp;lt;DIFFLIB:OPCODE :REPLACE 4 6 3 5&amp;gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These &quot;opcodes&quot; tell us what to do with subsequences of two lists. For example, &lt;code&gt;REPLACE&lt;/code&gt; opcode from the results tell us that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; This should be replaced:
POFTHEDAY&amp;gt; (subseq &amp;#039;(:one :two :three :four :five :six)
                   4 6)
(:FIVE :SIX)

;; with:
POFTHEDAY&amp;gt; (subseq &amp;#039;(:one :three :four :seven :eight)
                   3 5)
(:SEVEN :EIGHT)

;; The same as we seen in the text output in the beginning:
--- a.txt 
+++ b.txt 
@@ -1,6 +1,5 @@
 one
-two
 three
 four
-five
-six
+seven
+eight&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorow we&apos;ll see the library, which uses &lt;code&gt;cl-difflib&lt;/code&gt; for something more interesting.&lt;/p&gt;
</description>
            <pubDate>Sun, 26 Jul 2020 22:38:01 +0300</pubDate>
        </item>
        <item>
            <title>cl-flow</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0141-cl-flow.html</link>
            <description>&lt;p&gt;&lt;code&gt;CL-Flow&lt;/code&gt; is &lt;a href=&quot;https://twitter.com/borodust&quot;&gt;@borodust&lt;/a&gt;&apos;s library and provides a way for lock-free parallel code execution. You can combine blocks of code and define how they should be executed - serially or in parallel.&lt;/p&gt;
&lt;p&gt;This system is in the Quicklisp, but is not installable because requires &lt;code&gt;bodge-queue&lt;/code&gt; which is not in the Quicklisp yet (or now). You need to install @borodust&apos;s distribution first:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDDAY&amp;gt; (ql-dist:install-dist
             &amp;quot;http://bodge.borodust.org/dist/org.borodust.bodge.txt&amp;quot;
             :replace t :prompt nil)

POFTHEDAY&amp;gt; (ql:quickload &amp;#039;(:simple-flow-dispatcher
                           :cl-flow
                           :log4cl
                           :dexador))

POFTHEDAY&amp;gt; (defun handle-error (e)
             (log:error &amp;quot;Unhandled error&amp;quot; e))

;; This code will help us to run flow blocks
;; in the thread pool:
POFTHEDAY&amp;gt; (defvar *dispatcher*
             (simple-flow-dispatcher:make-simple-dispatcher
              :threads 4
              :error-handler #&amp;#039;handle-error))

POFTHEDAY&amp;gt; (defun run (flow)
             (cl-flow:run *dispatcher* flow))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is an example from &lt;code&gt;cl-flow&lt;/code&gt;&apos;s documentation.&lt;/p&gt;
&lt;p&gt;This code will run three blocks of code in parallel and then pass their results into another block:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (run (flow:serially
                  (flow:concurrently
                    (flow:atomically :first ()
                      &amp;quot;Hello&amp;quot;)
                    (flow:atomically :second ()
                      &amp;quot;Lisp&amp;quot;)
                    (flow:atomically :third ()
                      &amp;quot;World&amp;quot;))
                  ;; Last block will receive results
                  ;; of all previous blocks:
                  (flow:atomically :finally (results)
                    (destructuring-bind (first second third)
                        results
                      (format t &amp;quot;~A ~A ~A~%&amp;quot;
                              first
                              second
                              third)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sadly, the documentation does not cover a more interesting topic - blocks which generate other blocks. Let&apos;s try to figure out how to use &lt;code&gt;flow:dynamically&lt;/code&gt; to define a web crawler which will process pages recursively:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *base-url*
             &amp;quot;https://borodust.org/projects/cl-flow/&amp;quot;)

POFTHEDAY&amp;gt; (defun is-external (url)
             (or (str:starts-with-p &amp;quot;mailto:&amp;quot; url)
                 (and (str:starts-with-p &amp;quot;http&amp;quot; url)
                      (not (str:starts-with-p *base-url* url)))))

POFTHEDAY&amp;gt; (defun make-full (url)
             (let ((new-url
                     (cond
                       ((or (str:starts-with-p &amp;quot;http&amp;quot; url)
                            (str:starts-with-p &amp;quot;mailto:&amp;quot; url))
                        url)
                       ((str:starts-with-p &amp;quot;/&amp;quot; url)
                        (concatenate &amp;#039;string &amp;quot;https://borodust.org&amp;quot; url))
                       (t
                        (concatenate &amp;#039;string *base-url* url)))))
               (cl-ppcre:regex-replace &amp;quot;#.*&amp;quot; new-url &amp;quot;&amp;quot;)))

POFTHEDAY&amp;gt; (defun make-url-processor (already-processed url)
             (flow:serially
               (flow:atomically url ()
                 (log:info &amp;quot;Downloading ~A&amp;quot; url)
                 (dex:get url))

               ;; This block creates new blocks where each
               ;; will process a single url and produce more
               ;; blocks to process links from fetched pages:
               (flow:dynamically (content)
                 (flow:concurrently
                   (loop with page = (ignore-errors
                                      (plump:parse content))
                         for link in (when page
                                       (plump:get-elements-by-tag-name page &amp;quot;a&amp;quot;))
                         for link-url = (plump:attribute link &amp;quot;href&amp;quot;)
                         for full-url = (make-full link-url)
                         unless (or (is-external full-url)
                                    (gethash full-url already-processed))
                           collect (progn
                                     (setf (gethash full-url already-processed)
                                           t)
                                     (make-url-processor already-processed
                                                         full-url)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can start it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((already-processed (make-hash-table :test &amp;#039;equal)))
             (run
              (make-url-processor already-processed *base-url*))
             already-processed)

 &amp;lt;INFO&amp;gt; [23:10:00] poftheday (make-url-processor body-fu3) -
  Downloading https://borodust.org/projects/
#&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 0 {10073D59A3}&amp;gt;
 &amp;lt;INFO&amp;gt; [23:10:00] poftheday (make-url-processor body-fu3) -
  Downloading https://borodust.org/projects/vinoyaku/
...
 &amp;lt;INFO&amp;gt; [23:10:01] poftheday (make-url-processor body-fu3) -
  Downloading https://borodust.org/projects/cl-bodge/overview/

;; These URL were processed by our crawler:
POFTHEDAY&amp;gt; (rutils:hash-table-to-alist *)
((&amp;quot;https://borodust.org/projects/vinoyaku/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/trivial-gamekit/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/cl-flow/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/cl-bodge/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/cl-flow/getting-started/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/trivial-gamekit/getting-started/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/trivial-gamekit/advanced/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/trivial-gamekit/manual/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/cl-bodge/overview/&amp;quot; . T))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It would be nice if &lt;a href=&quot;https://twitter.com/borodust&quot;&gt;@borodust&lt;/a&gt; will do a little code review and check if I used &lt;code&gt;cl-flow&lt;/code&gt; correctly or not.&lt;/p&gt;
</description>
            <pubDate>Sat, 25 Jul 2020 23:26:42 +0300</pubDate>
        </item>
        <item>
            <title>cl-mechanize</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0140-cl-mechanize.html</link>
            <description>&lt;p&gt;The README says this library tries to be a Perl&apos;s WWW:Mechanize clon. There is also Python library &lt;a href=&quot;https://github.com/python-mechanize/mechanize&quot;&gt;mechanize&lt;/a&gt; as well. Seems the stateful web scrapers is popular among some developers.&lt;/p&gt;
&lt;p&gt;When I tried cl-mechanize to log into Reddit, it didn&apos;t work. The &lt;code&gt;fetch&lt;/code&gt; function should discover all forms with their inputs but the login form was empty. Without CSRF token I wasn&apos;t able to log in.&lt;/p&gt;
&lt;p&gt;But I found a fork &lt;a href=&quot;https://github.com/ilook/cl-mechanize&quot;&gt;https://github.com/ilook/cl-mechanize&lt;/a&gt; where this problem was fixed.&lt;/p&gt;
&lt;p&gt;Let&apos;s create a program which will fetch your karma and latest comments from the Reddit!&lt;/p&gt;
&lt;p&gt;First, we need to log in. Mechanize operates on the &lt;code&gt;browser&lt;/code&gt; object which keeps the information about the current page and cookies:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *browser*
             (make-instance &amp;#039;cl-mechanize:browser))

POFTHEDAY&amp;gt; (cl-mechanize:fetch &amp;quot;https://www.reddit.com/login/&amp;quot;
                               *browser*)
#&amp;lt;CL-MECHANIZE:PAGE {100A2D7FA3}&amp;gt;

POFTHEDAY&amp;gt; (mechanize:page-forms *)
(#&amp;lt;CL-MECHANIZE:FORM {100A2D4923}&amp;gt;)

POFTHEDAY&amp;gt; (defparameter *login-form* (first *))

POFTHEDAY&amp;gt; (mechanize:form-inputs *login-form*)
((&amp;quot;otp-type&amp;quot; . &amp;quot;app&amp;quot;) (&amp;quot;otp&amp;quot; . &amp;quot;&amp;quot;) (&amp;quot;password&amp;quot; . &amp;quot;&amp;quot;) (&amp;quot;username&amp;quot; . &amp;quot;&amp;quot;)
 (&amp;quot;is_mobile_ui&amp;quot; . &amp;quot;False&amp;quot;) (&amp;quot;ui_mode&amp;quot; . &amp;quot;&amp;quot;) (&amp;quot;frontpage_signup_variant&amp;quot; . &amp;quot;&amp;quot;)
 (&amp;quot;is_oauth&amp;quot; . &amp;quot;False&amp;quot;)
 (&amp;quot;csrf_token&amp;quot; . &amp;quot;ba038152b86951ab28725c37ed0b3e96d640d083&amp;quot;)
 (&amp;quot;dest&amp;quot; . &amp;quot;https://www.reddit.com&amp;quot;) (&amp;quot;cookie_domain&amp;quot; . &amp;quot;.reddit.com&amp;quot;))

POFTHEDAY&amp;gt; (setf (alexandria:assoc-value
                  (mechanize:form-inputs *login-form*)
                  &amp;quot;username&amp;quot; :test #&amp;#039;string=)
                 &amp;quot;svetlyak40wt&amp;quot;)

POFTHEDAY&amp;gt; (setf (alexandria:assoc-value
                  (mechanize:form-inputs *login-form*)
                  &amp;quot;password&amp;quot; :test #&amp;#039;string=)
                 &amp;quot;********&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, ilook&apos;s version of the cl-mechanize does not work either. It fails on form submission with the following error:&lt;/p&gt;
&lt;p&gt;&quot;Don&apos;t know how to handle method :|post|.&quot;&lt;/p&gt;
&lt;p&gt;To overcome this issue we&apos;ll set the method to the proper keyword:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (setf (mechanize:form-method *login-form*)
                 :post)

POFTHEDAY&amp;gt; (mechanize:submit *login-form* *browser*)

POFTHEDAY&amp;gt; (cl-mechanize:fetch &amp;quot;https://www.reddit.com/&amp;quot;
                               *browser*)

POFTHEDAY&amp;gt; (cl-ppcre:scan-to-strings
            &amp;quot;(\\d+) karma&amp;quot;
            (mechanize:page-content *))
&amp;quot;708 karma&amp;quot;
#(&amp;quot;708&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we&apos;ll fetch last 3 comments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Mechanize can be enchanced to handle relative URLs:
POFTHEDAY&amp;gt; (cl-mechanize:fetch &amp;quot;/message/inbox&amp;quot;
                               *browser*)
; Debugger entered on #&amp;lt;DRAKMA:PARAMETER-ERROR
; &amp;quot;Don&amp;#039;t know how to handle scheme ~S.&amp;quot; {100252AA63}&amp;gt;

;; I found that page /message/inbox does not countain messages
;; and you have to fetch this instead:
POFTHEDAY&amp;gt; (cl-mechanize:fetch &amp;quot;https://www.reddit.com/message/inbox?embedded=true&amp;quot;
                               *browser*)
; Debugger entered on #&amp;lt;TYPE-ERROR expected-type: STRING datum: NIL&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you see, &lt;code&gt;cl-mechanize&lt;/code&gt; failed on fetching this simple page. This library is 10 years old and still has so many bugs :(&lt;/p&gt;
&lt;p&gt;Also, I found very unpleasant to work with &lt;code&gt;cxml-stp&lt;/code&gt;&apos;s API. &lt;code&gt;CL-Mechanize&lt;/code&gt; parses the page&apos;s body into &lt;code&gt;cxml&lt;/code&gt; data structures and it was hard to figure out how to search the nodes I need.&lt;/p&gt;
&lt;p&gt;If you know about some other Common Lisp library that is able to keep cookies and suitable for web scraping, please, let me know.&lt;/p&gt;
</description>
            <pubDate>Fri, 24 Jul 2020 21:08:15 +0300</pubDate>
        </item>
        <item>
            <title>papyrus</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0139-papyrus.html</link>
            <description>&lt;p&gt;In &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/04/0050-literate-lisp.html&quot;&gt;post number 50&lt;/a&gt; I&apos;ve reviewed the &lt;code&gt;literate-lisp&lt;/code&gt; system which allows to write you lisp code in &lt;code&gt;org-mode&lt;/code&gt; files and to load them as usual lisp files.&lt;/p&gt;
&lt;p&gt;Papyrus does a similar trick but for Markdown files. It adds a named readtable to load markdown files as usual lisp code.&lt;/p&gt;
&lt;p&gt;The library itself is less than 20 lines of code!&lt;/p&gt;
&lt;p&gt;Here is how does the hello world look like using a literate programming style and Papyrus:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;markdown&apos;&gt;(defpackage #:hello-world
      (:use :cl :named-readtables))
    (in-package #:hello-world)
    
    (in-readtable :papyrus)

# Hello world with Papyrus

As you probably know, every programmer starts his learning of the
new programming language from the &amp;quot;hello world&amp;quot; program.

Simplest hello world program outputs a text &amp;quot;Hello World!&amp;quot; in console and exit.

Here is how we can output this program in Common Lisp:

```lisp
(defun main ()
    (princ &amp;quot;Hello World!&amp;quot;)
    (terpri))
```&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can load it and run our &lt;code&gt;main&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (ql:quickload :papyrus)

POFTHEDAY&amp;gt; (load &amp;quot;docs/media/0139/hello.md&amp;quot;)
T

POFTHEDAY&amp;gt; (hello-world::main)
Hello World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you can add markdown files as ASDF system&apos;s dependencies!&lt;/p&gt;
&lt;p&gt;However, there are view drawbacks because of Markdown&apos;s limitations and Papyrus simplicity:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;All files have to start with an indented block of code to set proper read-table.&lt;/li&gt;&lt;li&gt;Emacs does not understand the current package when you are doing &lt;code&gt;C-c   C-c&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;It is impossible to define blocks of lisp code which shouldn&apos;t be   evaluated.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;But &lt;code&gt;literate-lisp&lt;/code&gt; system addresses all these issues.&lt;/p&gt;
</description>
            <pubDate>Thu, 23 Jul 2020 22:22:03 +0300</pubDate>
        </item>
        <item>
            <title>freebsd-sysctl</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0138-freebsd-sysctl.html</link>
            <description>&lt;p&gt;This library works on OSX because of its BSD roots, but fails on Linux with error: &quot;The alien function &apos;sysctlnametomib&apos; is undefined.&quot;&lt;/p&gt;
&lt;p&gt;It provides information about the system.&lt;/p&gt;
&lt;p&gt;Here is a quick example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (freebsd-sysctl:sysctl-by-name &amp;quot;kern.hostname&amp;quot;)
&amp;quot;poftheday&amp;quot;

POFTHEDAY&amp;gt; (freebsd-sysctl:sysctl-by-name &amp;quot;kern.ostype&amp;quot;)
&amp;quot;Darwin&amp;quot;

POFTHEDAY&amp;gt; (freebsd-sysctl:sysctl-by-name &amp;quot;machdep.cpu.core_count&amp;quot;)
6&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using this library and &lt;code&gt;cl-spark&lt;/code&gt;, &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/07/0124-cl-spark.html&quot;&gt;reviewed two weeks ago&lt;/a&gt;, we can build a simple tool to monitor the CPU&apos;s temperature:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (loop with num-probes = 30
                 with probes = ()
                 for current = (freebsd-sysctl:sysctl-by-name
                                &amp;quot;machdep.xcpm.cpu_thermal_level&amp;quot;)
                 do (push current probes)
                    (setf probes
                          (subseq probes 0
                                  (min num-probes
                                       (length probes))))
                    (format t &amp;quot;~A ~A~%~%&amp;quot;
                            (cl-spark:spark
                             (reverse probes)
                             :min 30)
                            current)
                    (sleep 15))

&amp;#x2588;&amp;#x2587;&amp;#x2587;&amp;#x2587;&amp;#x2587;&amp;#x2587;&amp;#x2587;&amp;#x2586;&amp;#x2586;&amp;#x2585;&amp;#x2584;&amp;#x2584;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2584;&amp;#x2584;&amp;#x2584;&amp;#x2584;&amp;#x2584;&amp;#x2584; 53
...
&amp;#x2583;&amp;#x2582;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2582;&amp;#x2582;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2584;&amp;#x2585;&amp;#x2586;&amp;#x2587;&amp;#x2588; 93
...
&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2585;&amp;#x2585;&amp;#x2586;&amp;#x2587;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2587;&amp;#x2586;&amp;#x2585;&amp;#x2584; 66
...
&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2585;&amp;#x2585;&amp;#x2586;&amp;#x2587;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2587;&amp;#x2586;&amp;#x2585;&amp;#x2584;&amp;#x2583;&amp;#x2582;&amp;#x2582;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581; 21&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To find out different keys supported by your system do &lt;code&gt;sysctl -a&lt;/code&gt; in console.&lt;/p&gt;
</description>
            <pubDate>Wed, 22 Jul 2020 21:52:20 +0300</pubDate>
        </item>
        <item>
            <title>thread.comm.rendezvous</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0137-thread.comm.rendezvous.html</link>
            <description>&lt;p&gt;This system provides a simple thread synchronization primitive called &lt;a href=&quot;https://en.wikipedia.org/wiki/Rendezvous_(Plan_9)&quot;&gt;Rendezvous&lt;/a&gt;. It allows exchanging pieces of data between threads.&lt;/p&gt;
&lt;p&gt;Here is how it works. You create a &lt;code&gt;rendezvous&lt;/code&gt; object. Then you might create one or many threads and each of them can either to &quot;call&quot; &lt;code&gt;rendezvous&lt;/code&gt; and pass it some value or to &quot;accept&quot; value and return a result.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Accept&lt;/code&gt; blocks the calling thread until some other thread will not &lt;code&gt;call&lt;/code&gt; and vice-versa. This is similar to a thread-safe blocking queue of size 1:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *r*
             (thread.comm.rendezvous:make-rendezvous))

POFTHEDAY&amp;gt; (bt:make-thread
            (lambda ()
              (log:info &amp;quot;Waiting for value&amp;quot;)
              (let ((value (thread.comm.rendezvous:accept-rendezvous *r*)))
                (log:info &amp;quot;Value received: ~S&amp;quot; value))))

&amp;lt;INFO&amp;gt; [2020-07-21T23:06:56.836061+03:00] Waiting for value

POFTHEDAY&amp;gt; (thread.comm.rendezvous:call-rendezvous
            *r*
            :the-value-to-be-sent-to-the-thread)

&amp;lt;INFO&amp;gt; [2020-07-21T23:07:46.642640+03:00] Value received: :THE-VALUE-TO-BE-SENT-TO-THE-THREAD&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I wasn&apos;t able to imagine a more complex but short illustration of the case where this synchronization primitive can be useful. If you know one, please share your ideas in comments.&lt;/p&gt;
</description>
            <pubDate>Tue, 21 Jul 2020 23:34:42 +0300</pubDate>
        </item>
        <item>
            <title>log4cl-extras</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0136-log4cl-extras.html</link>
            <description>&lt;p&gt;Yesterday I&apos;ve posted about the &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/07/0135-log4cl.html&quot;&gt;log4cl&lt;/a&gt; and promised to tell you about my addons. The library is called &lt;code&gt;log4cl-extras&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The main purpose of &lt;code&gt;log4cl-extras&lt;/code&gt; is to make logging suitable for production. It provides &lt;code&gt;JSON&lt;/code&gt; formatter, a macro to capture context variables and a macro to log unhandled tracebacks.&lt;/p&gt;
&lt;p&gt;Capturing context variables makes each log entry self-sustained. Also, this way you can use do a &quot;request_id&quot; trick to bind many related log messages into a single track.&lt;/p&gt;
&lt;p&gt;To show you how does &quot;request_id&quot; trick works, let me create a simple Clack application which will handle a request, simulate the query to the database and use logging.&lt;/p&gt;
&lt;p&gt;Pay attention how does it use &lt;code&gt;log4cl-extras/context:with-fields&lt;/code&gt; to capture &lt;code&gt;request-id&lt;/code&gt; variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun get-current-user ()
             &amp;quot;This is a fake function simulating SQL queries to database.&amp;quot;
             (log:debug &amp;quot;SELECT * FROM users WHERE ...&amp;quot;)
             (values &amp;quot;Bob&amp;quot;))

POFTHEDAY&amp;gt; (defun handle-request (env)
             (let* ((headers (getf env :headers))
                    (request-id (or (gethash &amp;quot;x-request-id&amp;quot; headers)
                                    (format nil &amp;quot;~A&amp;quot; (uuid:make-v4-uuid)))))
               (log4cl-extras/context:with-fields (:request-id request-id)
                 (log:debug &amp;quot;Processing request&amp;quot;)
                 (let ((user (get-current-user)))
                   (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                         (list (format nil &amp;quot;Hello ~A!&amp;quot; user)))))))

POFTHEDAY&amp;gt; (defparameter *server*
             (clack:clackup &amp;#039;handle-request
                            :port 8081))
Hunchentoot server is started.
Listening on 127.0.0.1:8081.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can initialize logging and make a few HTTP requests:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (log4cl-extras/config:setup
            &amp;#039;(:level :debug
              :appenders ((this-console :layout :plain))))

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8081/&amp;quot;)
&amp;lt;DEBUG&amp;gt; [2020-07-20T23:23:28.293441+03:00] Processing request
  Fields:
    request-id: 0E0D035A-B24F-4E69-806C-ACACE6C6B08E
&amp;lt;DEBUG&amp;gt; [2020-07-20T23:23:28.295783+03:00] SELECT * FROM users WHERE ...
  Fields:
    request-id: 0E0D035A-B24F-4E69-806C-ACACE6C6B08E
&amp;quot;Hello Bob!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Our app is able to use request id passed as an HTTP header &lt;code&gt;X-Request-ID&lt;/code&gt;. This is useful when you have many microservices and want to have a single trail of all their logs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8081/&amp;quot;
                    :headers &amp;#039;((&amp;quot;X-Request-ID&amp;quot; . &amp;quot;Custom ID :)))))&amp;quot;)))
&amp;lt;DEBUG&amp;gt; [2020-07-20T23:29:04.123354+03:00] Processing request
  Fields:
    request-id: Custom ID :)))))
&amp;lt;DEBUG&amp;gt; [2020-07-20T23:29:04.123412+03:00] SELECT * FROM users WHERE ...
  Fields:
    request-id: Custom ID :)))))
&amp;quot;Hello Bob!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This plain text log format is convenient when you are debugging the application. But in production you either want to &lt;code&gt;grep&lt;/code&gt; log messages or to feed them to the Elastic Search for further indexing.&lt;/p&gt;
&lt;p&gt;In both cases it is more convenient to write each messages as a single-line JSON object:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (log4cl-extras/config:setup
            &amp;#039;(:level :debug
              :appenders ((this-console :layout :json))))

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8081/&amp;quot;)
{&amp;quot;fields&amp;quot;:{&amp;quot;request-id&amp;quot;:&amp;quot;20A7...&amp;quot;},&amp;quot;level&amp;quot;:&amp;quot;DEBUG&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Processing request&amp;quot;,&amp;quot;timestamp&amp;quot;:&amp;quot;2020-07-20T23:32:34.566029+03:00&amp;quot;}
{&amp;quot;fields&amp;quot;:{&amp;quot;request-id&amp;quot;:&amp;quot;20A7...&amp;quot;},&amp;quot;level&amp;quot;:&amp;quot;DEBUG&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;SELECT * FROM users WHERE ...&amp;quot;,&amp;quot;timestamp&amp;quot;:&amp;quot;2020-07-20T23:32:34.566167+03:00&amp;quot;}
&amp;quot;Hello Bob!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;log4cl-extras&lt;/code&gt; also contains a macro to capture unhandled errors along with their tracebacks. It is also very useful for production. I&apos;m using this facility to capture errors in Ultralisp.org.&lt;/p&gt;
&lt;p&gt;Read &lt;code&gt;log4cl-extra&lt;/code&gt;&apos;s documentation to learn more:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/40ants/log4cl-extras&quot;&gt;https://github.com/40ants/log4cl-extras&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Mon, 20 Jul 2020 23:39:29 +0300</pubDate>
        </item>
        <item>
            <title>log4cl</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0135-log4cl.html</link>
            <description>&lt;p&gt;This is the mystery why I didn&apos;t review any logging library so far! Probably, because there is a &lt;a href=&quot;https://www.sites.google.com/site/sabraonthehill/comparison-of-lisp-logging-libraries&quot;&gt;great article&lt;/a&gt; exists which compares 8 logging libraries.&lt;/p&gt;
&lt;p&gt;Today I want only mention that my library of choice is &lt;code&gt;log4cl&lt;/code&gt;. Mostly because if it&apos;s great integration with SLIME/SLY which helps when you have a lot&apos;s of &quot;debug&quot; logging in the app, but at some moment want to turn it on only for a function or a package.&lt;/p&gt;
&lt;p&gt;Log4cl has &lt;a href=&quot;https://github.com/sharplispers/log4cl&quot;&gt;great documentation&lt;/a&gt; which demonstrates all its features. Here I&apos;ll provide only a small example of its default logging output and ability to process additional arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (log:config :sane2 :debug)

POFTHEDAY&amp;gt; (defun foo (first-arg second-arg)
             (log:info &amp;quot;Entering into the foo with&amp;quot; first-arg &amp;quot;and&amp;quot; second-arg))

POFTHEDAY&amp;gt; (foo 100500 &amp;quot;Blah&amp;quot;)

 &amp;lt;INFO&amp;gt; [21:04:10] poftheday (foo) -
  Entering into the foo with FIRST-ARG: 100500 and SECOND-ARG: &amp;quot;Blah&amp;quot; 

;; Now I want to process arguments with in format-like style:

POFTHEDAY&amp;gt; (defun foo (first-arg second-arg)
             (log:info &amp;quot;Entering into the (foo ~A ~A)&amp;quot; first-arg second-arg))

POFTHEDAY&amp;gt; (foo 100500 &amp;quot;Blah&amp;quot;)
 &amp;lt;INFO&amp;gt; [21:04:53] poftheday (foo) - Entering into the (foo 100500 Blah)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow I&apos;ll show you addons I&apos;ve made, to make &lt;code&gt;log4cl&lt;/code&gt; even more suitable for production applications.&lt;/p&gt;
</description>
            <pubDate>Sun, 19 Jul 2020 21:07:55 +0300</pubDate>
        </item>
        <item>
            <title>taglib</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0134-taglib.html</link>
            <description>&lt;p&gt;The first post in the #poftheday series was about &lt;code&gt;cl-mpg123&lt;/code&gt; library. It failed on attempt to process metadata of mp3 file. Today we&apos;ll try &lt;code&gt;taglib&lt;/code&gt;. This is the pure CL library to process MP3, MP4, FLAC tags.&lt;/p&gt;
&lt;p&gt;Let&apos;s try it on the file from the zero post!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (audio-streams:open-audio-file
            &amp;quot;docs/media/0000/file.mp3&amp;quot;)
#&amp;lt;ID3:MP3-FILE {10036524E3}&amp;gt;

POFTHEDAY&amp;gt; (abstract-tag:show-tags *)
/Users/art/projects/poftheday/docs/media/0000/file.mp3
1 frame read, MPEG 1, Layer III, CBR, sample rate: 44,100 Hz, bit rate: 320 Kbps, duration: 7:15
    album: Rogue&amp;#039;s Gallery: Pirate Ballads, Sea Songs, and Chanteys
    artist: Baby Gramps
    comment: ((0 eng  NIL))
    compilation: no
    cover: (Size: 9,870)
    genre: Folk
    lyrics:  
    title: Cape Cod Girls
    track: (1 23)
    year: 2006
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a possibility to access specific fields:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (audio-streams:open-audio-file
            &amp;quot;docs/media/0000/file.mp3&amp;quot;)
#&amp;lt;ID3:MP3-FILE {10027E6093}&amp;gt;

POFTHEDAY&amp;gt; (id3:id3-header *)
#&amp;lt;ID3:ID3-HEADER {10027E60D3}&amp;gt;

POFTHEDAY&amp;gt; (id3:v21-tag-header *)
#&amp;lt;ID3:V21-TAG-HEADER {10027E6363}&amp;gt;

POFTHEDAY&amp;gt; (id3:album *)
&amp;quot;Rogue&amp;#039;s Gallery: Pirate Ballad&amp;quot;

POFTHEDAY&amp;gt; (id3:title **)
&amp;quot;Cape Cod Girls&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Seems it works very good!&lt;/p&gt;
</description>
            <pubDate>Sat, 18 Jul 2020 22:42:56 +0300</pubDate>
        </item>
        <item>
            <title>open-location-code</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0133-open-location-code.html</link>
            <description>&lt;p&gt;This is an interesting way to encode coordinates on the planet Earth.&lt;/p&gt;
&lt;p&gt;These codes can be short enough to remember them, and they are pronounceable. What is essential – they supported by Google.&lt;/p&gt;
&lt;p&gt;For example, I have an architectural landmark in nearby Bykovo village - the &lt;a href=&quot;https://ru.wikipedia.org/wiki/Усадьба_Быково&quot;&gt;Vorontcov-Dashkov&apos;s mansion&lt;/a&gt;. Its coordinates are &lt;code&gt;55.608093&lt;/code&gt;, &lt;code&gt;38.048927&lt;/code&gt; or &lt;code&gt;55&#xB0;36&apos;29.1&quot;N 38&#xB0;02&apos;56.1&quot;E&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This building has no address, but we can get an &quot;open location code&quot; for its location on Google Maps:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0133/map.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;J25X+6H&lt;/code&gt; is the shortened open location code for this location.&lt;/p&gt;
&lt;p&gt;You can get the full code using latitude, longitude and one line of Lisp code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:encode
            55.608093
            38.048927)
&amp;quot;9G7WJ25X+6H&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The code &lt;code&gt;9G7WJ25X+6H&lt;/code&gt; is full. It has all information to get back our latitude and longitude:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:decode &amp;quot;9G7WJ25X+6H&amp;quot;)
#&amp;lt;OPEN-LOCATION-CODE:CODE-AREA {1002BF7E13}&amp;gt;
:FULL

POFTHEDAY&amp;gt; (open-location-code:south-west-corner *)
6951/125 (55.608)
304391/8000 (38.048874)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But for short code this will not work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:decode &amp;quot;J25X+6H&amp;quot;)
#&amp;lt;OPEN-LOCATION-CODE:CODE-AREA {10067CAAB3}&amp;gt;
:SHORT

POFTHEDAY&amp;gt; (open-location-code:south-west-corner *)
76/125 (0.608, 304/5%)
391/8000 (0.048875, 391/80%)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To get the coordinates, you need to &quot;recover&quot; the full code first. This is done using some reference point. For example, we can take the nearest village&apos;s coordinates as the reference point:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:recover
            &amp;quot;J25X+6H&amp;quot;
            55.634068
            38.044629)
&amp;quot;9G7WJ25X+6H&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is the same code we&apos;ve received from mansion&apos;s coordinates. You can open the Google Maps and search the code &lt;code&gt;9G7WJ25X+6H&lt;/code&gt; to check it. In real life short codes are used together with the name of the nearest city, like &lt;code&gt;J25X+6H Быково, Московская обл.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;That is for today. For me, open location codes were an exciting discovery. Didn&apos;t hear about them before.&lt;/p&gt;
</description>
            <pubDate>Fri, 17 Jul 2020 23:38:24 +0300</pubDate>
        </item>
    </channel>
</rss>