<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>cl-reddit</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0096-cl-reddit.html</link>
            <description>&lt;p&gt;This is an API wrapper for Reddit.&lt;/p&gt;
&lt;p&gt;Today I found &lt;a href=&quot;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&quot;&gt;an interesting thread from SpaceX&lt;/a&gt;, where it&apos;s software developers answer the questions. I wondered if there was a discussion around Lisp in the Space?&lt;/p&gt;
&lt;p&gt;But this post has about 8000 comments and I didn&apos;t found a search in a single post&apos;s comments on the Reddit. So, I decided to use &lt;code&gt;cl-reddit&lt;/code&gt; to fetch all post comments and to search through them a &quot;lisp&quot; term.&lt;/p&gt;
&lt;p&gt;Here is how you can connect to the Reddit and list of your subreddits:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *user*
             (cl-reddit:api-login
              :username &amp;quot;svetlyak40wt&amp;quot;
              :password *password*))

;; This is how we can retrieve a list of my subreddits:

POFTHEDAY&amp;gt; (mapcar #&amp;#039;cl-reddit:subreddit-title
                   (cl-reddit::get-reddits-mine *user*))
(&amp;quot;programming&amp;quot; &amp;quot;Lisp Advocates&amp;quot; &amp;quot;Lisp&amp;quot; &amp;quot;Scheme Programming Language articles&amp;quot;
 &amp;quot;M-x emacs-reddit&amp;quot; &amp;quot;Web Startups&amp;quot; &amp;quot;Common Lisp&amp;quot; &amp;quot;Filmmakers&amp;quot; &amp;quot;coding&amp;quot;
 &amp;quot;Github: social coding&amp;quot; &amp;quot;EarthPorn: Amazing images of light and landscape&amp;quot;
 &amp;quot;LISP ja&amp;quot; &amp;quot;Learn Lisp&amp;quot; &amp;quot;Startup Accelerators&amp;quot; &amp;quot;defunkydrummer&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot;
 &amp;quot;Steel Bank Common Lisp&amp;quot;
 &amp;quot;(find-if (alexandria:conjoin #&amp;#039;funny-p #&amp;#039;about-lisp-p) *reddit*)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But we want to run a search in the post comments, right?&lt;/p&gt;
&lt;p&gt;Then we need to extract post id from this link:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&quot;&gt;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;and to fetch comments tree using &lt;code&gt;cl-reddit&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-reddit::get-comments &amp;quot;gxb7j1&amp;quot; *user*)

(#&amp;lt;CL-REDDIT:COMMENT {1002009693}&amp;gt; #&amp;lt;CL-REDDIT:COMMENT {10020098F3}&amp;gt;
 #&amp;lt;CL-REDDIT:COMMENT {1002016BF3}&amp;gt; #&amp;lt;CL-REDDIT:COMMENT {1002016CB3}&amp;gt;
 ...
 #&amp;lt;CL-REDDIT:COMMENT {1002016D73}&amp;gt; #&amp;lt;CL-REDDIT:MORE {1002016E33}&amp;gt;)

POFTHEDAY&amp;gt; (length *)
151&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Well, we received 151 comments, but real comments count is about 7.7k. This is because other items either replies or &lt;code&gt;CL-REDDIT:MORE&lt;/code&gt; objects which contain ids of the replies:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; &apos;&gt;POFTHEDAY&amp;gt; (defparameter *comments*
              (cl-reddit::get-comments &amp;quot;gxb7j1&amp;quot; *user*))

POFTHEDAY&amp;gt; (rutils:last-elt *comments*)
#&amp;lt;CL-REDDIT:MORE {1002016E33}&amp;gt;

POFTHEDAY&amp;gt; (cl-reddit:more-children *)
(&amp;quot;ft35r7m&amp;quot; &amp;quot;ft0rpxi&amp;quot; &amp;quot;ft0jn61&amp;quot; &amp;quot;ft34002&amp;quot; &amp;quot;ft4b6z4&amp;quot;
 ...
 &amp;quot;ft0pado&amp;quot; ...)

POFTHEDAY&amp;gt; (cl-reddit:comment-replies
               (first *comments*))
(#&amp;lt;CL-REDDIT:MORE {1003607093}&amp;gt;)

POFTHEDAY&amp;gt; (cl-reddit:comment-replies
               (second *comments*))
(#&amp;lt;CL-REDDIT:COMMENT {1007607293}&amp;gt;)

POFTHEDAY&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We need to write a comment walker which &lt;code&gt;cl-reddit&lt;/code&gt; does not provide.&lt;/p&gt;
&lt;p&gt;This walker will expand all &lt;code&gt;MORE&lt;/code&gt; items and collect comments into the flat list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((post-id &amp;quot;gxb7j1&amp;quot;))
             (uiop:while-collecting (collect)
               (labels ((visit (item)
                          (etypecase item
                            (cl-reddit:comment
                             (collect item)
                             (mapc #&amp;#039;visit
                                   (cl-reddit:comment-replies
                                    item)))
                            (cl-reddit:more
                             (expand-more item))))
                        (expand-more (more)
                          (loop for id in (cl-reddit:more-children more)
                                for comments = (cl-reddit::get-comments
                                                post-id
                                                *user*
                                                :comment id)
                                do (mapc #&amp;#039;visit
                                         comments))))
                 (mapcar #&amp;#039;visit
                         (cl-reddit::get-comments post-id
                                                  *user*)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When I started this code the first time, it broke my Lisp. A quick investigation showed a resource leak. This library uses &lt;a href=&quot;https://edicl.github.io/drakma/&quot;&gt;Drakma&lt;/a&gt; for data fetching and instead of receiving response bodies, request a stream.&lt;/p&gt;
&lt;p&gt;Drakma&apos;s documentation says, that you might need to close the stream. If you don&apos;t - a connection to the server remains opene.&lt;/p&gt;
&lt;p&gt;Seems, the library&apos;s author never used it for making thousands of requests.&lt;/p&gt;
&lt;p&gt;I&apos;ve fixed this leak, but comments fetching still was too slow - about 2 comments per second. This is because &lt;code&gt;MORE&lt;/code&gt; item contains comment ids and I have to fetch them individually one by one.&lt;/p&gt;
&lt;p&gt;I tried to parallelize the fetching process using lparallel, reviewed two days ago:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *all-comments*
             (let ((post-id &amp;quot;gxb7j1&amp;quot;)
                 (counter 0))
               (uiop:while-collecting (collect)
                 (labels ((visit (item)
                            (etypecase item
                              (cl-reddit:comment
                               (collect item)
                               (incf counter)
                               (when (zerop (mod counter 10))
                                 (log:info &amp;quot;~A comments collected&amp;quot;
                                           counter))
                               (mapc #&amp;#039;visit (cl-reddit:comment-replies item)))
                              (cl-reddit:more
                               (expand-more item))))
                          (expand-more (more)
                            (log:info &amp;quot;Expanding&amp;quot; more)
                            (loop with more-ids = (cl-reddit:more-children more)
                                  with replies = (lparallel:pmapcar
                                                  (lambda (id)
                                                    (cl-reddit::get-comments
                                                     post-id
                                                     *user*
                                                     :comment id))
                                                  more-ids)
                                  for comments in replies
                                  do (lparallel:pmapc #&amp;#039;visit comments))))
                   (lparallel:pmapc #&amp;#039;visit
                           (cl-reddit::get-comments post-id
                                                    *user*))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But encountered these strange errors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;The condition Socket error in &amp;quot;connect&amp;quot;: EINTR (Interrupted system call) occurred with errno: 0.

Condition USOCKET:TIMEOUT-ERROR was signalled.
   [Condition of type USOCKET:TIMEOUT-ERROR]

Restarts:
 0: [TRANSFER-ERROR] Transfer this error to a dependent thread, if one exists.
 1: [KILL-ERRORS] Kill errors in workers (remove debugger instances).
 2: [ABORT] abort thread (#&amp;lt;THREAD &amp;quot;lparallel&amp;quot; RUNNING {10071B3DE3}&amp;gt;)

Backtrace:
 0: (USOCKET::HANDLE-CONDITION #&amp;lt;SB-EXT:TIMEOUT {10059E7C53}&amp;gt; #&amp;lt;USOCKET:STREAM-USOCKET {100871AB43}&amp;gt; &amp;quot;www.reddit.com&amp;quot;)
 1: (SB-KERNEL::%SIGNAL #&amp;lt;SB-EXT:TIMEOUT {10059E7C53}&amp;gt;)
 2: (ERROR SB-EXT:TIMEOUT)
 3: (USOCKET:SOCKET-CONNECT &amp;quot;www.reddit.com&amp;quot; 80 :PROTOCOL :STREAM :ELEMENT-TYPE FLEXI-STREAMS:OCTET :TIMEOUT 20 :DEADLINE NIL :NODELAY :IF-SUPPORTED :LOCAL-HOST NIL :LOCAL-PORT NIL)
 4: (DRAKMA:HTTP-REQUEST #&amp;lt;PURI:URI http://www.reddit.com/comments/gxb7j1.json?comment=ft3odzl&amp;gt; :METHOD :GET :USER-AGENT &amp;quot;cl-reddit/0.2 (common lisp api wrapper)&amp;quot; :COOKIE-JAR #&amp;lt;DRAKMA:COOKIE-JAR (with 5 c..
 5: (CL-REDDIT::GET-JSON &amp;quot;http://www.reddit.com/comments/gxb7j1.json?comment=ft3odzl&amp;quot; #&amp;lt;CL-REDDIT:USER {10079B9973}&amp;gt;)
 6: (CL-REDDIT:GET-COMMENTS &amp;quot;gxb7j1&amp;quot; #&amp;lt;CL-REDDIT:USER {10079B9973}&amp;gt; :ARTICLE NIL :COMMENT &amp;quot;ft3odzl&amp;quot; :CONTEXT NIL :DEPTH NIL :LIMIT NIL :SORT NIL :THREADED NIL :SHOWMORE NIL)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tried to switch to the Dexador instead of Drakma, but found another bug - it is not able to work in multiple threads:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fukamachi/dexador/issues/88&quot;&gt;https://github.com/fukamachi/dexador/issues/88&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So, we&apos;ll never know if SpaceX developers are using Lisp in their space ships :)&lt;/p&gt;
</description>
            <pubDate>Thu, 11 Jun 2020 23:45:15 +0300</pubDate>
        </item>
        <item>
            <title>cl-gearman</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0095-cl-gearman.html</link>
            <description>&lt;p&gt;Yesterday, we &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0094-lfarm.html&quot;&gt;talked about&lt;/a&gt; distributing jobs across a cluster using &lt;code&gt;lfarm&lt;/code&gt;. &lt;code&gt;lfarm&lt;/code&gt; is not well suited to environments where worker hosts can go down and return back later.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gearman.org/&quot;&gt;Gearman&lt;/a&gt; is the RPC server. Multiple workers can connect to this server and advertise which functions they are supporting. A client can call these functions and receive a result.&lt;/p&gt;
&lt;p&gt;Here is the diagram showing how does it work in the common case:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0095/gearman-cluster.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A cool feature of Gearman is its language independence. Workers can be written in any language. This means that in your distributed system some functions can be written in Lisp, others in Python or even in Bash and some UNIX tools.&lt;/p&gt;
&lt;p&gt;Now we&apos;ll see how to write a simple worker in Common Lisp and call it. But first, let&apos;s start Gearman server in the Docker container:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; bash&apos;&gt;[art@poftheday:~]% docker run --rm -p 4730:4730 artefactual/gearmand:1.1.19.1-alpine
Unable to find image &amp;#039;artefactual/gearmand:1.1.19.1-alpine&amp;#039; locally
1.1.19.1-alpine: Pulling from artefactual/gearmand
cbdbe7a5bc2a: Pull complete
33291983401c: Pull complete
b4a2ffd9f406: Pull complete
c5f0c79c81bd: Pull complete
c3b95f315fd4: Pull complete
e8fb3c47a5c3: Pull complete
Digest: sha256:585921f3509b86a9e78aac6c3512c894e0f0a8e0497d194483bafc5ebc275edc
Status: Downloaded newer image for artefactual/gearmand:1.1.19.1-alpine
   INFO 2020-06-10 13:34:35.722249 [  main ] Initializing Gear on port 4730 with SSL: false
   INFO 2020-06-10 13:34:35.000000 [  main ] Starting up with pid 1, verbose is set to INFO
   INFO 2020-06-10 13:34:35.000000 [  main ] Listening on 0.0.0.0:4730 (9)
   INFO 2020-06-10 13:34:35.000000 [  main ] Adding event for listening socket (9)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, we need to start a simple worker which supports two functions. It can reverse any string and report about it&apos;s Lisp implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-gearman:with-worker (worker &amp;quot;localhost:4730&amp;quot;)
             (cl-gearman:add-ability worker &amp;quot;get-implementation&amp;quot;
                                     (lambda (arg job)
                                       (declare (ignorable arg job))
                                       (format nil &amp;quot;~A ~A&amp;quot;
                                               (lisp-implementation-type)
                                               (lisp-implementation-version))))
             (cl-gearman:add-ability worker &amp;quot;reverse&amp;quot;
                                     (lambda (arg job)
                                       (declare (ignorable job))
                                       (reverse arg)))
             (loop (cl-gearman:work worker)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is how we can call these functions from the console:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; bash&apos;&gt;[art@poftheday:~]% echo &amp;#039;Hello Lisp World!&amp;#039; | gearman -f reverse
!dlroW psiL olleH

[art@poftheday:~]% echo &amp;#039;&amp;#039; | gearman -f get-implementation
SBCL 2.0.2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This way you can communicate with the Lisp from the outer world.&lt;/p&gt;
&lt;p&gt;If we want to call these functions from other Lisp program, then we can do it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;OTHER-LISP&amp;gt; (cl-gearman:with-client (client &amp;quot;localhost:4730&amp;quot;)
              (format t &amp;quot;~A&amp;quot;
                      (cl-gearman:submit-job client &amp;quot;reverse&amp;quot;
                                             :arg &amp;quot;Hello Lisp World!&amp;quot;)))
!dlroW psiL olleH

OTHER-LISP&amp;gt; (cl-gearman:with-client (client &amp;quot;localhost:4730&amp;quot;)
              (format t &amp;quot;~A&amp;quot;
                      (cl-gearman:submit-job client &amp;quot;get-implementation&amp;quot;)))
SBCL 2.0.2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gearman uses a very simple protocol. Every function accepts only one string as its argument. If you want to pass something complex, you&apos;ll need to use some sort of serialization.&lt;/p&gt;
&lt;p&gt;For example, here is how I use &lt;code&gt;cl-store&lt;/code&gt; and &lt;code&gt;base64&lt;/code&gt; to pass lisp data-structures between a worker and a client in Ultralisp.org:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ultralisp/ultralisp/blob/f52411bd89dc5b0bcb6701e4ba0712dd5aee128b/src/rpc/core.lisp#L23-L47&quot;&gt;https://github.com/ultralisp/ultralisp/blob/f52411bd89dc5b0bcb6701e4ba0712dd5aee128b/src/rpc/core.lisp#L23-L47&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;That is it for today. Play with both &lt;code&gt;lfarm&lt;/code&gt; and &lt;code&gt;cl-gearman&lt;/code&gt; to decide which one is better suited for your task.&lt;/p&gt;
</description>
            <pubDate>Wed, 10 Jun 2020 21:28:59 +0300</pubDate>
        </item>
        <item>
            <title>lfarm</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0094-lfarm.html</link>
            <description>&lt;p&gt;This library is similar to Python&apos;s multiprocessing which is also &lt;a href=&quot;https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.connection&quot;&gt;able to run processes on different hosts&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Use &lt;code&gt;lfarm&lt;/code&gt; when you need to run jobs on the cluster.&lt;/p&gt;
&lt;p&gt;The cool &lt;code&gt;lfarm&lt;/code&gt;&apos;s feature is the ability to run jobs on workers, running on different Common Lisp implementation.&lt;/p&gt;
&lt;p&gt;To demonstrate how it works, I started a LispWorks Personal edition on my laptop and SBCL with ClozureCL in the Docker containers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(ql:quickload :lfarm-server)

;; This how I started it on LispWorks
(lfarm-server:start-server &amp;quot;127.0.0.1&amp;quot; 10003)

;; inside the Docker:
(lfarm-server:start-server &amp;quot;0.0.0.0&amp;quot; 10000)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After that, I created a workers pool in my SBCL REPL and called &lt;code&gt;broadcast-task&lt;/code&gt; to run a function on every worker:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (setf lfarm:*kernel* (lfarm:make-kernel &amp;#039;((&amp;quot;127.0.0.1&amp;quot; 10001)
                                                     (&amp;quot;127.0.0.1&amp;quot; 10002)
                                                     (&amp;quot;127.0.0.1&amp;quot; 10003))))
#&amp;lt;LFARM-CLIENT.KERNEL:KERNEL :WORKER-COUNT 3 {1004E7C7C3}&amp;gt;

POFTHEDAY&amp;gt; (lfarm:broadcast-task
            (lambda ()
              (list :lisp (lisp-implementation-type)
                    :lisp-version (lisp-implementation-version)
                    :system (string-trim
                             (list #\Newline #\Space)
                             (with-output-to-string (s)
                               (uiop:run-program &amp;quot;uname -s -m -n&amp;quot;
                                                 :output s))))))
#((:LISP &amp;quot;LispWorks Personal Edition&amp;quot;
   :LISP-VERSION &amp;quot;7.1.2&amp;quot;
   :SYSTEM &amp;quot;Darwin lispbook x86_64&amp;quot;)
  (:LISP &amp;quot;SBCL&amp;quot;
   :LISP-VERSION &amp;quot;1.5.6&amp;quot;
   :SYSTEM &amp;quot;Linux 5d4cc1b96f7e x86_64&amp;quot;)
  (:LISP &amp;quot;Clozure Common Lisp&amp;quot;
   :LISP-VERSION &amp;quot;Version 1.11.5/v1.11.5  (LinuxX8664)&amp;quot;
   :SYSTEM &amp;quot;Linux d2c83144fce3 x86_64&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another great feature is API compatibility with &lt;code&gt;lparallel&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/06/0093-lparallel.html&quot;&gt;reviewed yesterday&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I took our yesterday code and modified it to be able to distinguish a machine processed a task:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lfarm:pmapcar
            (lambda (idx)
              (loop for iteration from 1 to 10
                    do (format t &amp;quot;~A task is processing ~A iteration~%&amp;quot;
                               idx iteration)
                       (sleep (random 1.0))
                    finally (return (format nil &amp;quot;~A result processed by ~A&amp;quot;
                                            idx
                                            (lisp-implementation-type)))))
              (alexandria:iota 10))
(&amp;quot;0 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;1 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;2 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;3 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;4 result processed by SBCL&amp;quot;
 &amp;quot;5 result processed by SBCL&amp;quot;
 &amp;quot;6 result processed by SBCL&amp;quot;
 &amp;quot;7 result processed by LispWorks Personal Edition&amp;quot;
 &amp;quot;8 result processed by LispWorks Personal Edition&amp;quot;
 &amp;quot;9 result processed by LispWorks Personal Edition&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The bad news is that &lt;code&gt;lfarm&lt;/code&gt; is not suite well to the cloud environment, where workers can disappear at any time and become available later.&lt;/p&gt;
&lt;p&gt;Some time ago, I tried to use &lt;code&gt;lfarm&lt;/code&gt; in Ultralisp, to run some jobs in separate containers, but found that &lt;code&gt;lfarm&lt;/code&gt; does not like when worker process disconnects.&lt;/p&gt;
&lt;p&gt;For example, if some of the workers aren&apos;t running, &lt;code&gt;make-kernel&lt;/code&gt; will hang forever. Or if some of the workers will go offline, then &lt;code&gt;broadcast-task&lt;/code&gt; also will hang.&lt;/p&gt;
&lt;p&gt;Tomorrow I&apos;ll tell you about another solution which helped me to solve this problem.&lt;/p&gt;
</description>
            <pubDate>Tue, 09 Jun 2020 21:06:00 +0300</pubDate>
        </item>
        <item>
            <title>lparallel</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0093-lparallel.html</link>
            <description>&lt;p&gt;Today I want to tell you about this great library which makes it very easy to speed up your program in an easy way.&lt;/p&gt;
&lt;p&gt;LParallel provides a convenient to use a thread pool. It allows you to run your code on multiple CPUs without bothering with threading et all.&lt;/p&gt;
&lt;p&gt;Here is a quick demo which allows us to run calculations in parallel by changing a call to &lt;code&gt;mapcar&lt;/code&gt; with a call to &lt;code&gt;lparallel:pmapcar&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; First we need to create a pool of 4 workers:
POFTHEDAY&amp;gt; (setf lparallel:*kernel*
                 (lparallel:make-kernel 4))
#&amp;lt;LPARALLEL.KERNEL:KERNEL
   :NAME &amp;quot;lparallel&amp;quot;
   :WORKER-COUNT 4
   :USE-CALLER NIL
   :ALIVE T
   :SPIN-COUNT 2000 {1002FB64D3}&amp;gt;

;; And here is the easiest way to use it:
POFTHEDAY&amp;gt; (lparallel:pmapcar
            (lambda (idx)
              (loop for iteration from 1 to 10
                    do (format t &amp;quot;~A task is processing ~A iteration~%&amp;quot;
                               idx iteration)
                       (sleep (random 1.0))
                    finally (return (format nil &amp;quot;~A worker result&amp;quot;
                                            idx))))
              (alexandria:iota 10))
0 task is processing 1 iteration
3 task is processing 1 iteration
0 task is processing 2 iteration
3 task is processing 2 iteration
3 task is processing 3 iteration
0 task is processing 3 iteration
...
7 task is processing 7 iteration
7 task is processing 8 iteration
7 task is processing 9 iteration
7 task is processing 10 iteration
(&amp;quot;0 worker result&amp;quot; &amp;quot;1 worker result&amp;quot; &amp;quot;2 worker result&amp;quot; &amp;quot;3 worker result&amp;quot;
 &amp;quot;4 worker result&amp;quot; &amp;quot;5 worker result&amp;quot; &amp;quot;6 worker result&amp;quot; &amp;quot;7 worker result&amp;quot;
 &amp;quot;8 worker result&amp;quot; &amp;quot;9 worker result&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A number of workers depend on the reason why do you want to parallelize execution. There are two possible situations:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;you have a CPU intensive tasks and want to use more power;&lt;/li&gt;&lt;li&gt;you have an IO-bound tasks and want to make more operations in   parallel.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;In the first case there is no sense to make more workers than a number of CPU&apos;s on your machine. In the second scenario, the number of workers can be higher.&lt;/p&gt;
&lt;p&gt;There is also a lower-level API for offloading work to workers through channels. In the next example, I pass a function to the pool and then receive the result:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *chan*
             (lparallel:make-channel))

POFTHEDAY&amp;gt; (lparallel:submit-task
            *chan*
            (lambda (param)
              (format t &amp;quot;Processing ~A~%&amp;quot; param)
              (sleep 3)
              (format t &amp;quot;Processing is done~%&amp;quot;)
              :result-of-processing)
            100500)
; No values
Processing 100500
Processing is done
POFTHEDAY&amp;gt; (lparallel:receive-result *chan*)
:RESULT-OF-PROCESSING&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LParallel has more great features like promises, futures and many ways to run jobs in parallel. It is one of the few Common Lisp projects that have excellent documentation. I recommend you to read it:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lparallel.org/&quot;&gt;https://lparallel.org/&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Mon, 08 Jun 2020 19:06:26 +0300</pubDate>
        </item>
        <item>
            <title>lime</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0092-lime.html</link>
            <description>&lt;p&gt;Lime is a standalone SWANK client. It can be used to programmatically connect to the SWANK server without Emacs.&lt;/p&gt;
&lt;p&gt;One useful thing, you might do is to make a command-line client to send a command to your server. One practical task is code hot-reload. Here is an &lt;a href=&quot;https://lispcookbook.github.io/cl-cookbook/web.html#hot-reload&quot;&gt;example&lt;/a&gt; of how to implement it using &lt;a href=&quot;http://quickdocs.org/swank-client/&quot;&gt;another SWANK client&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Example from Lime&apos;s sources shows how to create a REPL connected to the SWANK. However, this example creates a SWANK server in the same process. I think it will be more realistic to connect from one lisp to another.&lt;/p&gt;
&lt;p&gt;So, I modified example to make it connect to the localhost 20100, where we&apos;ll start a separate ClozureCL process with SWANK:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;Clozure Common Lisp Version 1.12 (v1.12) DarwinX8664

For more information about CCL, please see http://ccl.clozure.com.

CCL is free software.  It is distributed under the terms of the Apache
Licence, Version 2.0.
? (ql:quickload :swank)
To load &amp;quot;swank&amp;quot;:
  Load 1 ASDF system:
    swank
; Loading &amp;quot;swank&amp;quot;

? (swank:create-server :port 20100 :dont-close t :style :spawn)
;; Swank started at port: 20100.
20100&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we need a function which will make a connection and provide us with the remote REPL.&lt;/p&gt;
&lt;p&gt;I just removed the code which starts  SWANK in the same process and replaced &lt;code&gt;(uiop:hostname)&lt;/code&gt; with &quot;localhost&quot;, because &lt;code&gt;(uiop:hostname)&lt;/code&gt; didn&apos;t work for me:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun repl ()
             &amp;quot;Start the REPL.&amp;quot;
             (let ((conn (lime:make-connection &amp;quot;localhost&amp;quot;
                                               20100)))
               (lime:connect conn)

               (format t &amp;quot;Swank server running on ~A ~A~%&amp;quot;
                       (lime:connection-implementation-name conn)
                       (lime:connection-implementation-version conn))
               
               (loop
                 ;; Read all events
                 (sleep 0.05)
                 (let ((events (lime:pull-all-events conn)))
                   (loop for event in events do
                     (typecase event
                       (lime:write-string-event
                        (write-string (lime:event-string event)))
                       (lime:debugger-event
                        (write-string &amp;quot;Entered debugger!&amp;quot;))
                       (t
                        t))))
                 ;; Take input
                 (if (lime:connection-reader-waiting-p conn)
                     ;; Read a line to send as standard input
                     (progn
                       (format t &amp;quot;~%Read: &amp;quot;)
                       (let ((input (read-line)))
                         (lime:send-input conn input)))
                     ;; Read regular code
                     (progn
                       (format t &amp;quot;~A&amp;gt; &amp;quot; (lime:connection-package conn))
                       (let ((input (read)))
                         (lime:evaluate conn
                                        (with-standard-io-syntax
                                          (prin1-to-string input)))))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can connect to our ClozureCL process and have a fun!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; We are connecting from SBCL to CCL
POFTHEDAY&amp;gt; (lisp-implementation-type)
&amp;quot;SBCL&amp;quot;
POFTHEDAY&amp;gt; (lisp-implementation-version)
&amp;quot;2.0.2&amp;quot;

POFTHEDAY&amp;gt; (repl)
Swank server running on ccl Version 1.12 (v1.12) DarwinX8664

COMMON-LISP-USER&amp;gt; (lisp-implementation-type)
&amp;quot;Clozure Common Lisp&amp;quot;

COMMON-LISP-USER&amp;gt; (lisp-implementation-version)
&amp;quot;Version 1.12 (v1.12) DarwinX8664&amp;quot;

COMMON-LISP-USER&amp;gt; (+ 1 2)
3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you are going to try &lt;code&gt;Lime&lt;/code&gt; on CCL, use the patched &lt;code&gt;swank-protocol&lt;/code&gt; system with &lt;a href=&quot;https://github.com/eudoxia0/swank-protocol/pull/2&quot;&gt;this fix&lt;/a&gt;. Without the fix Lime will not work because of the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;&amp;lt;INFO&amp;gt; [23:48:47] swank-protocol swank-protocol.lisp (read-message) -
  Read message SWANK-PROTOCOL::RESULT: (:READER-ERROR
                                        &amp;quot;(:emacs-rex (swank-repl:listener-eval #A((7) common-lisp:base-char . \&amp;quot;(+ 1 2)\&amp;quot;)) \&amp;quot;COMMON-LISP-USER\&amp;quot; :repl-thread 5)
&amp;quot;
                                        &amp;quot;Reader error on #&amp;lt;STRING-INPUT-STREAM  :CLOSED #x30200139FB9D&amp;gt;:
reader macro #A used without a rank integer&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I experienced the same error with &lt;a href=&quot;https://github.com/cxxxr/lem&quot;&gt;Lem&lt;/a&gt; editor. And it was fixed with a &lt;a href=&quot;https://github.com/cxxxr/lem/pull/471/files&quot;&gt;similar patch&lt;/a&gt;.&lt;/p&gt;
</description>
            <pubDate>Mon, 08 Jun 2020 00:27:06 +0300</pubDate>
        </item>
        <item>
            <title>defclass-std</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0091-defclass-std.html</link>
            <description>&lt;p&gt;This library provides a shortcut macro to define &lt;code&gt;CLOS&lt;/code&gt; classes. Today I needed to define a class which will store stock candles data. It will keep data in the columns.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;defclass-std&lt;/code&gt; we can define such class like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass-std:defclass/std candles ()
             ((timestamps
               lows highs
               opens closes
               volumes)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will be expand into the &lt;code&gt;defclass&lt;/code&gt; full of accessors, init forms, etc:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass candles nil
  ((timestamps :accessor timestamps
               :initarg :timestamps
               :initform nil)
   (lows :accessor lows
         :initarg :lows
         :initform nil)
   (highs :accessor highs
          :initarg :highs
          :initform nil)
   (opens :accessor opens
          :initarg :opens
          :initform nil)
   (closes :accessor closes
           :initarg :closes
           :initform nil)
   (volumes :accessor volumes
            :initarg :volumes
            :initform nil)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what I really want is a class with custom initforms and readers, prefixed by class name.&lt;/p&gt;
&lt;p&gt;Here is the class definition I had before discovered the &lt;code&gt;defclass-std&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass candles ()
  ((timestamps :reader candles-timestamps
               :initform (make-time-vector)
               :initarg :timestamps)
   (lows :reader candles-lows
         :initform (make-price-vector)
         :initarg :lows)
   (highs :reader candles-highs
          :initform (make-price-vector)
          :initarg :highs)
   (opens :reader candles-opens
          :initform (make-price-vector)
          :initarg :opens)
   (closes :reader candles-closes
           :initform (make-price-vector)
           :initarg :closes)
   (volumes :reader candles-volumes
            :initform (make-volume-vector)
            :initarg :volumes))
  (:documentation
   &amp;quot;This is stock candles candles.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how &lt;code&gt;defclass-std&lt;/code&gt; can make this definition shorter and &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass-std:defclass/std candles ()
  ((timestamps
    :ri :with-prefix
    :std (make-time-vector))
   (volumes
    :ri :with-prefix
    :std (make-volume-vector))
   ;; Columns, having common options
   ;; can be grouped together!
   (lows highs opens closes
    :ri :with-prefix
    :std (make-price-vector)))
  (:documentation
   &amp;quot;This is stock candles storage.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will write &lt;code&gt;:initarg&lt;/code&gt; and &lt;code&gt;:reader&lt;/code&gt; for each slot. Also, slot&apos;s &lt;code&gt;:initform&lt;/code&gt; will have the value, provided after the &lt;code&gt;:std&lt;/code&gt; keyword.&lt;/p&gt;
&lt;p&gt;The syntax can be made even shorter, but such format is not supported yet:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass-std:defclass/std candles ()
  ((timestamps
    :std (make-time-vector))
   (volumes
    :std (make-volume-vector))
   (lows highs opens closes
    :std (make-price-vector)))
  (:default-slot-opts :ri :with-prefix)
  (:documentation
   &amp;quot;This is stock candles storage.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This can make class definitions as concise as defstruct.&lt;/p&gt;
</description>
            <pubDate>Sat, 06 Jun 2020 20:58:34 +0300</pubDate>
        </item>
        <item>
            <title>defmain</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0090-defmain.html</link>
            <description>&lt;p&gt;Today I want to tell about my own library for command-line arguments parsing. &lt;code&gt;Defmain&lt;/code&gt; provides a macro for defining the main function.&lt;/p&gt;
&lt;p&gt;All you need is to declare required and optional arguments like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defmain:defmain main
               ((debug &amp;quot;Show traceback instead of short message.&amp;quot;
                       :flag t)
                (log   &amp;quot;Filename to write log to.&amp;quot;)
                (token &amp;quot;GitHub personal access token.&amp;quot;
                       :env-var &amp;quot;TOKEN&amp;quot;)
                &amp;amp;rest repositories)
             &amp;quot;Utility to analyze github forks.&amp;quot;
             
             (format t
                     &amp;quot;Repositories: ~{~S~^, ~}~%~
                      Debug: ~S~%~
                      Log: ~S~%~
                      Token: ~S~%&amp;quot;
                     repositories
                     debug
                     log
                     token))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code expands to a lot of low-level code which uses &lt;a href=&quot;https://twitter.com/didierverna&quot;&gt;@didierverna&lt;/a&gt;&apos;s &lt;code&gt;net.didierverna.clon&lt;/code&gt; for actual arguments parsing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(progn
 (defun main (&amp;amp;rest defmain/defmain::argv)
   (declare (ignorable))
   (let ((defmain/defmain::synopsis
          (net.didierverna.clon:defsynopsis (:postfix &amp;quot;REPOSITORY...&amp;quot;
                                             :make-default nil)
            (defmain/defmain::text :contents &amp;quot;Utility to analyze github forks.&amp;quot;)
            (defmain/defmain::flag :long-name &amp;quot;help&amp;quot; :env-var nil :description
             &amp;quot;Show help on this program.&amp;quot; :short-name &amp;quot;h&amp;quot;)
            (defmain/defmain::flag :long-name &amp;quot;debug&amp;quot; :env-var nil :description
             &amp;quot;Show traceback instead of short message.&amp;quot; :short-name &amp;quot;d&amp;quot;)
            (defmain/defmain::stropt :long-name &amp;quot;log&amp;quot; :env-var nil :description
             &amp;quot;Filename to write log to.&amp;quot; :short-name &amp;quot;l&amp;quot;)
            (defmain/defmain::stropt :long-name &amp;quot;token&amp;quot; :env-var &amp;quot;TOKEN&amp;quot;
             :description &amp;quot;GitHub personal access token.&amp;quot; :short-name &amp;quot;t&amp;quot;)))
         (defmain/defmain::argv
          (or defmain/defmain::argv (uiop/image:command-line-arguments))))
     (change-class defmain/defmain::synopsis &amp;#039;defmain/defmain::cool-synopsis
                   :command &amp;#039;main)
     (net.didierverna.clon:make-context :cmdline
                                        (cons &amp;quot;main&amp;quot; defmain/defmain::argv)
                                        :synopsis defmain/defmain::synopsis))
   (let ((defmain/defmain::%rest-arguments (net.didierverna.clon:remainder)))
     (declare (ignorable defmain/defmain::%rest-arguments))
     (flet ((defmain/defmain::%pop-argument (defmain/defmain::name)
              &amp;quot;This local function is used to pop positional arguments from the command line.&amp;quot;
              (unless defmain/defmain::%rest-arguments
                (check-type defmain/defmain::name symbol)
                (error &amp;#039;defmain/defmain::argument-is-required-error :name
                       defmain/defmain::name))
              (pop defmain/defmain::%rest-arguments)))
       (let ((net.didierverna.clon:help
              (net.didierverna.clon:getopt :long-name &amp;quot;help&amp;quot;))
             (debug (net.didierverna.clon:getopt :long-name &amp;quot;debug&amp;quot;))
             (log (net.didierverna.clon:getopt :long-name &amp;quot;log&amp;quot;))
             (token (net.didierverna.clon:getopt :long-name &amp;quot;token&amp;quot;)))
         (when net.didierverna.clon:help
           (net.didierverna.clon:help)
           (uiop/image:quit 1))
         (handler-bind ((sb-sys:interactive-interrupt
                         (lambda (defmain/defmain::c)
                           (declare (ignorable defmain/defmain::c))
                           (uiop/image:quit 0)))
                        (defmain/defmain::argument-is-required-error
                         (lambda (defmain/defmain::c)
                           (format t &amp;quot;~A~%&amp;quot; defmain/defmain::c)
                           (uiop/image:quit 1)))
                        (error
                         (lambda (condition)
                           (uiop/image:print-condition-backtrace condition
                                                                 :stream
                                                                 *error-output*)
                           (uiop/image:quit 1))))
           (let ((repositories defmain/defmain::%rest-arguments))
             (flet ()
               (setf (logical-pathname-translations &amp;quot;TEMPORARY-FILES&amp;quot;)
                       `((&amp;quot;*.*.*&amp;quot;
                          ,(uiop/package:symbol-call :cl-fad
                                                     &amp;#039;defmain/defmain::get-default-temporary-directory))))
               (uiop/stream:setup-temporary-directory)
               (format t &amp;quot;Repositories: ~{~S~^, ~}~%~
                          Debug: ~S~%~
                          Log: ~S~%~
                          Token: ~S~%&amp;quot;
                       repositories debug log token)
               nil)))))))
 (setf (get &amp;#039;main :arguments) &amp;#039;(debug log token)
       (documentation &amp;#039;main &amp;#039;function) &amp;quot;Utility to analyze github forks.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&apos;s try to call our main function to check how  it processes command-line arguments.&lt;/p&gt;
&lt;p&gt;Defmain calls &lt;code&gt;uiop:quit&lt;/code&gt; at the end of the function on after the printing help message. To suppress this behaviour, I&apos;ll redefine this function to just print to the screen:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun uiop:quit (&amp;amp;optional (code 0))
             (format t &amp;quot;Quit was called with code=~A~%&amp;quot;
                     code))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can pass it different combinations of arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (main)
Repositories: 
Debug: NIL
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: NIL
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;--log&amp;quot; &amp;quot;app.log&amp;quot;&amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: &amp;quot;app.log&amp;quot;
Token: NIL

;; Now we&amp;#039;ll check how it will
;; process environment variable:
POFTHEDAY&amp;gt; (setf (uiop:getenv &amp;quot;TOKEN&amp;quot;)
                 &amp;quot;$ome $ecret 7oken&amp;quot;)

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;--log&amp;quot; &amp;quot;app.log&amp;quot;&amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: &amp;quot;app.log&amp;quot;
Token: &amp;quot;$ome $ecret 7oken&amp;quot;
NIL
POFTHEDAY&amp;gt; (main &amp;quot;--help&amp;quot;)
Usage: main main [-hd] [OPTIONS] REPOSITORY...

Utility to analyze github forks.
  -h, --help                  Show help on this program.
  -d, --debug                 Show traceback instead of short message.
  -l, --log=STR               Filename to write log to.
  -t, --token=STR             GitHub personal access token.
                              Environment: TOKEN
Quit was called with code=1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Defmain&lt;/code&gt; is not in Quicklisp distribution, but you can install it from &lt;a href=&quot;https://ultralisp.org/&quot;&gt;Ultralisp.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are looking to something simpler, you might take a look at &lt;code&gt;unix-opts&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/03/0006-unix-opts.html&quot;&gt;reviewed in the #0006 #poftheday&lt;/a&gt; post.&lt;/p&gt;
</description>
            <pubDate>Fri, 05 Jun 2020 22:24:53 +0300</pubDate>
        </item>
        <item>
            <title>lambda-fiddle</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0089-lambda-fiddle.html</link>
            <description>&lt;p&gt;This library serves a single purpose - to help macro writers to parse lambda lists. In this sense, it is similar to &lt;code&gt;parse-declarations&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0067-parse-declarations.html&quot;&gt;reviewed on 13 May&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The library has a number of functions to extract or remove exact parts of the lambda list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lambda-fiddle:remove-aux-part
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(FOO BAR &amp;amp;KEY BAZ)

POFTHEDAY&amp;gt; (lambda-fiddle:aux-lambda-vars
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(SOMETHING ALTOGETHER)

POFTHEDAY&amp;gt; (lambda-fiddle:extract-all-lambda-vars
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(FOO BAR BAZ SOMETHING ALTOGETHER)

POFTHEDAY&amp;gt; (lambda-fiddle:split-lambda-list
            &amp;#039;(&amp;amp;whole wide world &amp;amp;key roles))
((WORLD) WIDE NIL NIL NIL NIL (ROLES) NIL)

POFTHEDAY&amp;gt; (lambda-fiddle:with-destructured-lambda-list
               (:required req :optional opt)
               &amp;#039;(foo bar &amp;amp;optional baz)
             (list :required req
                   :optional opt))
(:REQUIRED (FOO BAR) :OPTIONAL (BAZ))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It also provides a higher-level macro to extract particular pieces all at once:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lambda-fiddle:with-destructured-lambda-list
               (:required req :optional opt)
               &amp;#039;(foo bar &amp;amp;optional baz)
             (list :required req
                   :optional opt))
(:REQUIRED (FOO BAR) :OPTIONAL (BAZ))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@Shinmera&lt;/a&gt;&apos;s &quot;legit&quot; contains &lt;a href=&quot;https://github.com/Shinmera/legit/blob/f822ac7aa8ed5aec7f2c63b146f790b0410f8502/toolkit.lisp#L31-L45&quot;&gt;a practical example&lt;/a&gt; of the &lt;code&gt;with-destructured-lambda-list&lt;/code&gt; usage.&lt;/p&gt;
&lt;p&gt;This code replaces optional arguments with keywords and adds optional predicates which can be used to check if a keyword argument was provided:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defmacro define-git-wrapper (name &amp;amp;rest argdefs)
  (lambda-fiddle:with-destructured-lambda-list (:required req :optional opt :key key) argdefs
    (let* ((purereq (purify-args req))
           (purekey (purify-args key))
           (pureopt (purify-args opt))
           (augkeys (mapcar (lambda (a)
                              `(,a NIL ,(p-symb a)))
                            (append pureopt purekey))))
      `(defun ,name (,@purereq &amp;amp;key ,@augkeys)
         (declare (ignorable ,@(mapcar #&amp;#039;third augkeys)))
         (run-git
          ,(subseq (string-downcase name) 4)
          ,@(loop for arg in req 
                  when (front-arg-p arg)
                    collect (parse-rargdef arg))
          ,@(loop for arg in opt
                  when (front-arg-p arg)
                    collect (parse-oargdef arg))
          ,@(mapcar #&amp;#039;parse-kargdef key)
          ,@(loop for arg in req
                  unless (front-arg-p arg)
                    collect (parse-rargdef arg))
          ,@(loop for arg in opt
                  unless (front-arg-p arg)
                    collect
                    (parse-oargdef arg)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. If you want to parse lambda lists, use this little helper instead of searching &amp;optional, &amp;rest, &amp;misc, etc by hand.&lt;/p&gt;
</description>
            <pubDate>Thu, 04 Jun 2020 23:51:31 +0300</pubDate>
        </item>
        <item>
            <title>group-by</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0088-group-by.html</link>
            <description>&lt;p&gt;This small utility library implements a really handy facility. It allows you to group items by one or many keys.&lt;/p&gt;
&lt;p&gt;Here is how it works. In the next example we&apos;ll group names by their first letter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (group-by:group-by
            &amp;#039;(&amp;quot;Alice&amp;quot;
              &amp;quot;Bob&amp;quot;
              &amp;quot;Ashley&amp;quot;
              &amp;quot;Katie&amp;quot;
              &amp;quot;Brittany&amp;quot;
              &amp;quot;Jessica&amp;quot;
              &amp;quot;Daniel&amp;quot;
              &amp;quot;Josh&amp;quot;)
            :key (lambda (name)
                   (elt name 0))
            :value #&amp;#039;identity)

((#\A &amp;quot;Alice&amp;quot;
      &amp;quot;Ashley&amp;quot;)
 (#\B &amp;quot;Bob&amp;quot;
      &amp;quot;Brittany&amp;quot;)
 (#\K &amp;quot;Katie&amp;quot;)
 (#\J &amp;quot;Jessica&amp;quot;
      &amp;quot;Josh&amp;quot;)
 (#\D &amp;quot;Daniel&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we are going to group by the first letter and next by the second, we need to use &lt;code&gt;group-by-repeated&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((first-letter (name)
                    (elt name 0))
                  (second-letter (name)
                    (elt name 1)))
             (group-by:group-by-repeated
              &amp;#039;(&amp;quot;Alice&amp;quot;
                &amp;quot;Bob&amp;quot;
                &amp;quot;Ashley&amp;quot;
                &amp;quot;Katie&amp;quot;
                &amp;quot;Brittany&amp;quot;
                &amp;quot;Jessica&amp;quot;
                &amp;quot;Daniel&amp;quot;
                &amp;quot;Josh&amp;quot;)
            :keys (list #&amp;#039;first-letter
                       #&amp;#039;second-letter)))

((#\D (#\a &amp;quot;Daniel&amp;quot;))
 (#\J (#\o &amp;quot;Josh&amp;quot;)
      (#\e &amp;quot;Jessica&amp;quot;))
 (#\K (#\a &amp;quot;Katie&amp;quot;))
 (#\B (#\r &amp;quot;Brittany&amp;quot;)
      (#\o &amp;quot;Bob&amp;quot;))
 (#\A (#\s &amp;quot;Ashley&amp;quot;)
      (#\l &amp;quot;Alice&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library also provides a way to accumulate grouped items into a special object. This could be useful when you don&apos;t have all items right away, but receiving them one by one from some source.&lt;/p&gt;
&lt;p&gt;Here is how it can be used in the simplest case. First, we&apos;ll request names from the user and will be collecting them into a special grouped list data structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((first-letter (name)
                    (elt name 0))
                  (second-letter (name)
                    (elt name 1))
                  (request-name ()
                    (format t &amp;quot;Enter a name: &amp;quot;)
                    (read)))
             (loop with accumulator = (group-by:make-grouped-list
                                       nil
                                       :keys (list #&amp;#039;first-letter
                                                   #&amp;#039;second-letter))
                   for name = (request-name)
                     then (request-name)
                   while name
                   do (group-by:add-item-to-grouping
                       name
                       accumulator)
                   finally (return accumulator)))
Enter a name: &amp;quot;Markus&amp;quot;
Enter a name: &amp;quot;Bob&amp;quot;
Enter a name: &amp;quot;Betty&amp;quot;
Enter a name: &amp;quot;Mery&amp;quot;
Enter a name: &amp;quot;Oleg&amp;quot;
Enter a name: &amp;quot;Marianna&amp;quot;
Enter a name: nil
#&amp;lt;GROUP-BY:GROUPED-LIST {1006D3EC43}&amp;gt;

POFTHEDAY&amp;gt; (defparameter *grouping* *)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At any time we can access the data structure to work with already collected items. Let&apos;s write a recursive function to see what we&apos;ve collected so far:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun print-tree (grouping &amp;amp;optional (depth 0))
             (let ((prefix (make-string depth :initial-element #\Space))
                   (key (group-by:key-value grouping))
                   (items (group-by:items-in-group grouping))
                   (subgroups (group-by:child-groupings grouping)))
               (when key
                 (format t &amp;quot;~A~A~&amp;amp;&amp;quot; prefix key)
                 (incf depth))

               (if subgroups
                   (loop for child in subgroups
                         do (print-tree child depth))
                   (loop for item in items
                         do (format t &amp;quot;~A - ~A~%&amp;quot;
                                    prefix
                                    item)))))

POFTHEDAY&amp;gt; (print-tree *grouping*)
O
 l
  - Oleg
B
 e
  - Betty
 o
  - Bob
M
 e
  - Mery
 a
  - Marianna
  - Markus&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library is powerful enough to have it in your toolbox. Go and group something now!&lt;/p&gt;
</description>
            <pubDate>Wed, 03 Jun 2020 20:44:42 +0300</pubDate>
        </item>
        <item>
            <title>cl-cron</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0087-cl-cron.html</link>
            <description>&lt;p&gt;This is a small system which allows you to organize a scheduled function execution in a Cron-like manner.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-cron:make-cron-job
            (lambda ()
              (format t &amp;quot;[~A] Cron works!~%&amp;quot;
                      (local-time:now))))
#:|cron743|

POFTHEDAY&amp;gt; (cl-cron:start-cron)
#&amp;lt;SB-THREAD:THREAD &amp;quot;Anonymous thread&amp;quot; RUNNING {1004D8CB93}&amp;gt;

[2020-06-02T22:29:00.328017+03:00] Cron works!
[2020-06-02T22:30:00.321083+03:00] Cron works!

POFTHEDAY&amp;gt; (cl-cron:stop-cron)
NIL

POFTHEDAY&amp;gt; (defun list-cron-jobs ()
             (loop for key being the hash-key
                     of cl-cron::*cron-jobs-hash*
                   collect key))

POFTHEDAY&amp;gt; (list-cron-jobs)
(#:|cron743|)

POFTHEDAY&amp;gt; (cl-cron:delete-cron-job (first *))
T

POFTHEDAY&amp;gt; (list-cron-jobs)
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Having unnamed cron jobs is not convenient because it is to remove them, you need to get its name using &lt;code&gt;list-cron-jobs&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;But you can provide a &lt;code&gt;hash-key&lt;/code&gt; argument to the &lt;code&gt;make-cron-job&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-cron:make-cron-job
            (lambda ()
              (format t &amp;quot;[~A] Cron works!~%&amp;quot;
                      (local-time:now)))
            :hash-key :print-every-minute)
:PRINT-EVERY-MINUTE

POFTHEDAY&amp;gt; (list-cron-jobs)
(:PRINT-EVERY-MINUTE)

POFTHEDAY&amp;gt; (cl-cron:delete-cron-job
            :print-every-minute)
T

POFTHEDAY&amp;gt; (list-cron-jobs)
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To make a task which runs not every minute but at the specified time, you can pass keyword arguments to the &lt;code&gt;make-cron-job&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, this will add a callback to run at 10:00 of every Sunday:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-cron:make-cron-job
            (lambda ()
              (format t &amp;quot;Wake Up!~%&amp;quot;))

            ;; Days of week are numbered from 0,
            ;; where 0 is Monday.
            ;; Run every Sunday:
            :day-of-week 6
            :hour 10
            :minute 0
            :hash-key :sunday-alarm)
:SUNDAY-ALARM&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I use &lt;code&gt;cl-cron&lt;/code&gt; in the Ultralisp.org, &lt;a href=&quot;https://github.com/ultralisp/ultralisp/blob/517738b087ca5a3eb14de728d855ca70739913c8/src/cron.lisp#L157-L184&quot;&gt;to schedule different tasks&lt;/a&gt;. And another useful trick I do is redefining &lt;code&gt;cl-cron:log-cron-message&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;By default it writes lines to the &lt;code&gt;./cron.log&lt;/code&gt;, but using this definition you can redirect all messages to the &lt;code&gt;log4cl&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; Here we are patching this function because
;; original tries to write into a file cl-cron.log
(defun cl-cron:log-cron-message (message &amp;amp;optional (type &amp;quot;error&amp;quot;))
  (if (string-equal type &amp;quot;error&amp;quot;)
      (log:error message)
      (log:info message)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Probably, I&apos;ll make a pull-request with these fixes soon. But seems the author of this library is not very active neither at BitBucket nor at the GitHub.&lt;/p&gt;
</description>
            <pubDate>Tue, 02 Jun 2020 23:04:49 +0300</pubDate>
        </item>
        <item>
            <title>pythonic-string-reader</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0086-pythonic-string-reader.html</link>
            <description>&lt;p&gt;This is a small package which adds a new syntax for writing multiline string as you do in Python.&lt;/p&gt;
&lt;p&gt;I already reviewed the &quot;heredoc&quot; library providing a similar functionality:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0055-cl-heredoc.html&quot;&gt;http://40ants.com/lisp-project-of-the-day/2020/05/0055-cl-heredoc.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here is how &lt;code&gt;pythonic-string-reader&lt;/code&gt; can be used:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; Enable the syntax:
POFTHEDAY&amp;gt; (named-readtables:in-readtable
            pythonic-string-reader:pythonic-string-syntax)

;; Using it from the REPL:
POFTHEDAY&amp;gt; &amp;quot;&amp;quot;&amp;quot;
Hello &amp;quot;Lisp World!&amp;quot;
&amp;quot;&amp;quot;&amp;quot;
&amp;quot;
Hello \&amp;quot;Lisp World!\&amp;quot;
&amp;quot;

;; Using it for function&amp;#039;s docstring:
POFTHEDAY&amp;gt; (defun foo (x)
             &amp;quot;&amp;quot;&amp;quot; This is a function
                 which multiplies &amp;quot;x&amp;quot;
                 to itself.
             &amp;quot;&amp;quot;&amp;quot;
             (* x x))
FOO
POFTHEDAY&amp;gt; (documentation &amp;#039;FOO
                          &amp;#039;function)
&amp;quot; This is a function
                 which multiplies \&amp;quot;x\&amp;quot;
                 to itself.
             &amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Whereas &lt;code&gt;cl-heredoc&lt;/code&gt; package allowed you to choose a string which will denote the end of the string literal, &lt;code&gt;pythonic-string-reader&lt;/code&gt; supports only 3 or 4 double-quotes.&lt;/p&gt;
&lt;p&gt;4 double-quotes might be useful if you want to use 3 double quotes in the text:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun foo ()
             &amp;quot;&amp;quot;&amp;quot;&amp;quot;
             You also might enter text with 3 double quotes:

             &amp;quot;&amp;quot;&amp;quot;
             Just use 4 double quotes when starting such string
             literal.
             &amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;)

POFTHEDAY&amp;gt; (foo)
&amp;quot;
             You also might enter text with 3 double quotes:

             \&amp;quot;\&amp;quot;\&amp;quot;
             Just use 4 double quotes when starting such string
             literal.
             \&amp;quot;\&amp;quot;\&amp;quot;
&amp;quot;&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Mon, 01 Jun 2020 21:10:55 +0300</pubDate>
        </item>
        <item>
            <title>simplified-types</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0085-simplified-types.html</link>
            <description>&lt;p&gt;Yesterday I wrote a simple implementation of dataframe. A dataframe stores data columns as simple vectors of some type.&lt;/p&gt;
&lt;p&gt;For this implementation, I needed a type inference to set vector&apos;s type for each column. An inferred type should be generic enough to work for all items in the column.&lt;/p&gt;
&lt;p&gt;But what if we have positive and negative integers in our data? What type will return the standard &lt;code&gt;type-of&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Here is the answer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (type-of 21)
(INTEGER 0 4611686018427387903)

POFTHEDAY&amp;gt; (type-of -21)
FIXNUM&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, if I&apos;ll make my vector&apos;s type &lt;code&gt;(INTEGER 0 4611686018427387903)&lt;/code&gt; it will raise an error on the second element:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (make-array
            2
            :element-type &amp;#039;(INTEGER
                            0
                            4611686018427387903)
            :initial-contents &amp;#039;(21 -21))
; Debugger entered on
; #&amp;lt;TYPE-ERROR expected-type:
; (UNSIGNED-BYTE 62) datum: -21&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That&apos;s why I started to search the way to make inferred type more generic and found &lt;code&gt;simplified-types&lt;/code&gt; library.&lt;/p&gt;
&lt;p&gt;Here is how it works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (mapcar #&amp;#039;type-of
             &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;))

((INTEGER 0 4611686018427387903)
  FIXNUM
  SINGLE-FLOAT
  DOUBLE-FLOAT
  (SIMPLE-ARRAY CHARACTER (6)))
    
POFTHEDAY&amp;gt; (mapcar #&amp;#039;simplified-types:simplified-type-of
             &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;))

((INTEGER 21 21)
 (INTEGER -23 -23)
  SINGLE-FLOAT
  DOUBLE-FLOAT
  T)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, &lt;code&gt;INTEGER&lt;/code&gt; with bounds still is not what I need for my application. Happily, &lt;a href=&quot;https://github.com/marcoheisig&quot;&gt;Marco Heisig&lt;/a&gt; foresee this need and added a switcher which makes integer types more generic.&lt;/p&gt;
&lt;p&gt;With this option, the library produces exactly what I need:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((simplified-types::*precise-integer-types* nil))
             (mapcar #&amp;#039;simplified-types:simplified-type-of
               &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;)))

((INTEGER * *)
 (INTEGER * *)
  SINGLE-FLOAT
  DOUBLE-FLOAT
  T)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you&apos;d like to work with types in Common Lisp, then you probably might be interested in the library I&apos;ve reviewed recently - &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/04/0033-trivialib.type-unify.html&quot;&gt;trivialib.type-unify&lt;/a&gt;. It allows us to do pattern-matching on type specifiers.&lt;/p&gt;
</description>
            <pubDate>Sun, 31 May 2020 21:45:22 +0300</pubDate>
        </item>
        <item>
            <title>cl-ascii-table</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0084-cl-ascii-table.html</link>
            <description>&lt;p&gt;Today I want to cheat and to review a library you&apos;ve already seen in action in the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0082-data-table.html&quot;&gt;data-table&apos;s review&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Recently I encounter a task where I needed to print tabulated data. In Python there is really cool library &lt;a href=&quot;https://pypi.org/project/tabulate/&quot;&gt;tabulate&lt;/a&gt; and first thing I did - created &lt;a href=&quot;https://www.reddit.com/r/Common_Lisp/comments/gs115z/looking_for_a_library_to_show_data_frames_and/&quot;&gt;the post on Reddit&lt;/a&gt; asking if there is something similar for Common Lisp exists.&lt;/p&gt;
&lt;p&gt;Comments didn&apos;t give a  variety of choices, but I found a &lt;code&gt;cl-ascii-table&lt;/code&gt; &lt;a href=&quot;http://quickdocs.org/cl-ascii-table/&quot;&gt;on Quickdocs&lt;/a&gt;. Remember, if you need to solve some problem - search o Quickdocs first! ;-)&lt;/p&gt;
&lt;p&gt;So, &lt;code&gt;cl-ascii-table&lt;/code&gt; is a little helper to draw nice ASCII tables. It is very easy to use. Just create a table, then add rows, and command it to render the table:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (loop with rows = &amp;#039;((&amp;quot;Bob&amp;quot; 31 &amp;quot;bob@gmail.com&amp;quot; 89.4)
                               (&amp;quot;Alice&amp;quot; 28 &amp;quot;alice@hot.com&amp;quot; 65.1)
                               (&amp;quot;Garry&amp;quot; 25 &amp;quot;garry@zoumz.in&amp;quot; 76.3))
                 with table = (ascii-table:make-table
                               &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Age&amp;quot; &amp;quot;Email&amp;quot; &amp;quot;Weight&amp;quot;)
                               ;; this is optional
                               :header &amp;quot;Sport Group&amp;quot;)
                 for row in  rows
                 do (ascii-table:add-row table row)
                 finally (ascii-table:display table))
.---------------------------------------.
|              Sport Group              |
+-------+-----+----------------+--------+
| Name  | Age | Email          | Weight |
+-------+-----+----------------+--------+
| Bob   |  31 | bob@gmail.com  |   89.4 |
| Alice |  28 | alice@hot.com  |   65.1 |
| Garry |  25 | garry@zoumz.in |   76.3 |
+-------+-----+----------------+--------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is not so featureful as Python&apos;s tabulate, but does it job.&lt;/p&gt;
&lt;p&gt;By the way, pay attention on the difference between system name and package name. It might be important if you use &lt;a href=&quot;https://common-lisp.net/project/asdf/asdf/The-package_002dinferred_002dsystem-extension.html&quot;&gt;package-inferred-system&lt;/a&gt; ASDF extension for your own system.&lt;/p&gt;
&lt;p&gt;In this case, you can put this line into your ASD file. This will let ASDF to know which system should be loaded when you are importing symbols from &lt;code&gt;ascii-table&lt;/code&gt; package:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(register-system-packages &amp;quot;cl-ascii-table&amp;quot; &amp;#039;(#:ascii-table))&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Sat, 30 May 2020 22:00:38 +0300</pubDate>
        </item>
        <item>
            <title>assoc-utils</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0083-assoc-utils.html</link>
            <description>&lt;p&gt;This is a small utility library by &lt;a href=&quot;https://twitter.com/nitro_idiot&quot;&gt;Eitaro Fukamachi&lt;/a&gt;. It serves a single purpose - make working with alists more convenient.&lt;/p&gt;
&lt;p&gt;The library has good documentation with lots of examples. Here is the excerpt from it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *person*
             &amp;#039;((&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;)
               (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;)))

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;name&amp;quot;)
&amp;quot;Eitaro&amp;quot;

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;address&amp;quot;)
NIL

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;address&amp;quot;
                             ;; This is default
                             &amp;quot;Tokyo, Japan&amp;quot;)
&amp;quot;Tokyo, Japan&amp;quot;

;; The alist remains the same
POFTHEDAY&amp;gt; *person*
((&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;) (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;))

;; But aget is setf-able:
POFTHEDAY&amp;gt; (setf (assoc-utils:aget *person* &amp;quot;address&amp;quot;)
                 &amp;quot;Tokyo, Japan&amp;quot;)

POFTHEDAY&amp;gt; *person*
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;)
 (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;))

POFTHEDAY&amp;gt; (assoc-utils:delete-from-alistf *person*
                                           &amp;quot;email&amp;quot;)
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also conversion functions which automatically converts keys from strings to keywords and vice versa:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; *person*
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;) 
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))

POFTHEDAY&amp;gt; (assoc-utils:alist-plist *person*)
(:ADDRESS &amp;quot;Tokyo, Japan&amp;quot;
 :NAME &amp;quot;Eitaro&amp;quot;)

POFTHEDAY&amp;gt; (assoc-utils:plist-alist *)
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Read &lt;a href=&quot;http://quickdocs.org/assoc-utils/&quot;&gt;the documentation&lt;/a&gt; to learn more about other functions which allow to compare alists, check their type and to get keys and values.&lt;/p&gt;
</description>
            <pubDate>Fri, 29 May 2020 21:06:49 +0300</pubDate>
        </item>
        <item>
            <title>data-table</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0082-data-table.html</link>
            <description>&lt;p&gt;This library provides a few methods to work with data tables. Think about it as a limited version of &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html&quot;&gt;Pandas Dataframe&lt;/a&gt; for Common Lisp.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Data-table&lt;/code&gt; abilities are really modest. For example, it does not provide methods to investigate data in the table.&lt;/p&gt;
&lt;p&gt;To overcome this limitation, we&apos;ll use another library - &lt;code&gt;cl-ascii-table&lt;/code&gt; and define a &lt;code&gt;describe-object&lt;/code&gt; method for data tables:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (make-instance &amp;#039;data-table:data-table
                            :column-names &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Birthday&amp;quot; &amp;quot;Age&amp;quot;)
                            :rows &amp;#039;((&amp;quot;Bob&amp;quot; &amp;quot;1985-05-17&amp;quot; 35)
                                    (&amp;quot;Alice&amp;quot; &amp;quot;1989-02-23&amp;quot; 31)
                                    (&amp;quot;John&amp;quot; &amp;quot;2000-01-03&amp;quot; 20))))

;; This is what we&amp;#039;ll wee by default:
POFTHEDAY&amp;gt; (describe *dt*)
#&amp;lt;DATA-TABLE:DATA-TABLE {1003D50293}&amp;gt;
  [standard-object]

Slots with :INSTANCE allocation:
  COLUMN-NAMES                   = (&amp;quot;Name&amp;quot; &amp;quot;Birthday&amp;quot; &amp;quot;Age&amp;quot;)
  COLUMN-TYPES                   = (STRING STRING (INTEGER 0 4611686018427387903))
  ROWS                           = ((&amp;quot;Bob&amp;quot; &amp;quot;1985-05-17&amp;quot; 35) (&amp;quot;Alice&amp;quot; &amp;quot;1989-02-23&amp;quot; 31))

;; But with custom method we might make it more
;; more convenient:
POFTHEDAY&amp;gt; (defmethod describe-object ((obj data-table:data-table) stream)
             (loop with table = (ascii-table:make-table
                                 (data-table:column-names obj))
                   for row in (data-table:rows obj)
                   do (ascii-table:add-row table row)
                   finally (ascii-table:display table)))

POFTHEDAY&amp;gt; (describe *dt*)
+-------+------------+-----+
| Name  | Birthday   | Age |
+-------+------------+-----+
| Bob   | 1985-05-17 |  35 |
| Alice | 1989-02-23 |  31 |
| John  | 2000-01-03 |  20 |
+-------+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s see what capabilities for data slicing does it have.&lt;/p&gt;
&lt;p&gt;Here is how we can retrieve columns. Pay attention, column names are case insensitive. But if case mismatch, column names of the resulting table will be different. Maybe this is a bug:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (describe
            (data-table:select-columns *dt*
                                       &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Age&amp;quot;)))
+-------+-----+
| Name  | Age |
+-------+-----+
| Bob   |  35 |
| Alice |  31 |
| John  |  20 |
+-------+-----+
; No values
POFTHEDAY&amp;gt; (describe
            (data-table:select-columns *dt*
                                       &amp;#039;(&amp;quot;name&amp;quot; &amp;quot;age&amp;quot;)))
+-------+-----+
| name  | age |
+-------+-----+
| Bob   |  35 |
| Alice |  31 |
| John  |  20 |
+-------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a way to select a subtable using indices.&lt;/p&gt;
&lt;p&gt;This is how we can select contiguous columns with &quot;Name&quot; and &quot;Age&quot; labels:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; We have to do call this method first.
;; It will fill a list of datatypes.
;; Without filled list of datatypes, make-sub-table will fail :(

POFTHEDAY&amp;gt; (data-table:coerce-data-table-of-strings-to-types *dt*)

POFTHEDAY&amp;gt; (describe
            (data-table:make-sub-table *dt*
                                       :lci 1 :uci 3))
+------------+-----+
| Birthday   | Age |
+------------+-----+
| 1985-05-17 |  35 |
| 1989-02-23 |  31 |
| 2000-01-03 |  20 |
+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we want to select only the last two rows, then we have to do some math:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; In pandas.DataFrame this will be just: dt.tail(2)
;;
POFTHEDAY&amp;gt; (let ((rows-count (data-table:number-of-rows *dt*)))
             (describe
              (data-table:make-sub-table *dt*
                                         :lri (- rows-count 2)
                                         :uri rows-count)))
+-------+------------+-----+
| Name  | Birthday   | Age |
+-------+------------+-----+
| Alice | 1989-02-23 |  31 |
| John  | 2000-01-03 |  20 |
+-------+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, we can combine column selection by name with make-sub-table. But this will create an intermediate table.&lt;/p&gt;
&lt;p&gt;There is also a method &lt;code&gt;overlay-region&lt;/code&gt; to combine two tables. Let&apos;s use it to add email for Genry and Mary:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (data-table:plists-to-data-table
              &amp;#039;((:id 1 :name &amp;quot;Bob&amp;quot;)
                (:id 2 :name &amp;quot;Genry&amp;quot;)
                (:id 3 :name &amp;quot;Mary&amp;quot;))))

POFTHEDAY&amp;gt; (describe *dt*)
+----+-------+
| ID | NAME  |
+----+-------+
|  1 | Bob   |
|  2 | Genry |
|  3 | Mary  |
+----+-------+

POFTHEDAY&amp;gt; (data-table:overlay-region
            (data-table:plists-to-data-table
             &amp;#039;((:email &amp;quot;genry@gmail.com&amp;quot;)
               (:email &amp;quot;mary@hormail.com&amp;quot;)))
            *dt*)
NIL

POFTHEDAY&amp;gt; (describe *dt*)
+------------------+-------+
| ID               | NAME  |
+------------------+-------+
| genry@gmail.com  | Bob   |
| mary@hormail.com | Genry |
|                3 | Mary  |
+------------------+-------+

POFTHEDAY&amp;gt; ;; Oh, this method modified the original table :(((&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To fix the issue, we need to recreate an original table and to specify indexes for applied overlay:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (data-table:plists-to-data-table
              &amp;#039;((:id 1 :name &amp;quot;Bob&amp;quot;)
                (:id 2 :name &amp;quot;Genry&amp;quot;)
                (:id 3 :name &amp;quot;Mary&amp;quot;))))

POFTHEDAY&amp;gt; (data-table:overlay-region
            (data-table:plists-to-data-table
             &amp;#039;((:email &amp;quot;genry@gmail.com&amp;quot;)
               (:email &amp;quot;mary@hormail.com&amp;quot;)))
            *dt*
            :col-idx 2
            :row-idx 1)

;; But new column has no name now :(
POFTHEDAY&amp;gt; (describe *dt*)
+----+-------+------------------+
| ID | NAME  | NIL              |
+----+-------+------------------+
|  1 | Bob   | NIL              |
|  2 | Genry | genry@gmail.com  |
|  3 | Mary  | mary@hormail.com |
+----+-------+------------------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It would be nice to have support for indices and joins &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html#join&quot;&gt;like in Pandas&lt;/a&gt;. That is what I expect from the data manipulation library.&lt;/p&gt;
&lt;p&gt;We&apos;ve viewed almost all core functions of the &lt;code&gt;data-table&lt;/code&gt; library. There are also data coercion and comparison functions. But I think this library has lots of room for improvement.&lt;/p&gt;
&lt;p&gt;Maybe &lt;a href=&quot;https://twitter.com/guicho271828&quot;&gt;@guicho271828&lt;/a&gt; has plans to build a dataframe library as supplementary to his &lt;a href=&quot;https://github.com/numcl/numcl&quot;&gt;NumCL&lt;/a&gt;?&lt;/p&gt;
</description>
            <pubDate>Fri, 29 May 2020 00:31:49 +0300</pubDate>
        </item>
        <item>
            <title>cl-ppcre-unicode</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0081-cl-ppcre-unicode.html</link>
            <description>&lt;p&gt;This system adds Unicode support to the &lt;code&gt;cl-ppcre&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What does it mean? It means that after loading &lt;code&gt;cl-ppcre-unicode&lt;/code&gt; you&apos;ll be able to match against Unicode symbol properties.&lt;/p&gt;
&lt;p&gt;A property matcher has a special syntax in cl-ppcre&apos;s regexps: &lt;code&gt;\p{PropertyName}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; This is how we can find out a position
;; of the first Cyrillic letter:

POFTHEDAY&amp;gt; (ppcre:scan &amp;quot;\\p{Cyrillic}&amp;quot;
                       &amp;quot;123&amp;#x42E;56&amp;quot;)
3

;; Here we are extracting a
;; sequence of Emoji from the text:
POFTHEDAY&amp;gt; (ppcre:regex-replace
            &amp;quot;.*?([\\p{Emoticons}|\\p{Supplemental Symbols and Pictographs}]+).*&amp;quot;
            &amp;quot;Hello, Lisper! &amp;#x1F917;&amp;#x1F603; How are you?&amp;quot;
            &amp;quot;\\1&amp;quot;)
&amp;quot;&amp;#x1F917;&amp;#x1F603;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We are using two different Unicode classes as properties because these two characters belong to different classes.&lt;/p&gt;
&lt;p&gt;You can use &lt;code&gt;cl-unicode&lt;/code&gt; to discover the character&apos;s unicode class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-unicode:code-block #\&amp;#x1F603;)
&amp;quot;Emoticons&amp;quot;

POFTHEDAY&amp;gt; (cl-unicode:code-block #\&amp;#x1F917;)
&amp;quot;Supplemental Symbols and Pictographs&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The way, how &lt;code&gt;cl-ppcre-unicode&lt;/code&gt; works is very interesting. It turns out that &lt;code&gt;cl-ppcre&lt;/code&gt; has a special hook which allows you to define a property resolver.&lt;/p&gt;
&lt;p&gt;For example, if you want to have a special property for vowels, you might do something like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun my-property-resolver (property-name)
             (if (string-equal property-name
                               &amp;quot;vowel&amp;quot;)
                 (rutils:fn vovel-p (character)
                   (member character &amp;#039;(#\A #\E #\I #\O #\U)
                           :test #&amp;#039;char-equal))
                 (cl-ppcre-unicode:unicode-property-resolver
                  property-name)))

POFTHEDAY&amp;gt; (setf cl-ppcre:*property-resolver*
                 #&amp;#039;my-property-resolver)

;; And now we can use the &amp;quot;Vowel&amp;quot; property in any
;; regular expressions!
POFTHEDAY&amp;gt; (ppcre:regex-replace-all
            &amp;quot;\\p{Vowel}&amp;quot;
            &amp;quot;Hello, Lisper! How are you?&amp;quot;
            &amp;quot;&amp;quot;)
&amp;quot;Hll, Lspr! Hw r y?&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Isn&apos;t this cool!? 🤪&lt;/p&gt;
</description>
            <pubDate>Wed, 27 May 2020 20:38:40 +0300</pubDate>
        </item>
        <item>
            <title>jose</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0080-jose.html</link>
            <description>&lt;p&gt;JOSE is an implementation of &lt;a href=&quot;https://datatracker.ietf.org/wg/jose/documents/&quot;&gt;Javascript Object Signing and Encryption&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This &lt;a href=&quot;https://twitter.com/nitro_idiot&quot;&gt;@nitro_idiot&apos;s&lt;/a&gt; library implements a &lt;a href=&quot;https://tools.ietf.org/html/rfc7515&quot;&gt;JSON Web Signature&lt;/a&gt; and allows to encode, decode and inspect JWT tokens.&lt;/p&gt;
&lt;p&gt;JOSE can be useful to implement signed token exchange between microservices.&lt;/p&gt;
&lt;p&gt;I found a &lt;a href=&quot;https://medium.facilelogin.com/jwt-jws-and-jwe-for-not-so-dummies-b63310d201a3&quot;&gt;great article on what JWT, JWS and JWE are&lt;/a&gt;. Read it you want more about them. To demonstrate, how does token inspection work, I took a JWT token from the article and parsed it with Common Lisp JOSE:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (jose/jwt:inspect-token
            &amp;quot;eyJhbGciOiJSUzI1NiIsImtpZCI6Ijc4YjRjZjIzNjU2ZGMzOTUzNjRmMWI2YzAyOTA3NjkxZjJjZGZmZTEifQ.eyJpc3MiOiJhY2NvdW50cy5nb29nbGUuY29tIiwic3ViIjoiMTEwNTAyMjUxMTU4OTIwMTQ3NzMyIiwiYXpwIjoiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiZW1haWwiOiJwcmFiYXRoQHdzbzIuY29tIiwiYXRfaGFzaCI6InpmODZ2TnVsc0xCOGdGYXFSd2R6WWciLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXVkIjoiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiaGQiOiJ3c28yLmNvbSIsImlhdCI6MTQwMTkwODI3MSwiZXhwIjoxNDAxOTEyMTcxfQ.TVKv-pdyvk2gW8sGsCbsnkqsrS0T-H00xnY6ETkIfgIxfotvFn5IwKm3xyBMpy0FFe0Rb5Ht8AEJV6PdWyxz8rMgX2HROWqSo_RfEfUpBb4iOsq4W28KftW5H0IA44VmNZ6zU4YTqPSt4TPhyFC9fP2D_Hg7JQozpQRUfbWTJI&amp;quot;)

((&amp;quot;exp&amp;quot; . 1401912171) (&amp;quot;iat&amp;quot; . 1401908271) (&amp;quot;hd&amp;quot; . &amp;quot;wso2.com&amp;quot;)
 (&amp;quot;aud&amp;quot;
  . &amp;quot;825249835659-te8qgl701kgonnomnp4sqv7erhu1211s.apps.googleusercontent.com&amp;quot;)
 (&amp;quot;email_verified&amp;quot; . T) (&amp;quot;at_hash&amp;quot; . &amp;quot;zf86vNulsLB8gFaqRwdzYg&amp;quot;)
 (&amp;quot;email&amp;quot; . &amp;quot;prabath@wso2.com&amp;quot;)
 (&amp;quot;azp&amp;quot;
  . &amp;quot;825249835659-te8qgl701kgonnomnp4sqv7erhu1211s.apps.googleusercontent.com&amp;quot;)
 (&amp;quot;sub&amp;quot; . &amp;quot;110502251158920147732&amp;quot;) (&amp;quot;iss&amp;quot; . &amp;quot;accounts.google.com&amp;quot;))

((&amp;quot;alg&amp;quot; . &amp;quot;RS256&amp;quot;) (&amp;quot;kid&amp;quot; . &amp;quot;78b4cf23656dc395364f1b6c02907691f2cdffe1&amp;quot;))

#(77 82 175 250 151 114 190 77 160 91 203 6 176 38 236 158 74 172 173 45 19 248
  125 52 198 118 58 17 57 8 126 2 49 126 139 111 22 126 72 192 169 183 199 32
  76 167 45 5 21 237 17 111 145 237 240 1 9 87 163 221 91 44 115 242 179 32 95
  97 209 57 106 146 163 244 95 17 245 41 5 190 34 58 202 184 91 111 10 126 213
  185 31 66 0 227 133 102 53 158 179 83 134 19 168 244 173 225 51 225 200 80
  189 124 253 131 252 120 59 37 10 51 165 4 84 125 181 147 36)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Inspect returns payload, headers and the signature.&lt;/p&gt;
&lt;p&gt;There are also two methods &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt;. Here is how we can use them to issue and verify JWT token:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter
               *secret* (ironclad:ascii-string-to-byte-array
                         &amp;quot;I Love Common Lisp!&amp;quot;))

POFTHEDAY&amp;gt; (defparameter
               *token*
             (jose:encode :hs256 *secret*
                          &amp;#039;((&amp;quot;user&amp;quot;  . &amp;quot;Bob&amp;quot;)
                            (&amp;quot;email&amp;quot; . &amp;quot;bob@gmail.com&amp;quot;))))

;; Now this token can be sent to the authenticated
;; user so that user can pass it back during API calls:
POFTHEDAY&amp;gt; *token*
&amp;quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiQm9iIiwiZW1haWwiOiJib2JAZ21haWwuY29tIn0.NLgg5RxlKDNqw1cqFU0_HysIu-zO7JBYUQN2IZF6c6w&amp;quot;

;; And when we&amp;#039;ll receive such API call,
;; we can know who this user is.
POFTHEDAY&amp;gt; (jose:decode :hs256 *secret*
                        *token*)
((&amp;quot;user&amp;quot; . &amp;quot;Bob&amp;quot;) (&amp;quot;email&amp;quot; . &amp;quot;bob@gmail.com&amp;quot;))
((&amp;quot;alg&amp;quot; . &amp;quot;HS256&amp;quot;) (&amp;quot;typ&amp;quot; . &amp;quot;JWT&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A cool feature of JWT token is that it is signed and you can trust the payload&apos;s content. Let&apos;s pretend, that Bob is the &quot;evil hacker&quot; who wants to get access to another account.&lt;/p&gt;
&lt;p&gt;To do this, Bob will modify payload and use header and sign from the original token:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun replace-payload (token new-payload)
             (rutils:with (((original-header rutils:_ original-sign)
                            (str:split &amp;quot;.&amp;quot; token))
                           (json-payload
                            (jonathan:to-json new-payload :from :alist))
                           (new-encoded-payload
                            (jose/base64:base64url-encode json-payload)))
               (str:join &amp;quot;.&amp;quot;
                         (list original-header
                               new-encoded-payload
                               original-sign))))

POFTHEDAY&amp;gt; (defparameter *new-token*
             (replace-payload *token*
                              &amp;#039;((&amp;quot;user&amp;quot;  . &amp;quot;Alice&amp;quot;)
                                (&amp;quot;email&amp;quot; . &amp;quot;alice@wonderland.in&amp;quot;))))

;; Now we&amp;#039;ll try to decode token on the server-side
;; and receive error from JOSE:
POFTHEDAY&amp;gt; (jose:decode :hs256 *secret*
                        *new-token*)
; Debugger entered on #&amp;lt;JOSE/ERRORS:JWS-VERIFICATION-ERROR {1005C37033}&amp;gt;
[1] POFTHEDAY&amp;gt; 
; Evaluation aborted on #&amp;lt;JOSE/ERRORS:JWS-VERIFICATION-ERROR {1005C37033}&amp;gt;

;; But we still can inspect bad token because
;; it&amp;#039;s content is not encrypted:
POFTHEDAY&amp;gt; (jose:inspect-token *new-token*)

((&amp;quot;email&amp;quot; . &amp;quot;alice@wonderland.in&amp;quot;) (&amp;quot;user&amp;quot; . &amp;quot;Alice&amp;quot;))

((&amp;quot;alg&amp;quot; . &amp;quot;HS256&amp;quot;) (&amp;quot;typ&amp;quot; . &amp;quot;JWT&amp;quot;))

#(52 184 32 229 28 101 40 51 106 195 87 42 21 77 63 31 43 8 187 236 206 236 144
  88 81 3 118 33 145 122 115 172)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BTW, as you can see, tokens are not encoded, they are signed. Because of that, you should pass them only over encrypted channels.&lt;/p&gt;
</description>
            <pubDate>Tue, 26 May 2020 19:53:38 +0300</pubDate>
        </item>
        <item>
            <title>cl-collider</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0079-cl-collider.html</link>
            <description>&lt;p&gt;This library is an interface to a very interesting algorithmic audio synthesizer - &lt;a href=&quot;https://supercollider.github.io/&quot;&gt;SuperCollider&lt;/a&gt;. SuperCollider itself has a builtin programming language, but &lt;code&gt;cl-collider&lt;/code&gt; makes it possible to write music in lisp interactively.&lt;/p&gt;
&lt;p&gt;Here is how a simple program in sclang looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; C&apos;&gt;// 60Hz Gabber Rave 1995
Server.default.boot;

(
SynthDef(\gabberkick, {
    var snd, freq, high, lfo;
    freq = \freq.kr(440) * (Env.perc(0.001, 0.08, curve: -1).ar * 48 * \bend.kr(1)).midiratio;
    snd = Saw.ar(freq);
    snd = (snd * 100).tanh + ((snd.sign - snd) * -8.dbamp);
    high = HPF.ar(snd, 300);
    lfo = SinOsc.ar(8, [0, 0.5pi]).range(0, 0.01);
    high = high.dup(2) + (DelayC.ar(high, 0.01, lfo) * -2.dbamp);
    snd = LPF.ar(snd, 100).dup(2) + high;
    snd = RLPF.ar(snd, 7000, 2);
    snd = BPeakEQ.ar(snd, \ffreq.kr(3000) * XLine.kr(1, 0.8, 0.3), 0.5, 15);
    snd = snd * Env.asr(0.001, 1, 0.05).ar(2, \gate.kr(1));
    Out.ar(\out.kr(0), snd * \amp.kr(0.1));
}).add;

SynthDef(\hoover, {
    var snd, freq, bw, delay, decay;
    freq = \freq.kr(440);
    freq = freq * Env([-5, 6, 0], [0.1, 1.7], [\lin, -4]).kr.midiratio;
    bw = 1.035;
    snd = { DelayN.ar(Saw.ar(freq * ExpRand(bw, 1 / bw)) + Saw.ar(freq * 0.5 * ExpRand(bw, 1 / bw)), 0.01, Rand(0, 0.01)) }.dup(20);
    snd = (Splay.ar(snd) * 3).atan;
    snd = snd * Env.asr(0.01, 1.0, 1.0).kr(0, \gate.kr(1));
    snd = FreeVerb2.ar(snd[0], snd[1], 0.3, 0.9);
    snd = snd * Env.asr(0, 1.0, 4, 6).kr(2, \gate.kr(1));
    Out.ar(\out.kr(0), snd * \amp.kr(0.1));
}).add;
)

(
var durations;
durations = [1, 1, 1, 1, 3/4, 1/4, 1/2, 3/4, 1/4, 1/2];
Ppar([
    Pbind(*[
        instrument: \gabberkick,
        amp: -23.dbamp,
        freq: 60,
        legato: 0.8,
        ffreq: Pseq((0..(durations.size * 4 - 1)).normalize, inf).linexp(0, 1, 100, 4000),
        dur: Pseq(durations, inf),
        bend: Pfuncn({ |x| if(x &amp;lt; (1/2), 0.4, 1) }, inf) &amp;lt;&amp;gt; Pkey(\dur),
    ]),
    Pbind(*[
        instrument: \hoover,
        amp: -20.dbamp,
        midinote: 74,
        dur: durations.sum * 2,
        sustain: 7,
    ])
]).play(TempoClock(210 / 60));
)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I wasn&apos;t able to translate it into the Lisp form, because &lt;code&gt;cl-collider&lt;/code&gt; does not have documentation and diving into it will require too much time. However, there is a working code example from its README, which you can try in the REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:in-readtable :sc)
POFTHEDAY&amp;gt; (setf sc:*s* (sc:make-external-server
                         &amp;quot;localhost&amp;quot; :port 48800))
POFTHEDAY&amp;gt; (use-package :sc)

POFTHEDAY&amp;gt; (defsynth saw-synth ((note 60) (dur 4.0))
             (let* ((env (env-gen.kr (env [0 .2 0]
                                          [(* dur .2) (* dur .8)])
                                     :act :free))
                    (freq (midicps note))
                    (sig (lpf.ar (saw.ar freq env)
                                 (* freq 2))))
               (out.ar 0 [sig sig])))

POFTHEDAY&amp;gt; (defun make-melody (time n &amp;amp;optional (offset 0))
             (when (&amp;gt; n 0)
               (at time (synth &amp;#039;saw-synth
                               :note (+ offset (alexandria:random-elt
                                                &amp;#039;(62 65 69 72)))))
               (let ((next-time (+ time (alexandria:random-elt
                                         &amp;#039;(0 1 2 1.5)))))
                 (callback next-time #&amp;#039;make-melody
                           next-time (- n 1) offset))))

POFTHEDAY&amp;gt; (make-melody (quant 4) 16)
POFTHEDAY&amp;gt; (make-melody (+ 4 (quant 4)) 16 12)

;; This will stop the music
POFTHEDAY&amp;gt; (sc:stop)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is a demo, showing how does live coding works with &lt;code&gt;cl-collider&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=pZyuHjztARY&quot;&gt;https://www.youtube.com/watch?v=pZyuHjztARY&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To try &lt;code&gt;cl-collider&lt;/code&gt;, you&apos;ll need to install a SuperCollider. On OSX it is as simple as doing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; bash&apos;&gt;brew cask install supercollider&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Mon, 25 May 2020 20:19:16 +0300</pubDate>
        </item>
        <item>
            <title>trivial-ssh</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0078-trivial-ssh.html</link>
            <description>&lt;p&gt;This system is a simple wrapper around cl-libssh2 which is binding to the libssh2. Trivial SSH provides a few macros to safely establish a connection, open and close streams.&lt;/p&gt;
&lt;p&gt;In the next example we&apos;ll connect to the host and run two commands to get its hostname and OS description:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; Make this before Quickloading the system:
;; brew upgrade libssh2

POFTHEDAY&amp;gt; (flet ((read-lines (s)
                    (loop for line = (read-line s nil nil)
                          while line
                          collect line)))

             (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot; (ssh:agent &amp;quot;root&amp;quot;))
               (values
                (ssh:with-command (conn iostream &amp;quot;hostname -f&amp;quot;)
                                  (read-lines iostream))
                (ssh:with-command (conn iostream &amp;quot;lsb_release --id --release --codename&amp;quot;)
                                  (read-lines iostream)))))
(&amp;quot;my-lovely-host.inter.net&amp;quot;)
(&amp;quot;Distributor ID:	Ubuntu&amp;quot;
 &amp;quot;Release:	18.04&amp;quot;
 &amp;quot;Codename:	bionic&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, there is are commands to upload and download files using SCP protocol. Here is how we can copy the bootstrap file to the host and execute it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot; (ssh:agent &amp;quot;root&amp;quot;))
               (ssh:upload-file conn &amp;quot;install.sh&amp;quot; &amp;quot;/tmp/install.sh&amp;quot;)
               (ssh:with-command (conn stream &amp;quot;chmod +x /tmp/install.sh&amp;quot;))
                 (ssh:with-command (conn stream &amp;quot;/tmp/install.sh&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The cool part of &lt;code&gt;with-command&lt;/code&gt; macro is that you have a communication stream and can read output during the command execution. Here we are installing Emacs on the remote host and can observe the process:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0078/install-emacs.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here is the code from this sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((-&amp;gt; (from to)
                    (loop for line = (read-line from nil nil)
                       while line
                       do (write-string line to)
                          (terpri))))
             (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot;
                                        (ssh:agent &amp;quot;root&amp;quot;))
               (ssh:with-command
                   (conn stream &amp;quot;apt-get update &amp;amp;&amp;amp;
                                apt-get install -y emacs-nox&amp;quot;)
                   (-&amp;gt; stream *standard-output*))))&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Update&lt;/h2&gt;&lt;p&gt;Found that &lt;code&gt;cl-libssh2&lt;/code&gt; does not support agent forwarding. Because of that, I&apos;m not able to call &lt;code&gt;git pull&lt;/code&gt; on the remote machine.&lt;/p&gt;
&lt;p&gt;I tried to patch &lt;code&gt;cl-libssh2&lt;/code&gt; to support the latest &lt;code&gt;libssh2&lt;/code&gt; where agent forwarding was supported in August 2019, but this patch does not work yet.&lt;/p&gt;
&lt;p&gt;If somebody is interested to help me with that, he might try this pull-request:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alxchk/cl-libssh2/pull/7&quot;&gt;https://github.com/alxchk/cl-libssh2/pull/7&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Sun, 24 May 2020 20:54:00 +0300</pubDate>
        </item>
        <item>
            <title>named-readtables</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0077-named-readtables.html</link>
            <description>&lt;p&gt;This system is highly recommended if you are writing a code which modifies a &lt;code&gt;*readtable*&lt;/code&gt; because it allows to define and switch between readtables as you do with Lisp packages.&lt;/p&gt;
&lt;p&gt;If you are not familiar with what &lt;code&gt;*readtable*&lt;/code&gt; is, then read this article:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lisper.in/reader-macros&quot;&gt;https://lisper.in/reader-macros&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;but pay attention, that the article manipulates with &lt;code&gt;*readtable*&lt;/code&gt; instead of using &lt;code&gt;named-readtables&lt;/code&gt;. This is bad. Use &lt;code&gt;named-readtables&lt;/code&gt; instead.&lt;/p&gt;
&lt;p&gt;First, let&apos;s see how to use &lt;code&gt;named-readtables&lt;/code&gt; to switch between read-tables. As an example, we&apos;ll see how to use &lt;code&gt;cl-interpol&lt;/code&gt; and &lt;code&gt;rutils&lt;/code&gt; readtables.&lt;/p&gt;
&lt;p&gt;This is how you can lookup which tables are available:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ql:quickload &amp;#039;(:cl-interpol :rutils))

POFTHEDAY&amp;gt; (named-readtables:list-all-named-readtables)
(#&amp;lt;NAMED-READTABLE :COMMON-LISP {1000024B73}&amp;gt;
 #&amp;lt;NAMED-READTABLE :CURRENT {1000025663}&amp;gt;
 #&amp;lt;NAMED-READTABLE RUTILS.READTABLE:RUTILS-READTABLE {1004A960E3}&amp;gt;
 #&amp;lt;NAMED-READTABLE RUTILS.READTABLE:STANDARD-READTABLE {1004A96133}&amp;gt;
 #&amp;lt;NAMED-READTABLE :INTERPOL-SYNTAX {1001D19853}&amp;gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s see how does switching work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; First I&amp;#039;ll switch to the interpol&amp;#039;s syntax:
POFTHEDAY&amp;gt; (named-readtables:in-readtable :interpol-syntax)

POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #?&amp;quot;Hello ${username}!&amp;quot;)
&amp;quot;Hello Bob!&amp;quot;

;; Rutils readtable is not active, and we can&amp;#039;t
;; use it&amp;#039;s syntax for hashes:
POFTHEDAY&amp;gt; #h(:foo &amp;quot;bar&amp;quot;)
; Debugger entered on #&amp;lt;SB-INT:SIMPLE-READER-ERROR
; &amp;quot;no dispatch function defined for ~S&amp;quot; {10068D4C63}&amp;gt;

;; We have to activate  it first
POFTHEDAY&amp;gt; (named-readtables:in-readtable
            rutils:rutils-readtable)

POFTHEDAY&amp;gt; #h(:foo &amp;quot;bar&amp;quot;)
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 1 {10068B9013}&amp;gt;

;; But now we are unable to use iterpol&amp;#039;s syntax:
POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #?&amp;quot;Hello ${username}!&amp;quot;)
; Debugger entered on #&amp;lt;SB-INT:SIMPLE-READER-ERROR
; &amp;quot;no dispatch function defined for ~S&amp;quot; {1006AE93F3}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what if we want to use both readtables from &lt;code&gt;cl-interpol&lt;/code&gt; and from &lt;code&gt;rutils&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;It is possible if we merge them together and create a new readtable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:defreadtable
               :poftheday
             (:merge
              rutils:rutils-readtable
              :interpol-syntax))

POFTHEDAY&amp;gt; (named-readtables:in-readtable
            :poftheday)

POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #h(:greeting #?&amp;quot;Hello ${username}!&amp;quot;))
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 1 {1003054C23}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-ht *)
#{
  :GREETING &amp;quot;Hello Bob!&amp;quot;
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we&apos;ll define a literal syntax for lambda from &lt;code&gt;rutils&lt;/code&gt; as a separate named read-table:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; &apos;&gt;POFTHEDAY&amp;gt; (defmacro trivial-positional-lambda (body)
             `(lambda (&amp;amp;optional % %%)
                (declare (ignorable %) (ignorable %%))
                ,body))

POFTHEDAY&amp;gt; (defun |^-reader| (stream char)
             (declare (ignore char))
             (let ((sexp (read stream t nil t)))
               `(trivial-positional-lambda
                 ,(if (and (listp sexp) (listp (car sexp)))
                      (cons &amp;#039;progn sexp)
                      sexp))))

POFTHEDAY&amp;gt; (named-readtables:defreadtable
               :lambda
             (:merge :standard)
             (:macro-char #\^ #&amp;#039;|^-reader|))

;; Now we can switch to the new readtable
;; and use new syntax for lambdas:
POFTHEDAY&amp;gt; (named-readtables:in-readtable :lambda)

POFTHEDAY&amp;gt; ^(+ % %%)
#&amp;lt;FUNCTION (LAMBDA (&amp;amp;OPTIONAL % %%)) {2252593B}&amp;gt;

POFTHEDAY&amp;gt; (funcall *
                    2
                    3)
5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Named readtables has yet another useful feature - it integrates with SLIME. When you have a &lt;code&gt;(in-readtable)&lt;/code&gt; call after you package definition, SLIME will know what &lt;code&gt;readtable&lt;/code&gt; to use when you hit &lt;code&gt;Ctrl-C Ctrl-C&lt;/code&gt; on defuns.&lt;/p&gt;
&lt;p&gt;That is what &lt;code&gt;in-readtable&lt;/code&gt; expands to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:in-readtable :interpol-syntax)

;; It expands to:
(eval-when (:compile-toplevel
            :load-toplevel
            :execute)
  (setf *readtable*
        (named-readtables:ensure-readtable
         &amp;#039;:interpol-syntax))
  (when (find-package :swank)
    (named-readtables::%frob-swank-readtable-alist
     *package*
     *readtable*)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This &lt;code&gt;%frob-swank-readtable-alist&lt;/code&gt; modifies &lt;code&gt;swank:*readtable-alist*&lt;/code&gt; to make it know what readtable should be used for the package. But a comment to this code says it is a &lt;code&gt;KLUDGE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Interesting, how this will or should work in the LispWorks?&lt;/p&gt;
</description>
            <pubDate>Sat, 23 May 2020 21:18:23 +0300</pubDate>
        </item>
    </channel>
</rss>