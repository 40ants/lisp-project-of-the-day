<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>lack</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0107-lack.html</link>
            <description>&lt;p&gt;&lt;code&gt;Lack&lt;/code&gt; is a library, used by &lt;code&gt;Clack&lt;/code&gt; to compose web apps from middlewares.&lt;/p&gt;
&lt;p&gt;Yesterday &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0106-lack-middleware-accesslog.html&quot;&gt;we&apos;ve used&lt;/a&gt; the &lt;code&gt;lack-middleware-accesslog&lt;/code&gt; system to log every request to our webapp. But app configuration was not convenient. &lt;code&gt;Lack&lt;/code&gt; provides a macro to compose an application from middlewares:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lack:builder
              ;; middlewares
              :accesslog
              ;; the app
              (lambda (env)
                (declare (ignorable env))
                &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                  (&amp;quot;Hello, World&amp;quot;)))))

POFTHEDAY&amp;gt; (clack:clackup *app*
                          :port 8080)
Hunchentoot server is started.
Listening on 127.0.0.1:8080.

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8080/foo/bar&amp;quot;))
127.0.0.1 - [22/Jun/2020:22:15:23 +03:00] &amp;quot;GET /foo/bar HTTP/1.1&amp;quot;
         200 12 &amp;quot;-&amp;quot; &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can pass a middleware as a keyword or as a s-exp. In the slatter case, all values except the first one, will be passed to the middleware functions.&lt;/p&gt;
&lt;p&gt;This way a middleware can be configured. Here is for example, how we can replace a logging function to use &lt;code&gt;log4cl&lt;/code&gt; (by the way, remind me to tell you about &lt;code&gt;log4cl&lt;/code&gt;, it is wonderful!):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lack:builder
              ;; middlewares
              (:accesslog :logger
                          (lambda (message)
                            (log:info message)))
              ;; the app
              (lambda (env)
                (declare (ignorable env))
                &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                  (&amp;quot;Hello, World&amp;quot;)))))

POFTHEDAY&amp;gt; (clack:clackup *app*
                          :port 8081)

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8081/foo/bar&amp;quot;))

 &amp;lt;INFO&amp;gt; [22:38:06] poftheday () -
  POFTHEDAY::MESSAGE: &amp;quot;127.0.0.1 - [22/Jun/2020:22:38:06 +03:00] 
                \&amp;quot;GET /foo/bar HTTP/1.1\&amp;quot; 200 12 \&amp;quot;-\&amp;quot;
                \&amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0\&amp;quot;&amp;quot;
  
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Multiple middlewares can be passed to the &lt;code&gt;lack:builder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When we are specifying the middleware&apos;s name as a keyword, lack tries to search a middleware function using &lt;code&gt;lack.util:find-middleware&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lack.util:find-middleware :accesslog)

#&amp;lt;FUNCTION (LAMBDA (LACK.MIDDLEWARE.ACCESSLOG::APP &amp;amp;KEY :LOGGER :FORMATTER)
             :IN
             &amp;quot;/Users/art/projects/lisp/lisp-project-of-the-day/.qlot/dists/\
  ultralisp/software/fukamachi-lack-20200524065357/src/middleware/accesslog.lisp&amp;quot;)
  {22D1F6CB}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you intend to create an opensource library providing &lt;code&gt;Lack&lt;/code&gt; middleware and want this discovery work for it, then you have to follow these rules.&lt;/p&gt;
&lt;p&gt;Your system has to define a package prefixed with &lt;code&gt;LACK.MIDDLEWARE.&lt;/code&gt; And it should export a variable with name matched to the pattern &lt;code&gt;*LACK-MIDDLEWARE-...*&lt;/code&gt;. This variable should be bound to a middleware function.&lt;/p&gt;
&lt;p&gt;For example, access log middleware defines the &lt;code&gt;LACK.MIDDLEWARE.ACCESSLOG:*LACK-MIDDLEWARE-ACCESSLOG*&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;Another interesting feature, I didn&apos;t cover yet the ability to write an app which delays it&apos;s response or stream it back. Luckily, these kinds of applications &lt;a href=&quot;https://github.com/fukamachi/lack#delayed-response-and-streaming-body&quot;&gt;are covered by&lt;/a&gt; &lt;code&gt;Lack&lt;/code&gt;&apos;s documentation.&lt;/p&gt;
&lt;p&gt;Tomorrow, we&apos;ll look at some &lt;code&gt;Lack&apos;s&lt;/code&gt; middleware.&lt;/p&gt;
</description>
            <pubDate>Mon, 22 Jun 2020 22:32:36 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-accesslog</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0106-lack-middleware-accesslog.html</link>
            <description>&lt;p&gt;Yesterday, I&apos;ve showed you how does Clack work. A web app is a function which returns a list with the response or a function which should return create such list pass it to the provided callback.&lt;/p&gt;
&lt;p&gt;Now we&apos;ll add a logging to our app with the &lt;code&gt;lack-middleware-accesslog&lt;/code&gt; system.&lt;/p&gt;
&lt;p&gt;To do this, we must wrap our app&apos;s function into another function like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Now we&amp;#039;ll create a simple app:
POFTHEDAY&amp;gt; (defparameter *app*
             (lambda (env)
               &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                 (&amp;quot;Hello, World&amp;quot;))))

;; And wrap it into the middleware:
POFTHEDAY&amp;gt; (defparameter *app-with-access-log*
             (funcall lack.middleware.accesslog:*lack-middleware-accesslog*
                      *app*))

;; Now it&amp;#039;s time to start our app:
POFTHEDAY&amp;gt; (clack:clackup *app-with-access-log*
                          :port 8000)

Woo server is started.
Listening on 127.0.0.1:8000.

;; And to make a test request:
POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8000/&amp;quot;))
127.0.0.1 - [21/Jun/2020:22:50:52 +03:00] &amp;quot;GET / HTTP/1.1&amp;quot; 
  200 12 &amp;quot;-&amp;quot; &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Look how a log message was printed to the STDOUT.&lt;/p&gt;
&lt;p&gt;Now let&apos;s see how does this middleware works. Here is its content. It is a little bit complicated because the middleware needs to handle cases when an app returns a function instead of the normal response:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defparameter *lack-middleware-accesslog*
  (let ((no-body &amp;#039;#:no-body))
    (lambda (app &amp;amp;key
              (logger
               (lambda (output) (format t &amp;quot;~&amp;amp;~A~%&amp;quot; output)))
              (formatter #&amp;#039;default-formatter))
      (lambda (env)
        (funcall-with-cb
         app env
         (lambda (res)
           (funcall logger
                    (funcall formatter env res (now)))
           res)))))
  &amp;quot;Middleware for logging requests&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I&apos;ll show you a simpler version of this logging middleware:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Here is the middleware:
POFTHEDAY&amp;gt; (defun simple-logging (app)
             (lambda (env)
               (let ((response
                       (funcall app env)))
                 (format t &amp;quot;~A ~A -&amp;gt; ~A~%&amp;quot;
                         (getf env :request-method)
                         (getf env :path-info)
                         (car response))
                 response)))

;; And this is an example how we can apply it to our app:
POFTHEDAY&amp;gt; (defparameter *app-with-simple-log*
             (simple-logging *app*))

POFTHEDAY&amp;gt; (clack:clackup *app-with-simple-log*
                          :port 8000)
Hunchentoot server is started.
Listening on 127.0.0.1:8000.

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8000/&amp;quot;))
GET / -&amp;gt; 200
&amp;quot;Hello, World&amp;quot;

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8000/foo/bar&amp;quot;))
GET /foo/bar -&amp;gt; 200
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow we&apos;ll try the better way to apply middlewares to a Clack app.&lt;/p&gt;
</description>
            <pubDate>Sun, 21 Jun 2020 23:20:42 +0300</pubDate>
        </item>
        <item>
            <title>clack</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0105-clack.html</link>
            <description>&lt;p&gt;Today we begin our sprint around Fukamachi&apos;s web tools and will start from the Clack.&lt;/p&gt;
&lt;p&gt;Clack is an intermediate layer between the real webserver and your application code. It unifies requests parsing and you don&apos;t need to rewrite an app if you&apos;ll decide to run your app under another webserver.&lt;/p&gt;
&lt;p&gt;Today it supports FCGI, Hunchentoot, Toot, Woo, Wookie. Woo and Wookie are asynchronous and can be used to serve hundreds of simultaneous connections.&lt;/p&gt;
&lt;p&gt;Another interesting feature of Clack is that application is the only a lambda function. Because of this, the application code can be wrapped with middlewares. There are a number of middlewares: for logging, handling errors, serving static files, etc.&lt;/p&gt;
&lt;p&gt;Here is an example of the simplest app. A function should return a list of status-code, headers plist and the content. The content should be a list of strings, a vector of bytes or pathname:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *server*
             (clack:clackup
              (lambda (env)
                (declare (ignore env))
                &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                  (&amp;quot;Hello, Lisp World!&amp;quot;)))
              :port 8000))
Hunchentoot server is started.
Listening on 127.0.0.1:8000.

POFTHEDAY&amp;gt; (nth-value 0
             (dex:get &amp;quot;http://localhost:8000&amp;quot;))
&amp;quot;Hello, Lisp World!&amp;quot;

POFTHEDAY&amp;gt; (clack:stop *server*)
T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Compare this with plain Hunchentoot application:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (hunchentoot:define-easy-handler (say-yo :uri &amp;quot;/&amp;quot;) ()
             (setf (hunchentoot:content-type*)
                   &amp;quot;text/plain&amp;quot;)
             &amp;quot;Hello Lisp World&amp;quot;)

POFTHEDAY&amp;gt; (hunchentoot:start
            (make-instance &amp;#039;hunchentoot:easy-acceptor
                           :port 8002))

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8002/&amp;quot;
                    :headers &amp;#039;((&amp;quot;Custom-Header&amp;quot; . &amp;quot;Hello&amp;quot;)))
127.0.0.1 - [2020-06-20 20:58:04] &amp;quot;GET / HTTP/1.1&amp;quot; 200 16 &amp;quot;-&amp;quot; 
            &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
&amp;quot;Hello Lisp World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Clack version is more coherent. All request parameters are in one place and it is obvious how to return a status code or the headers.&lt;/p&gt;
&lt;p&gt;Here is the content of the env var passed by the Clack to the application function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; For this request:
POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8000/some/path&amp;quot;
                    :headers &amp;#039;((&amp;quot;Custom-Header&amp;quot; . &amp;quot;Hello&amp;quot;)))

;; This plist will be passed as env argument
;; to the function:
(:REQUEST-METHOD :GET
 :SCRIPT-NAME &amp;quot;&amp;quot;
 :PATH-INFO &amp;quot;/some/path&amp;quot;
 :SERVER-NAME &amp;quot;localhost&amp;quot;
 :SERVER-PORT 8000
 :SERVER-PROTOCOL :HTTP/1.1
 :REQUEST-URI &amp;quot;/some/path&amp;quot;
 :URL-SCHEME &amp;quot;http&amp;quot;
 :REMOTE-ADDR &amp;quot;127.0.0.1&amp;quot;
 :REMOTE-PORT 51325
 :QUERY-STRING NIL
 :RAW-BODY #&amp;lt;FLEXI-STREAMS:FLEXI-IO-STREAM {1009183813}&amp;gt;
 :CONTENT-LENGTH 0
 :CONTENT-TYPE NIL
 :CLACK.STREAMING T
 :CLACK.IO #&amp;lt;CLACK.HANDLER.HUNCHENTOOT::CLIENT {1009183863}&amp;gt;
 :HEADERS #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 4 {1009183AE3}&amp;gt;)

;; And here is the content of the HEADERS:
POFTHEDAY&amp;gt; (rutils:print-hash-table
            (getf * :headers))
#{EQUAL
  &amp;quot;user-agent&amp;quot; &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
  &amp;quot;host&amp;quot; &amp;quot;localhost:8000&amp;quot;
  &amp;quot;accept&amp;quot; &amp;quot;*/*&amp;quot;
  &amp;quot;custom-header&amp;quot; &amp;quot;Hello&amp;quot;
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow we&apos;ll review a Clack middleware and see how to apply to the app.&lt;/p&gt;
</description>
            <pubDate>Sat, 20 Jun 2020 21:12:07 +0300</pubDate>
        </item>
        <item>
            <title>pcall</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0104-pcall.html</link>
            <description>&lt;p&gt;This library contains a few primitives for parallel code execution. It is like a baby lparallel.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PCall&lt;/code&gt; provides a thread pool, few macro to execute and wait parallel task and a thread-safe Queue.&lt;/p&gt;
&lt;p&gt;Here is a simple demo which runs two tasks in parallel and then executes a body. A digit on each line is a number of seconds elapsed since the form was evaluated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((started-at (get-universal-time)))
             (flet ((info (message &amp;amp;rest args)
                      (let ((seconds-since-start
                              (- (get-universal-time)
                                  started-at)))
                        (format t &amp;quot;~A: ~A~%&amp;quot;
                                seconds-since-start
                                (apply #&amp;#039;format nil message
                                       args)))))
               (pcall:plet ((foo (progn (info &amp;quot;Creating Foo&amp;quot;)
                                        (sleep 5)
                                        (info &amp;quot;Foo was created&amp;quot;)
                                        :foo-result))
                            (bar (progn (info &amp;quot;Creating Bar&amp;quot;)
                                        (sleep 3)
                                        (info &amp;quot;Bar was created&amp;quot;)
                                    :bar-result)))
                 (info &amp;quot;Plet&amp;#039;s body is executed immediately.&amp;quot;)
                 (info &amp;quot;And it will wait for the result when you access the value.&amp;quot;)
                 (info &amp;quot;Here is the Bar&amp;#039;s value: ~S&amp;quot;
                       bar)
                 (info &amp;quot;Task foo still executing in the background.&amp;quot;)
                 (info &amp;quot;Here is the Foo&amp;#039;s value: ~S&amp;quot;
                       foo))))
0: Plet&amp;#039;s body is executed immediately.
0: And it will wait for the result when you access the value.
0: Creating Bar
0: Creating Foo
3: Bar was created
3: Here is the Bar&amp;#039;s value: :BAR-RESULT
3: Task foo still executing in the background.
5: Foo was created
5: Here is the Foo&amp;#039;s value: :FOO-RESULT&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are a few more interesting functions allowing to execute and wait for tasks. And a thread-safe queue can be loaded using the standalone system &lt;code&gt;pcall-queue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PCall&lt;/code&gt; can be useful when you don&apos;t need such a sophisticated tool as lparallel and just want to use thread pool or queue.&lt;/p&gt;
&lt;p&gt;If you are interested in trying &lt;code&gt;PCall&lt;/code&gt;, read it&apos;s &lt;a href=&quot;http://marijn.haverbeke.nl/pcall/&quot;&gt;docs here&lt;/a&gt; because it is not hosted on the GitHub and Quickdocs.org does not show it&apos;s docs either.&lt;/p&gt;
</description>
            <pubDate>Fri, 19 Jun 2020 23:16:06 +0300</pubDate>
        </item>
        <item>
            <title>trivial-tco</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0103-trivial-tco.html</link>
            <description>&lt;p&gt;This library could be considered as a &lt;a href=&quot;http://portability.cl/&quot;&gt;portability layer&lt;/a&gt; for tail call optimization.&lt;/p&gt;
&lt;p&gt;When I first found it, I decided it implements a TCO for implementations which do not support it by doing a trampolining trick &lt;a href=&quot;https://macropy3.readthedocs.io/en/latest/tco.html#trampolining&quot;&gt;like this&lt;/a&gt;. But I was wrong.&lt;/p&gt;
&lt;p&gt;It does ensure the proper declaration is used on implementations which support a proper TCO and signals warning or error on others.&lt;/p&gt;
&lt;p&gt;Here is an example on SBCL, which supports TCO only if &lt;code&gt;speed&lt;/code&gt; declared to be greater or equal to &lt;code&gt;debug&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (declaim (optimize (debug 3) (speed 1))

POFTHEDAY&amp;gt; (labels ((sum-aux (acc x)
                        (if (zerop x)
                            acc
                            (sum-aux (+ acc x) (- x 1))))
                      (sum (n)
                        (sum-aux 0 n)))
               (sum 1000000))
Control stack guard page temporarily disabled: proceed with caution
; Debugger entered on #&amp;lt;SB-KERNEL::CONTROL-STACK-EXHAUSTED {1004F12E73}&amp;gt;
[1] POFTHEDAY&amp;gt; 
; Evaluation aborted on #&amp;lt;SB-KERNEL::CONTROL-STACK-EXHAUSTED {1004F12E73}&amp;gt;

POFTHEDAY&amp;gt; (tco:with-tail-call-optimization ()
             (labels ((sum-aux (acc x)
                        (if (zerop x)
                            acc
                            (sum-aux (+ acc x) (- x 1))))
                      (sum (n)
                        (sum-aux 0 n)))
               (sum 1000000)))
500000500000 (39 bits, #x746A5A2920)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This macro gets expanded into:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(let ()
  (declare (optimize (speed 3)))
  (labels ((sum-aux (acc x)
             (if (zerop x)
                 acc
                 (sum-aux (+ acc x) (- x 1))))
           (sum (n)
             (sum-aux 0 n)))
    (sum 1000000)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. Use this library, if you want to employ a tail call and want to ensure they a properly optimized by your Lisp implementation.&lt;/p&gt;
&lt;p&gt;Maybe &lt;a href=&quot;https://0branch.com/notes/tco-cl.html&quot;&gt;this article&lt;/a&gt; by Marc Simpson will be interesting for you. It investigates which Common Lisp implementations have a proper TCO implementation.&lt;/p&gt;
</description>
            <pubDate>Fri, 19 Jun 2020 00:35:23 +0300</pubDate>
        </item>
        <item>
            <title>lass-flexbox</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0102-lass-flexbox.html</link>
            <description>&lt;p&gt;This is an addon to the &lt;code&gt;lass&lt;/code&gt; library, reviewed in &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/03/0021-lass.html&quot;&gt;#0021 post&lt;/a&gt;. &lt;code&gt;Lass-flexbox&lt;/code&gt; adds to &lt;code&gt;lass&lt;/code&gt; an ability to expand Flexbox CSS properties into browser-specific vendor prefixes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lass:compile-and-write
            &amp;#039;(.container :flexbox
              (.item :align-self &amp;quot;center&amp;quot;)))
&amp;quot;.container{
    display: -webkit-box;
    display: -webkit-flex;
    display: -moz-flex;
    display: -ms-flexbox;
    display: flex;
}

.container .item{
    -webkit-align-self: center;
    -moz-align-self: center;
    -ms-flex-item-align: center;
    align-self: center;
}&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I found a great &lt;a href=&quot;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&quot;&gt;illustrated article&lt;/a&gt; on how does Flexbox works and now we&apos;ll try to reproduce some layout from this article:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (format t &amp;quot;&amp;lt;style&amp;gt;~A&amp;lt;/style&amp;gt;
                      &amp;lt;div class=\&amp;quot;example\&amp;quot;&amp;gt;
                        &amp;lt;div class=\&amp;quot;item\&amp;quot;&amp;gt;One&amp;lt;/div&amp;gt;
                        &amp;lt;div class=\&amp;quot;item\&amp;quot;&amp;gt;Two&amp;lt;/div&amp;gt;
                        &amp;lt;div class=\&amp;quot;item\&amp;quot;&amp;gt;Three&amp;lt;/div&amp;gt;
                      &amp;lt;/div&amp;gt;
                     &amp;quot;
                   (lass:compile-and-write
                    &amp;#039;(.example
                      :flexbox
                      :align-items &amp;quot;flex-end&amp;quot;
                      :justify-content &amp;quot;space-around&amp;quot;
                      :border 1px solid gray
                      (.item :margin 0.5rem
                             :padding 0.5rem)
                      ((:and .item (:nth-child 1))
                       :background lime
                       :flex 1
                       :height 30px)
                      ((:and .item (:nth-child 2))
                       :background orange
                       :flex 2
                       :height 70px)
                      ((:and .item (:nth-child 3))
                       :background purple
                       :flex 3
                       :height 50px))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This lisp code will generate us these CSS and HTML:&lt;/p&gt;
&lt;h4&gt;Code&lt;/h4&gt;&lt;pre&gt;&lt;code class=&apos;html :render&apos;&gt;&amp;lt;style&amp;gt;.example{
    display: -webkit-box;
    display: -webkit-flex;
    display: -moz-flex;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-align: end;
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    -moz-align-items: flex-end;
    align-items: flex-end;
    -ms-flex-pack: distribute;
    -webkit-justify-content: space-around;
    -moz-justify-content: space-around;
    justify-content: space-around;
    border: 1px solid gray;
}

.example .item{
    margin: 0.5rem;
    padding: 0.5rem;
}

.example .item:nth-child(1){
    background: lime;
    flex: 1;
    height: 30px;
}

.example .item:nth-child(2){
    background: orange;
    flex: 2;
    height: 70px;
}

.example .item:nth-child(3){
    background: purple;
    flex: 3;
    height: 50px;
}&amp;lt;/style&amp;gt;

&amp;lt;div class=&amp;quot;example&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;One&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;Two&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;Three&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;Result&lt;/h4&gt;&lt;style&gt;.example{
    display: -webkit-box;
    display: -webkit-flex;
    display: -moz-flex;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-align: end;
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    -moz-align-items: flex-end;
    align-items: flex-end;
    -ms-flex-pack: distribute;
    -webkit-justify-content: space-around;
    -moz-justify-content: space-around;
    justify-content: space-around;
    border: 1px solid gray;
}

.example .item{
    margin: 0.5rem;
    padding: 0.5rem;
}

.example .item:nth-child(1){
    background: lime;
    flex: 1;
    height: 30px;
}

.example .item:nth-child(2){
    background: orange;
    flex: 2;
    height: 70px;
}

.example .item:nth-child(3){
    background: purple;
    flex: 3;
    height: 50px;
}&lt;/style&gt;

&lt;div class=&quot;example&quot;&gt;
  &lt;div class=&quot;item&quot;&gt;One&lt;/div&gt;
  &lt;div class=&quot;item&quot;&gt;Two&lt;/div&gt;
  &lt;div class=&quot;item&quot;&gt;Three&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Exciting, isn&apos;t it!?&lt;/p&gt;
</description>
            <pubDate>Wed, 17 Jun 2020 20:25:01 +0300</pubDate>
        </item>
        <item>
            <title>prbs</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0101-prbs.html</link>
            <description>&lt;p&gt;&lt;a href=&quot;https://github.com/jlowder/prbs&quot;&gt;This library&lt;/a&gt; provides a pseudo-random binary sequence generator useful for error detection in communication streams. It will be useful, if you are building own protocol over UDP, for example.&lt;/p&gt;
&lt;p&gt;Here is how it works. There is a function which creates a sequence generator. Its result is a lambda function which can return a requested number of random bits:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *generator*
             (prbs:bit-gen 33 :seed (get-universal-time)))

POFTHEDAY&amp;gt; (funcall *generator* 10)
#*0111000101

POFTHEDAY&amp;gt; (funcall *generator* 10)
#*0010011100

POFTHEDAY&amp;gt; (funcall *generator* 10)
#*1011001110&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a function to check if these pieces match the desired sequence. It should be used on the &quot;receiver&quot; to check if the message was corrupted or some packets were lost.&lt;/p&gt;
&lt;p&gt;Let&apos;s simulate a situation when we send our data in 1024 bit chunks and one chunk was lost:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;SENDER&amp;gt; (defparameter *generator*
           (prbs:bit-gen 33 :seed (get-universal-time)))

;; These chunks are generated by the sender side
SENDER&amp;gt; (defparameter *first-chunk*
           (funcall *generator* 1024))

SENDER&amp;gt; *first-chunk*
#*011100010100100111001000001001110111...

SENDER&amp;gt; (defparameter *second-chunk*
           (funcall *generator* 1024))

SENDER&amp;gt; (defparameter *third-chunk*
           (funcall *generator* 1024))

;; The reveiver creates a special tracker
;; when it receives the first chunk of data
RECEIVER&amp;gt; (defparameter *tracker*
             (prbs.err:prbs-lock
              *first-chunk*
              33))
RECEIVER&amp;gt; *tracker*
#&amp;lt;CLOSURE (LAMBDA (PRBS.ERR::BITS) :IN PRBS.ERR::MAKE-TRACKER) {10080FF8BB}&amp;gt;

;; Now let&amp;#039;s pretend we have lost our second packet
;; and process the third right after the first one:
RECEIVER&amp;gt; (funcall *tracker*
             *third-chunk*)
520
2048&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In case of found errors, &lt;code&gt;tracker&lt;/code&gt; returns their number as the first value. The second value is the total number of processed bits. This way we can calculate an error rate. In this case, tracker decided there are 520 bits which have wrong values.&lt;/p&gt;
&lt;p&gt;Let&apos;s simulate another situation when it received the second chunk, but 10 bits were corrupted and their value was flipped:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;SENDER&amp;gt; (defparameter *corrupted-second-chunk*
           (copy-seq *second-chunk*))

;; Accidentally, some bits were corrupted:
IN-THE-MIDDLE&amp;gt; (loop for i from 100 below 110
                     do (setf (bit *corrupted-second-chunk* i)
                              (logxor (bit *corrupted-second-chunk* i)
                                      1)))

RECEIVER&amp;gt; (defparameter *tracker*
            (prbs.err:prbs-lock
             *first-chunk*
             33))

;; Now we process the corrupted chunk:
RECEIVER&amp;gt; (funcall *tracker*
                    *corrupted-second-chunk*)
10
2048

;; After the processing of third chunk,
;; tracker still show us there were encountered 10
;; errors:
RECEIVER&amp;gt; (funcall *tracker*
                   *third-chunk*)
10
3072&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, this library will be useful if you&apos;ll decide to implement a protocol which needs to determine if there were errors introduced into the data.&lt;/p&gt;
</description>
            <pubDate>Tue, 16 Jun 2020 22:28:25 +0300</pubDate>
        </item>
        <item>
            <title>the-cost-of-nothing</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0100-the-cost-of-nothing.html</link>
            <description>&lt;p&gt;This is a library by Marco Heisig. It is convenient to use when you want to decide which data structure to use or whether some function is too slow.&lt;/p&gt;
&lt;p&gt;Of cause, you can measure execution time with the &lt;code&gt;time&lt;/code&gt; macro. But in this case, you&apos;ll have to select a number of iteration and to parse &lt;code&gt;time&lt;/code&gt;&apos;s output and do some time manipulation.&lt;/p&gt;
&lt;p&gt;The-cost-of-nothing does everything for you. It runs given form in chunks, measures an execution time for each chunk, divides and calculates average execution time.&lt;/p&gt;
&lt;p&gt;Let&apos;s see how long does it take to access an element in the hash-table.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (time
              (loop repeat 1000000000
                    do (gethash :foo h))))
Evaluation took:
  0.271 seconds of real time
  0.270554 seconds of total run time (0.270170 user, 0.000384 system)
  100.00% CPU
  597,543,804 processor cycles
  0 bytes consed

;; Now we have to calculate a speed of the
;; single operation:
POFTHEDAY&amp;gt; (/ 0.271
              1000000000)
2.71e-10&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I had to guess a number of iteration to get meaningful execution time and also did some arithmetics after that.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:benchmark
              (gethash :foo h)))
1.11d-8

;; You also can receive a human readable value:
POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:bench
              (gethash :foo h)))
11.36 nanoseconds&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we see result 11 nanoseconds, however with &lt;code&gt;time&lt;/code&gt; macro we received only 0.271 nanoseconds. Probably this is because the overhead introduced by &lt;code&gt;the-cost-of-nothing&lt;/code&gt;. It tries to subtract overhead time from the result, but seems it does works for very fast operations.&lt;/p&gt;
&lt;p&gt;In case if you are measuring the cost of very fast operations it is better to make a loop even when using the-cost-of-nothing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (/ (the-cost-of-nothing:benchmark
                 (loop repeat 1000
                       do (gethash :foo h)))
                1000))
2.59d-10&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;How does &lt;code&gt;benchmark&lt;/code&gt; macro work?&lt;/p&gt;
&lt;p&gt;It has two parameters: &lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;min-sample-time&lt;/code&gt;. A tested form gets wrapped into the lambda function and executed in the loop a number of times to measure samples.&lt;/p&gt;
&lt;p&gt;On each iteration, the form is executed in another loop where the number of iterations is automatically tuned to make this inner loop run no less than &lt;code&gt;min-sample-time&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After that, an average overall sampled times is calculated and &lt;code&gt;overhead&lt;/code&gt; time is subtracted. Overhead time is precalculated as the cost of nil form execution.&lt;/p&gt;
&lt;p&gt;On my system, overhead value is 2.7e-9.&lt;/p&gt;
&lt;p&gt;I tried to rewrite the function which measures a sample&apos;s time to make the calculation fairer, but without significant result.&lt;/p&gt;
&lt;p&gt;Here is what I&apos;ve got:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defun sample-execution-time-of-thunk (thunk min-sample-time)
  &amp;quot;Measure the execution time of invoking THUNK more and more often, until
the execution time exceeds MIN-SAMPLE-TIME.&amp;quot;
  (declare (optimize (speed 3) (debug 1)))
  
  (loop with started-at of-type integer = (get-internal-run-time)
        with run-until of-type integer = (+ started-at
                                             (round (* min-sample-time
                                                       internal-time-units-per-second)))
        for iterations of-type integer = 1 then (* iterations 2)
        summing iterations into total-iterations
        do (loop repeat iterations
                 do (funcall thunk))
        when (&amp;gt;= (get-internal-run-time)
                 run-until)
          do (return (/ (- (get-internal-run-time)
                            started-at)
                        internal-time-units-per-second
                        total-iterations))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I removed a call to an additional function and to &lt;code&gt;local-time:timestamp-difference&lt;/code&gt;, but result is not much better - only 10.71 nanoseconds.&lt;/p&gt;
&lt;p&gt;Am I missing something? Maybe compiler does some optimizations, when it sees a gethash call in a loop which does not change the dict?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:bench
              (gethash :foo h)))
10.71 nanoseconds&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another interesting thing about &lt;code&gt;the-cost-of-nothing&lt;/code&gt; is that it includes a benchmark which measures some the cost of some common operations.&lt;/p&gt;
&lt;p&gt;Even if they are not precise, it is interesting to compare their relative values. Here are numbers received on my Macbook Pro.&lt;/p&gt;
&lt;p&gt;Pay attention to how does cost grow for calling the function with multiple keyword arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (asdf:test-system :the-cost-of-nothing)

= The Cost Of Nothing =
Implementation: SBCL 2.0.2
Machine: X86-64 Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
Hostname: art-2osx

== Memory Management ==
Cost of allocating a cons cell: 6.76 nanoseconds
Cost of garbage collection: 10.68 milliseconds
Cost of full garbage collection: 107.05 milliseconds

== Functions ==
FUNCALL with zero mandatory arguments: 2.71 nanoseconds
FUNCALL with one mandatory argument: 2.68 nanoseconds
FUNCALL with two mandatory arguments: 2.52 nanoseconds
FUNCALL with three mandatory arguments: 2.43 nanoseconds
FUNCALL with four mandatory arguments: 2.74 nanoseconds
FUNCALL with five mandatory arguments: 2.62 nanoseconds
FUNCALL with six mandatory arguments: 2.78 nanoseconds
FUNCALL with zero optional arguments: 2.71 nanoseconds
FUNCALL with one optional argument: 3.24 nanoseconds
FUNCALL with two optional arguments: 3.00 nanoseconds
FUNCALL with three optional arguments: 3.23 nanoseconds
FUNCALL with four optional arguments: 3.09 nanoseconds
FUNCALL with five optional arguments: 3.42 nanoseconds
FUNCALL with six optional arguments: 3.38 nanoseconds
FUNCALL with zero keyword arguments: 2.71 nanoseconds
FUNCALL with one keyword argument: 5.35 nanoseconds
FUNCALL with two keyword arguments: 5.76 nanoseconds
FUNCALL with three keyword arguments: 8.34 nanoseconds
FUNCALL with four keyword arguments: 12.45 nanoseconds
FUNCALL with five keyword arguments: 14.88 nanoseconds
FUNCALL with six keyword arguments: 17.58 nanoseconds
FUNCALL with zero rest arguments: 2.71 nanoseconds
FUNCALL with one rest argument: 2.65 nanoseconds
FUNCALL with two rest arguments: 2.53 nanoseconds
FUNCALL with three rest arguments: 2.48 nanoseconds
FUNCALL with four rest arguments: 2.79 nanoseconds
FUNCALL with five rest arguments: 2.91 nanoseconds
FUNCALL with six rest arguments: 2.66 nanoseconds

== Numerics ==
Flops (single-float): 4.25 gigaflops
Flops (double-float): 2.71 gigaflops&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I think it would be great to make this library to output some statistics about collected samples - a number of samples, standard deviation, like IPython does:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;python&apos;&gt;Python 3.7.7 (default, Mar 10 2020, 15:43:33)
Type &amp;#039;copyright&amp;#039;, &amp;#039;credits&amp;#039; or &amp;#039;license&amp;#039; for more information
IPython 7.14.0 -- An enhanced Interactive Python. Type &amp;#039;?&amp;#039; for help.

In [1]: d = {&amp;#039;what&amp;#039;: 42}

In [2]: %timeit d[&amp;#039;what&amp;#039;]
35.7 ns &amp;#xB1; 0.405 ns per loop (mean &amp;#xB1; std. dev. of 7 runs, 10000000 loops each)

In [3]:&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As @guicho271828 &lt;a href=&quot;https://twitter.com/guicho271828/status/1272616501187678209&quot;&gt;noted&lt;/a&gt;, SBCL is able to figure out that gethash&apos;s results aren&apos;t used in the loop and optimizes it away.&lt;/p&gt;
&lt;p&gt;I&apos;ve checked this hypothesis, and with &lt;code&gt;gethash&lt;/code&gt; wrapped with a function results of &quot;time&quot; macro and &quot;benchmark&quot; macro are the same:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun get-value (h)
             (gethash :foo h))

POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (time
              (loop repeat 1000000000
                    do (get-value h))))
Evaluation took:
  12.968 seconds of real time
  12.966402 seconds of total run time (12.958497 user, 0.007905 system)
  99.98% CPU
  28,634,122,802 processor cycles
  0 bytes consed
  
POFTHEDAY&amp;gt; (/ 12.968
              1000000000)
1.2968e-8

POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:benchmark
              (get-value h)))
1.1339696e-8

POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:benchmark
              (gethash :foo h)))
1.0396756e-8&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Mon, 15 Jun 2020 22:19:19 +0300</pubDate>
        </item>
        <item>
            <title>teddy</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0099-teddy.html</link>
            <description>&lt;p&gt;I always wanted to work from Common Lisp with data like we do in Python. That is how does Teddy born.&lt;/p&gt;
&lt;p&gt;Teddy make it possible to define a data frame full of data, to slice it in different ways, to join data frames, see some statistics about the data and render plots.&lt;/p&gt;
&lt;p&gt;This is a proof of the concept and API will be changed. Check the ChangeLog.md to learn about new abilities and refactoring details.&lt;/p&gt;
&lt;p&gt;Here is how we can create a simple data frame:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/data-frame:make-data-frame
            &amp;#039;(&amp;quot;Idx&amp;quot; &amp;quot;Integers&amp;quot; &amp;quot;Uniform floats&amp;quot; &amp;quot;Gaussian&amp;quot;)
            :rows
            (loop repeat 10
                  for idx upfrom 0
                  collect (list idx
                                (random 100)
                                (random 1.0)
                                (statistics:random-normal
                                 :mean 5.0
                                 :sd 0.2))))
+-----+----------+----------------+----------+
| Idx | Integers | Uniform floats | Gaussian |
+-----+----------+----------------+----------+
|   0 |       41 |           0.27 |   4.89d0 |
|   1 |       98 |           0.08 |   4.93d0 |
|   2 |        8 |           0.45 |   5.15d0 |
|   3 |       56 |           0.63 |   4.87d0 |
|   4 |       79 |           0.42 |   4.72d0 |
|   5 |       19 |           0.04 |   4.73d0 |
|   6 |        1 |           0.34 |   4.93d0 |
|   7 |       79 |           0.60 |   5.25d0 |
|   8 |       42 |           0.08 |   5.10d0 |
|   9 |        7 |           0.86 |   5.31d0 |
+-----+----------+----------------+----------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can slice it by columns, rows or both:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/data-frame:head *d* 2)
+-----+----------+----------------+----------+
| Idx | Integers | Uniform floats | Gaussian |
+-----+----------+----------------+----------+
|   0 |       41 |           0.27 |   4.89d0 |
|   1 |       98 |           0.08 |   4.93d0 |
+-----+----------+----------------+----------+
POFTHEDAY&amp;gt; (teddy/data-frame:tail *d* 2)
+-----+----------+----------------+----------+
| Idx | Integers | Uniform floats | Gaussian |
+-----+----------+----------------+----------+
|   8 |       42 |           0.08 |   5.10d0 |
|   9 |        7 |           0.86 |   5.31d0 |
+-----+----------+----------------+----------+
POFTHEDAY&amp;gt; (teddy/data-frame:slice
            *d*
            :columns &amp;#039;(&amp;quot;idx&amp;quot; &amp;quot;gaussian&amp;quot;))
+-----+----------+
| Idx | Gaussian |
+-----+----------+
|   0 |   4.89d0 |
|   1 |   4.93d0 |
|   2 |   5.15d0 |
|   3 |   4.87d0 |
|   4 |   4.72d0 |
|   5 |   4.73d0 |
|   6 |   4.93d0 |
|   7 |   5.25d0 |
|   8 |   5.10d0 |
|   9 |   5.31d0 |
+-----+----------+
POFTHEDAY&amp;gt; (teddy/data-frame:slice *d*
            :columns &amp;#039;(&amp;quot;idx&amp;quot; &amp;quot;gaussian&amp;quot;)
            :from 4
            :to 6)
+-----+----------+
| Idx | Gaussian |
+-----+----------+
|   4 |   4.72d0 |
|   5 |   4.73d0 |
+-----+----------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, we might want to see some descriptive statistical data about our data frame. This is pretty easy with Teddy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/stats:stats *d*)
+----------------+--------+--------+--------+--------+--------+-------+-------+---------+
| Column         | Min    | p25    | p50    | p75    | Max    | Mean  | SD    | Sum     |
+----------------+--------+--------+--------+--------+--------+-------+-------+---------+
| Idx            |      0 |      2 |   4.50 |      7 |      9 |  4.50 |  3.03 |      45 |
| Integers       |      1 |      8 |  41.50 |     79 |     98 | 43.00 | 34.40 |     430 |
| Uniform floats |   0.04 |   0.08 |   0.38 |   0.60 |   0.86 |  0.38 |  0.27 |    3.75 |
| Gaussian       | 4.72d0 | 4.87d0 | 4.93d0 | 5.15d0 | 5.31d0 |  4.99 |  0.20 | 49.88d0 |
+----------------+--------+--------+--------+--------+--------+-------+-------+---------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Probably, we can make some extandable protocol to calculate other properties.&lt;/p&gt;
&lt;p&gt;Data frame stores data as columns. Each column is a vector of a particular type. If you want to process a row, you can create an iterator and use it to go through rows like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (loop with iterator = (teddy/data-frame:make-iterator *d*)
                 for row = (funcall iterator)
                 while row
                 do (format t &amp;quot;Row: ~S~%&amp;quot;
                            row))
Row: (0 41 0.26806116 4.887522971759381d0)
Row: (1 98 0.081421256 4.928584134866222d0)
Row: (2 8 0.45165908 5.147222819038834d0)
Row: (3 56 0.62647486 4.874349648519968d0)
Row: (4 79 0.41671002 4.7239718274963485d0)
Row: (5 19 0.04152584 4.727268395019779d0)
Row: (6 1 0.3369373 4.93339303609316d0)
Row: (7 79 0.59791017 5.2466443304900965d0)
Row: (8 42 0.076958776 5.103448455243024d0)
Row: (9 7 0.85732913 5.310498824093041d0)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Plotting facilities as rudimentary, but should be improved.. All functions related to plotting are in the &lt;code&gt;teddy/plot&lt;/code&gt; package. Right now &lt;code&gt;GNUPlot&lt;/code&gt; is used via &lt;a href=&quot;http://quickdocs.org/eazy-gnuplot/&quot;&gt;eazy-gnuplot&lt;/a&gt; library.&lt;/p&gt;
&lt;p&gt;Here is how we can plot our data from all columns:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/plot:plot *d*
            &amp;quot;docs/media/0099/simple-plot.png&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0099/simple-plot.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;If we want to plot only gaussian, then it will be wrong, because we need a histogram type of plot. This feature is &quot;to be done&quot;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/plot:plot
            (teddy/data-frame:slice *d*
                                    :columns &amp;#039;(&amp;quot;Idx&amp;quot; &amp;quot;Gaussian&amp;quot;))
            &amp;quot;docs/media/0099/gaussian.png&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0099/gaussian.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Another type of plots &lt;code&gt;Teddy&lt;/code&gt; is able to render right now is a &quot;timeseries&quot;.&lt;/p&gt;
&lt;p&gt;Let&apos;s plot how does Moscow&apos;s population was changed over years:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *moscow-population*
             (teddy/data-frame:make-data-frame
              &amp;#039;(&amp;quot;Date&amp;quot; &amp;quot;Population&amp;quot;)
              :rows &amp;#039;((&amp;quot;1350-01-01&amp;quot; 30000)
                      (&amp;quot;1840-01-01&amp;quot; 349000)
                      (&amp;quot;1907-01-01&amp;quot; 1345700)
                      (&amp;quot;1967-01-01&amp;quot; 6422000)
                      (&amp;quot;1994-01-01&amp;quot; 9066000)
                      (&amp;quot;2010-01-01&amp;quot; 11500000)
                      (&amp;quot;2020-01-01&amp;quot; 12680000))))
*MOSCOW-POPULATION*
POFTHEDAY&amp;gt; (teddy/plot:plot-timeseries
            *moscow-population* &amp;quot;docs/media/0099/moscow2.png&amp;quot;
            :title &amp;quot;Moscow population&amp;quot;)
&amp;quot;docs/media/0099/moscow.png&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0099/moscow.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Right now, Teddy installable only from Ultralisp, because it is the best place to host unstable fast-changing Common Lisp libraries.&lt;/p&gt;
&lt;p&gt;Join the effort to make &lt;code&gt;Teddy&lt;/code&gt; really useful for data analysis!&lt;/p&gt;
&lt;p&gt;Send your pull-requests to:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/40ants/teddy&quot;&gt;https://github.com/40ants/teddy&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Sun, 14 Jun 2020 23:31:39 +0300</pubDate>
        </item>
        <item>
            <title>cl-store</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0098-cl-store.html</link>
            <description>&lt;p&gt;I use this library in a few of my projects. It is much like Python&apos;s &lt;a href=&quot;https://docs.python.org/3/library/pickle.html&quot;&gt;pickle module&lt;/a&gt;, but a lot more extensible.&lt;/p&gt;
&lt;p&gt;CL-Store is able to store and restore back almost any Lisp object. For example, &lt;code&gt;lfarm&lt;/code&gt;, &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0094-lfarm.html&quot;&gt;reviewed four days ago&lt;/a&gt; uses it to serialize and deserialize parameters when executing remote jobs on the server.&lt;/p&gt;
&lt;p&gt;To demonstrate how it works, I&apos;ll create a vector of objects. Then we&apos;ll save this vector to the file and restore it back:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ((name :initarg :name
                    :reader user-name)))

POFTHEDAY&amp;gt; (defmethod print-object ((user user) stream)
             (print-unreadable-object (user stream :type t)
               (format stream &amp;quot;~A&amp;quot;
                       (user-name user))))

POFTHEDAY&amp;gt; (defparameter *users*
             (make-array 2
                         :initial-contents
                         (list (make-instance &amp;#039;user :name &amp;quot;Bob&amp;quot;)
                               (make-instance &amp;#039;user :name &amp;quot;Alice&amp;quot;))))

POFTHEDAY&amp;gt; *users*
#(#&amp;lt;USER Bob&amp;gt; #&amp;lt;USER Alice&amp;gt;)

;; Now we are ready to store our data to the file
POFTHEDAY&amp;gt; (cl-store:store *users* #P&amp;quot;/tmp/users.bin&amp;quot;)

;; and to restore it back:
POFTHEDAY&amp;gt; (cl-store:restore #P&amp;quot;/tmp/users.bin&amp;quot;)
#(#&amp;lt;USER Bob&amp;gt; #&amp;lt;USER Alice&amp;gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the resulting file. Don&apos;t be deceived by the readable content. This is the binary format and it might contain nonreadable characters:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;text&apos;&gt;[art@poftheday] cat /tmp/users.bin
CLCL
#USER#  POFTHEDAY
#NAMEBobAlice&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CL-Store can be extended. Originally it also provided a backend to serialize data into the XML. But now this backend is considered as deprecated.&lt;/p&gt;
&lt;p&gt;Previously I didn&apos;t write backends for CL-Store, but today I found in its docs an example, &lt;a href=&quot;https://common-lisp.net/project/cl-store/docs/cl-store_5.html#SEC19&quot;&gt;how to write a backend&lt;/a&gt;, compatible with  Python&apos;s pickle.&lt;/p&gt;
&lt;p&gt;Documentation is 13 years old, let&apos;s see if we&apos;ll be able to reproduce it!&lt;/p&gt;
&lt;p&gt;First, we need to define a new backend:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-store:defbackend pickle
             :stream-type &amp;#039;character)
#&amp;lt;PICKLE {100369EBB3}&amp;gt;

;; This small call expands into this huge amount of code:

(eval-when (:load-toplevel :execute)
  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defclass pickle (cl-store:backend) nil
              (:documentation
               &amp;quot;Autogenerated cl-store class for backend pickle.&amp;quot;))
    (defmacro defstore-pickle
              ((cl-store::var type stream &amp;amp;optional cl-store::qualifier)
               &amp;amp;body cl-store::body)
      (cl-store::with-gensyms (cl-store::gbackend)
        `(defmethod cl-store:internal-store-object ,@(if cl-store::qualifier
                                                         (list
                                                          cl-store::qualifier)
                                                         nil)
                    ((,cl-store::gbackend ,&amp;#039;pickle) (,cl-store::var ,type)
                     ,stream)
           ,(format nil &amp;quot;Definition for storing an object of type ~A with ~
 backend ~A&amp;quot;
                    type &amp;#039;pickle)
           (declare (ignorable ,cl-store::gbackend))
           ,@cl-store::body)))
    (defmacro defrestore-pickle
              ((type cl-store::place &amp;amp;optional cl-store::qualifier)
               &amp;amp;body cl-store::body)
      (cl-store::with-gensyms (cl-store::gbackend cl-store::gtype)
        `(defmethod cl-store::internal-restore-object ,@(if cl-store::qualifier
                                                            (list
                                                             cl-store::qualifier)
                                                            nil)
                    ((,cl-store::gbackend ,&amp;#039;pickle)
                     (,cl-store::gtype (eql &amp;#039;,type)) (,cl-store::place t))
           (declare (ignorable ,cl-store::gbackend ,cl-store::gtype))
           ,@cl-store::body))))
  (cl-store::register-backend &amp;#039;pickle &amp;#039;pickle nil &amp;#039;character &amp;#039;nil &amp;#039;nil))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use &lt;code&gt;defstore-pickle&lt;/code&gt; and &lt;code&gt;defrestore-pickle&lt;/code&gt; macroses to define rules for the processing of different data types.&lt;/p&gt;
&lt;p&gt;Here is where all real work is done:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *pickle-mapping*
             &amp;#039;((#\S . string))
             &amp;quot;A mapping from Pickle&amp;#039;s char codes
              to a Lisp data type&amp;quot;)

POFTHEDAY&amp;gt; (defmethod cl-store:get-next-reader ((backend pickle) (stream stream))
             &amp;quot;This method is responsible for recognizing what
              type of object should be read next.&amp;quot;
             (let ((type-code (read-char stream)))
               (or (cdr (assoc type-code *pickle-mapping*))
                   (values nil (format nil &amp;quot;Type ~A&amp;quot; type-code)))))

POFTHEDAY&amp;gt; (defrestore-pickle (noop stream)
             &amp;quot;We&amp;#039;ll skip unknown objects&amp;quot;)

POFTHEDAY&amp;gt; (defstore-pickle (obj string stream)
             &amp;quot;Here is how string should be written in Pickle&amp;#039;s format.&amp;quot;
             (format stream &amp;quot;S&amp;#039;~A&amp;#039;~%p0~%.&amp;quot; obj))

POFTHEDAY&amp;gt; (defrestore-pickle (string stream)
             &amp;quot;And this is a code to read string back&amp;quot;
             (let ((val (read-line stream)))
               (read-line stream) ;; remove the PUSH op
               (read-line stream) ;; remove the END op
               (subseq val 1 (1- (length val)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is time to test our functions. To make this old example work, I had to use old Python2.7, because Python3&apos;s pickle serializes into a little bit different format.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;python&apos;&gt;[art@poftheday] python2.7

&amp;gt;&amp;gt;&amp;gt; with open(&amp;#039;/tmp/word.pickle&amp;#039;, &amp;#039;w&amp;#039;) as f:
...     pickle.dump(&amp;#039;Hello Lisp World!&amp;#039;, f, protocol=0)
...
&amp;gt;&amp;gt;&amp;gt; ^D

[art@poftheday] cat /tmp/word.pickle
S&amp;#039;Hello Lisp World!&amp;#039;
p0
.

# Here is what I&amp;#039;ve got under Python3:

In [9]: with open(&amp;#039;/tmp/word.pickle&amp;#039;, &amp;#039;bw&amp;#039;) as f:
   ...:     pickle.dump(&amp;#039;Hello Lisp World!&amp;#039;, f, protocol=0)
   ...:

In [10]: !cat /tmp/word.pickle
VHello Lisp World!
p0
.
# This cl-store backend does not support V type code.
# Seems, it stands for a Unicode string.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can read this file from Lisp and write it back:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-store:restore #P&amp;quot;/tmp/word.pickle&amp;quot;
                             &amp;#039;pickle)
&amp;quot;Hello Lisp World!&amp;quot;

POFTHEDAY&amp;gt; (cl-store:store &amp;quot;Howdy, Python!&amp;quot;
                           #P&amp;quot;/tmp/word.pickle&amp;quot;
                           &amp;#039;pickle)
&amp;quot;Howdy, Python!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally, to ensure our backend works as expected, we&apos;ll read this response in Python2:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;python&apos;&gt;&amp;gt;&amp;gt;&amp;gt; import pickle
&amp;gt;&amp;gt;&amp;gt; with open(&amp;#039;/tmp/word.pickle&amp;#039;) as f:
...     pickle.load(f)
...
&amp;#039;Howdy, Python!&amp;#039;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. If you need a time-proved serialization library, check out the CL-Store! To extend it, just read the &lt;a href=&quot;https://common-lisp.net/project/cl-store/docs/cl-store.html&quot;&gt;docs&lt;/a&gt;.&lt;/p&gt;
</description>
            <pubDate>Sat, 13 Jun 2020 23:53:16 +0300</pubDate>
        </item>
        <item>
            <title>sblint</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0097-sblint.html</link>
            <description>&lt;p&gt;Today I want to review not a library but a tool. &lt;code&gt;SBLint&lt;/code&gt; is a program, which can be run from the command-line. It loads your lisp code and outputs all warnings and notes from SBCL compiler.&lt;/p&gt;
&lt;p&gt;I must admit, that SBLint&apos;s output is very readable. You&apos;ll see where you left unused variables or called a function with wrong parameters.&lt;/p&gt;
&lt;p&gt;To show you an example, I&apos;ve added this bad code to one of my libraries:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(declaim (ftype (function (fixnum fixnum)
                          fixnum)
                foo))
(defun foo (a b)
  (+ a 10))


(defun bar ()
  (foo))


(defun blah ()
  (foo 2
       3.14))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code is full of problems :) Let&apos;s see how SBLint will highlight them!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[art@poftheday] sblint
src/appenders.lisp:41:0: style-warning: \
    The variable B is defined but never used.
src/appenders.lisp:46:2: simple-warning: \
    The function FOO is called with zero arguments, but wants exactly two.
src/appenders.lisp:50:2: type-warning: \
    Constant 3.14 conflicts with its asserted type FIXNUM.
WARNING: Compilation failed in a system &amp;quot;log4cl-extras&amp;quot;.

# But return code is still SUCCESS:
[art@poftheday] echo $?
0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, all errors are caught. However, &lt;code&gt;SBLint&lt;/code&gt; itself exited with 0 exit code. Because of this, we can&apos;t add it into our CI pipeline.&lt;/p&gt;
&lt;p&gt;I consider this is a bug and will made a pull-request to fix it. Hopefully, the current maintainer will merge it soon:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cxxxr/sblint/pull/19&quot;&gt;https://github.com/cxxxr/sblint/pull/19&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Fri, 12 Jun 2020 23:43:40 +0300</pubDate>
        </item>
        <item>
            <title>cl-reddit</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0096-cl-reddit.html</link>
            <description>&lt;p&gt;This is an API wrapper for Reddit.&lt;/p&gt;
&lt;p&gt;Today I found &lt;a href=&quot;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&quot;&gt;an interesting thread from SpaceX&lt;/a&gt;, where it&apos;s software developers answer the questions. I wondered if there was a discussion around Lisp in the Space?&lt;/p&gt;
&lt;p&gt;But this post has about 8000 comments and I didn&apos;t found a search in a single post&apos;s comments on the Reddit. So, I decided to use &lt;code&gt;cl-reddit&lt;/code&gt; to fetch all post comments and to search through them a &quot;lisp&quot; term.&lt;/p&gt;
&lt;p&gt;Here is how you can connect to the Reddit and list of your subreddits:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *user*
             (cl-reddit:api-login
              :username &amp;quot;svetlyak40wt&amp;quot;
              :password *password*))

;; This is how we can retrieve a list of my subreddits:

POFTHEDAY&amp;gt; (mapcar #&amp;#039;cl-reddit:subreddit-title
                   (cl-reddit::get-reddits-mine *user*))
(&amp;quot;programming&amp;quot; &amp;quot;Lisp Advocates&amp;quot; &amp;quot;Lisp&amp;quot; &amp;quot;Scheme Programming Language articles&amp;quot;
 &amp;quot;M-x emacs-reddit&amp;quot; &amp;quot;Web Startups&amp;quot; &amp;quot;Common Lisp&amp;quot; &amp;quot;Filmmakers&amp;quot; &amp;quot;coding&amp;quot;
 &amp;quot;Github: social coding&amp;quot; &amp;quot;EarthPorn: Amazing images of light and landscape&amp;quot;
 &amp;quot;LISP ja&amp;quot; &amp;quot;Learn Lisp&amp;quot; &amp;quot;Startup Accelerators&amp;quot; &amp;quot;defunkydrummer&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot;
 &amp;quot;Steel Bank Common Lisp&amp;quot;
 &amp;quot;(find-if (alexandria:conjoin #&amp;#039;funny-p #&amp;#039;about-lisp-p) *reddit*)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But we want to run a search in the post comments, right?&lt;/p&gt;
&lt;p&gt;Then we need to extract post id from this link:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&quot;&gt;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;and to fetch comments tree using &lt;code&gt;cl-reddit&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-reddit::get-comments &amp;quot;gxb7j1&amp;quot; *user*)

(#&amp;lt;CL-REDDIT:COMMENT {1002009693}&amp;gt; #&amp;lt;CL-REDDIT:COMMENT {10020098F3}&amp;gt;
 #&amp;lt;CL-REDDIT:COMMENT {1002016BF3}&amp;gt; #&amp;lt;CL-REDDIT:COMMENT {1002016CB3}&amp;gt;
 ...
 #&amp;lt;CL-REDDIT:COMMENT {1002016D73}&amp;gt; #&amp;lt;CL-REDDIT:MORE {1002016E33}&amp;gt;)

POFTHEDAY&amp;gt; (length *)
151&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Well, we received 151 comments, but real comments count is about 7.7k. This is because other items either replies or &lt;code&gt;CL-REDDIT:MORE&lt;/code&gt; objects which contain ids of the replies:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;&apos;&gt;POFTHEDAY&amp;gt; (defparameter *comments*
              (cl-reddit::get-comments &amp;quot;gxb7j1&amp;quot; *user*))

POFTHEDAY&amp;gt; (rutils:last-elt *comments*)
#&amp;lt;CL-REDDIT:MORE {1002016E33}&amp;gt;

POFTHEDAY&amp;gt; (cl-reddit:more-children *)
(&amp;quot;ft35r7m&amp;quot; &amp;quot;ft0rpxi&amp;quot; &amp;quot;ft0jn61&amp;quot; &amp;quot;ft34002&amp;quot; &amp;quot;ft4b6z4&amp;quot;
 ...
 &amp;quot;ft0pado&amp;quot; ...)

POFTHEDAY&amp;gt; (cl-reddit:comment-replies
               (first *comments*))
(#&amp;lt;CL-REDDIT:MORE {1003607093}&amp;gt;)

POFTHEDAY&amp;gt; (cl-reddit:comment-replies
               (second *comments*))
(#&amp;lt;CL-REDDIT:COMMENT {1007607293}&amp;gt;)

POFTHEDAY&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We need to write a comment walker which &lt;code&gt;cl-reddit&lt;/code&gt; does not provide.&lt;/p&gt;
&lt;p&gt;This walker will expand all &lt;code&gt;MORE&lt;/code&gt; items and collect comments into the flat list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((post-id &amp;quot;gxb7j1&amp;quot;))
             (uiop:while-collecting (collect)
               (labels ((visit (item)
                          (etypecase item
                            (cl-reddit:comment
                             (collect item)
                             (mapc #&amp;#039;visit
                                   (cl-reddit:comment-replies
                                    item)))
                            (cl-reddit:more
                             (expand-more item))))
                        (expand-more (more)
                          (loop for id in (cl-reddit:more-children more)
                                for comments = (cl-reddit::get-comments
                                                post-id
                                                *user*
                                                :comment id)
                                do (mapc #&amp;#039;visit
                                         comments))))
                 (mapcar #&amp;#039;visit
                         (cl-reddit::get-comments post-id
                                                  *user*)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When I started this code the first time, it broke my Lisp. A quick investigation showed a resource leak. This library uses &lt;a href=&quot;https://edicl.github.io/drakma/&quot;&gt;Drakma&lt;/a&gt; for data fetching and instead of receiving response bodies, request a stream.&lt;/p&gt;
&lt;p&gt;Drakma&apos;s documentation says, that you might need to close the stream. If you don&apos;t - a connection to the server remains opene.&lt;/p&gt;
&lt;p&gt;Seems, the library&apos;s author never used it for making thousands of requests.&lt;/p&gt;
&lt;p&gt;I&apos;ve fixed this leak, but comments fetching still was too slow - about 2 comments per second. This is because &lt;code&gt;MORE&lt;/code&gt; item contains comment ids and I have to fetch them individually one by one.&lt;/p&gt;
&lt;p&gt;I tried to parallelize the fetching process using lparallel, reviewed two days ago:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *all-comments*
             (let ((post-id &amp;quot;gxb7j1&amp;quot;)
                 (counter 0))
               (uiop:while-collecting (collect)
                 (labels ((visit (item)
                            (etypecase item
                              (cl-reddit:comment
                               (collect item)
                               (incf counter)
                               (when (zerop (mod counter 10))
                                 (log:info &amp;quot;~A comments collected&amp;quot;
                                           counter))
                               (mapc #&amp;#039;visit (cl-reddit:comment-replies item)))
                              (cl-reddit:more
                               (expand-more item))))
                          (expand-more (more)
                            (log:info &amp;quot;Expanding&amp;quot; more)
                            (loop with more-ids = (cl-reddit:more-children more)
                                  with replies = (lparallel:pmapcar
                                                  (lambda (id)
                                                    (cl-reddit::get-comments
                                                     post-id
                                                     *user*
                                                     :comment id))
                                                  more-ids)
                                  for comments in replies
                                  do (lparallel:pmapc #&amp;#039;visit comments))))
                   (lparallel:pmapc #&amp;#039;visit
                           (cl-reddit::get-comments post-id
                                                    *user*))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But encountered these strange errors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;The condition Socket error in &amp;quot;connect&amp;quot;: EINTR (Interrupted system call) occurred with errno: 0.

Condition USOCKET:TIMEOUT-ERROR was signalled.
   [Condition of type USOCKET:TIMEOUT-ERROR]

Restarts:
 0: [TRANSFER-ERROR] Transfer this error to a dependent thread, if one exists.
 1: [KILL-ERRORS] Kill errors in workers (remove debugger instances).
 2: [ABORT] abort thread (#&amp;lt;THREAD &amp;quot;lparallel&amp;quot; RUNNING {10071B3DE3}&amp;gt;)

Backtrace:
 0: (USOCKET::HANDLE-CONDITION #&amp;lt;SB-EXT:TIMEOUT {10059E7C53}&amp;gt; #&amp;lt;USOCKET:STREAM-USOCKET {100871AB43}&amp;gt; &amp;quot;www.reddit.com&amp;quot;)
 1: (SB-KERNEL::%SIGNAL #&amp;lt;SB-EXT:TIMEOUT {10059E7C53}&amp;gt;)
 2: (ERROR SB-EXT:TIMEOUT)
 3: (USOCKET:SOCKET-CONNECT &amp;quot;www.reddit.com&amp;quot; 80 :PROTOCOL :STREAM :ELEMENT-TYPE FLEXI-STREAMS:OCTET :TIMEOUT 20 :DEADLINE NIL :NODELAY :IF-SUPPORTED :LOCAL-HOST NIL :LOCAL-PORT NIL)
 4: (DRAKMA:HTTP-REQUEST #&amp;lt;PURI:URI http://www.reddit.com/comments/gxb7j1.json?comment=ft3odzl&amp;gt; :METHOD :GET :USER-AGENT &amp;quot;cl-reddit/0.2 (common lisp api wrapper)&amp;quot; :COOKIE-JAR #&amp;lt;DRAKMA:COOKIE-JAR (with 5 c..
 5: (CL-REDDIT::GET-JSON &amp;quot;http://www.reddit.com/comments/gxb7j1.json?comment=ft3odzl&amp;quot; #&amp;lt;CL-REDDIT:USER {10079B9973}&amp;gt;)
 6: (CL-REDDIT:GET-COMMENTS &amp;quot;gxb7j1&amp;quot; #&amp;lt;CL-REDDIT:USER {10079B9973}&amp;gt; :ARTICLE NIL :COMMENT &amp;quot;ft3odzl&amp;quot; :CONTEXT NIL :DEPTH NIL :LIMIT NIL :SORT NIL :THREADED NIL :SHOWMORE NIL)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tried to switch to the Dexador instead of Drakma, but found another bug - it is not able to work in multiple threads:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fukamachi/dexador/issues/88&quot;&gt;https://github.com/fukamachi/dexador/issues/88&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So, we&apos;ll never know if SpaceX developers are using Lisp in their space ships :)&lt;/p&gt;
</description>
            <pubDate>Thu, 11 Jun 2020 23:45:15 +0300</pubDate>
        </item>
        <item>
            <title>cl-gearman</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0095-cl-gearman.html</link>
            <description>&lt;p&gt;Yesterday, we &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0094-lfarm.html&quot;&gt;talked about&lt;/a&gt; distributing jobs across a cluster using &lt;code&gt;lfarm&lt;/code&gt;. &lt;code&gt;lfarm&lt;/code&gt; is not well suited to environments where worker hosts can go down and return back later.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gearman.org/&quot;&gt;Gearman&lt;/a&gt; is the RPC server. Multiple workers can connect to this server and advertise which functions they are supporting. A client can call these functions and receive a result.&lt;/p&gt;
&lt;p&gt;Here is the diagram showing how does it work in the common case:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0095/gearman-cluster.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A cool feature of Gearman is its language independence. Workers can be written in any language. This means that in your distributed system some functions can be written in Lisp, others in Python or even in Bash and some UNIX tools.&lt;/p&gt;
&lt;p&gt;Now we&apos;ll see how to write a simple worker in Common Lisp and call it. But first, let&apos;s start Gearman server in the Docker container:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[art@poftheday:~]% docker run --rm -p 4730:4730 artefactual/gearmand:1.1.19.1-alpine
Unable to find image &amp;#039;artefactual/gearmand:1.1.19.1-alpine&amp;#039; locally
1.1.19.1-alpine: Pulling from artefactual/gearmand
cbdbe7a5bc2a: Pull complete
33291983401c: Pull complete
b4a2ffd9f406: Pull complete
c5f0c79c81bd: Pull complete
c3b95f315fd4: Pull complete
e8fb3c47a5c3: Pull complete
Digest: sha256:585921f3509b86a9e78aac6c3512c894e0f0a8e0497d194483bafc5ebc275edc
Status: Downloaded newer image for artefactual/gearmand:1.1.19.1-alpine
   INFO 2020-06-10 13:34:35.722249 [  main ] Initializing Gear on port 4730 with SSL: false
   INFO 2020-06-10 13:34:35.000000 [  main ] Starting up with pid 1, verbose is set to INFO
   INFO 2020-06-10 13:34:35.000000 [  main ] Listening on 0.0.0.0:4730 (9)
   INFO 2020-06-10 13:34:35.000000 [  main ] Adding event for listening socket (9)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, we need to start a simple worker which supports two functions. It can reverse any string and report about it&apos;s Lisp implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-gearman:with-worker (worker &amp;quot;localhost:4730&amp;quot;)
             (cl-gearman:add-ability worker &amp;quot;get-implementation&amp;quot;
                                     (lambda (arg job)
                                       (declare (ignorable arg job))
                                       (format nil &amp;quot;~A ~A&amp;quot;
                                               (lisp-implementation-type)
                                               (lisp-implementation-version))))
             (cl-gearman:add-ability worker &amp;quot;reverse&amp;quot;
                                     (lambda (arg job)
                                       (declare (ignorable job))
                                       (reverse arg)))
             (loop (cl-gearman:work worker)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is how we can call these functions from the console:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[art@poftheday:~]% echo &amp;#039;Hello Lisp World!&amp;#039; | gearman -f reverse
!dlroW psiL olleH

[art@poftheday:~]% echo &amp;#039;&amp;#039; | gearman -f get-implementation
SBCL 2.0.2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This way you can communicate with the Lisp from the outer world.&lt;/p&gt;
&lt;p&gt;If we want to call these functions from other Lisp program, then we can do it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;OTHER-LISP&amp;gt; (cl-gearman:with-client (client &amp;quot;localhost:4730&amp;quot;)
              (format t &amp;quot;~A&amp;quot;
                      (cl-gearman:submit-job client &amp;quot;reverse&amp;quot;
                                             :arg &amp;quot;Hello Lisp World!&amp;quot;)))
!dlroW psiL olleH

OTHER-LISP&amp;gt; (cl-gearman:with-client (client &amp;quot;localhost:4730&amp;quot;)
              (format t &amp;quot;~A&amp;quot;
                      (cl-gearman:submit-job client &amp;quot;get-implementation&amp;quot;)))
SBCL 2.0.2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gearman uses a very simple protocol. Every function accepts only one string as its argument. If you want to pass something complex, you&apos;ll need to use some sort of serialization.&lt;/p&gt;
&lt;p&gt;For example, here is how I use &lt;code&gt;cl-store&lt;/code&gt; and &lt;code&gt;base64&lt;/code&gt; to pass lisp data-structures between a worker and a client in Ultralisp.org:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ultralisp/ultralisp/blob/f52411bd89dc5b0bcb6701e4ba0712dd5aee128b/src/rpc/core.lisp#L23-L47&quot;&gt;https://github.com/ultralisp/ultralisp/blob/f52411bd89dc5b0bcb6701e4ba0712dd5aee128b/src/rpc/core.lisp#L23-L47&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;That is it for today. Play with both &lt;code&gt;lfarm&lt;/code&gt; and &lt;code&gt;cl-gearman&lt;/code&gt; to decide which one is better suited for your task.&lt;/p&gt;
</description>
            <pubDate>Wed, 10 Jun 2020 21:28:59 +0300</pubDate>
        </item>
        <item>
            <title>lfarm</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0094-lfarm.html</link>
            <description>&lt;p&gt;This library is similar to Python&apos;s multiprocessing which is also &lt;a href=&quot;https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.connection&quot;&gt;able to run processes on different hosts&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Use &lt;code&gt;lfarm&lt;/code&gt; when you need to run jobs on the cluster.&lt;/p&gt;
&lt;p&gt;The cool &lt;code&gt;lfarm&lt;/code&gt;&apos;s feature is the ability to run jobs on workers, running on different Common Lisp implementation.&lt;/p&gt;
&lt;p&gt;To demonstrate how it works, I started a LispWorks Personal edition on my laptop and SBCL with ClozureCL in the Docker containers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(ql:quickload :lfarm-server)

;; This how I started it on LispWorks
(lfarm-server:start-server &amp;quot;127.0.0.1&amp;quot; 10003)

;; inside the Docker:
(lfarm-server:start-server &amp;quot;0.0.0.0&amp;quot; 10000)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After that, I created a workers pool in my SBCL REPL and called &lt;code&gt;broadcast-task&lt;/code&gt; to run a function on every worker:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (setf lfarm:*kernel* (lfarm:make-kernel &amp;#039;((&amp;quot;127.0.0.1&amp;quot; 10001)
                                                     (&amp;quot;127.0.0.1&amp;quot; 10002)
                                                     (&amp;quot;127.0.0.1&amp;quot; 10003))))
#&amp;lt;LFARM-CLIENT.KERNEL:KERNEL :WORKER-COUNT 3 {1004E7C7C3}&amp;gt;

POFTHEDAY&amp;gt; (lfarm:broadcast-task
            (lambda ()
              (list :lisp (lisp-implementation-type)
                    :lisp-version (lisp-implementation-version)
                    :system (string-trim
                             (list #\Newline #\Space)
                             (with-output-to-string (s)
                               (uiop:run-program &amp;quot;uname -s -m -n&amp;quot;
                                                 :output s))))))
#((:LISP &amp;quot;LispWorks Personal Edition&amp;quot;
   :LISP-VERSION &amp;quot;7.1.2&amp;quot;
   :SYSTEM &amp;quot;Darwin lispbook x86_64&amp;quot;)
  (:LISP &amp;quot;SBCL&amp;quot;
   :LISP-VERSION &amp;quot;1.5.6&amp;quot;
   :SYSTEM &amp;quot;Linux 5d4cc1b96f7e x86_64&amp;quot;)
  (:LISP &amp;quot;Clozure Common Lisp&amp;quot;
   :LISP-VERSION &amp;quot;Version 1.11.5/v1.11.5  (LinuxX8664)&amp;quot;
   :SYSTEM &amp;quot;Linux d2c83144fce3 x86_64&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another great feature is API compatibility with &lt;code&gt;lparallel&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/06/0093-lparallel.html&quot;&gt;reviewed yesterday&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I took our yesterday code and modified it to be able to distinguish a machine processed a task:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lfarm:pmapcar
            (lambda (idx)
              (loop for iteration from 1 to 10
                    do (format t &amp;quot;~A task is processing ~A iteration~%&amp;quot;
                               idx iteration)
                       (sleep (random 1.0))
                    finally (return (format nil &amp;quot;~A result processed by ~A&amp;quot;
                                            idx
                                            (lisp-implementation-type)))))
              (alexandria:iota 10))
(&amp;quot;0 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;1 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;2 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;3 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;4 result processed by SBCL&amp;quot;
 &amp;quot;5 result processed by SBCL&amp;quot;
 &amp;quot;6 result processed by SBCL&amp;quot;
 &amp;quot;7 result processed by LispWorks Personal Edition&amp;quot;
 &amp;quot;8 result processed by LispWorks Personal Edition&amp;quot;
 &amp;quot;9 result processed by LispWorks Personal Edition&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The bad news is that &lt;code&gt;lfarm&lt;/code&gt; is not suite well to the cloud environment, where workers can disappear at any time and become available later.&lt;/p&gt;
&lt;p&gt;Some time ago, I tried to use &lt;code&gt;lfarm&lt;/code&gt; in Ultralisp, to run some jobs in separate containers, but found that &lt;code&gt;lfarm&lt;/code&gt; does not like when worker process disconnects.&lt;/p&gt;
&lt;p&gt;For example, if some of the workers aren&apos;t running, &lt;code&gt;make-kernel&lt;/code&gt; will hang forever. Or if some of the workers will go offline, then &lt;code&gt;broadcast-task&lt;/code&gt; also will hang.&lt;/p&gt;
&lt;p&gt;Tomorrow I&apos;ll tell you about another solution which helped me to solve this problem.&lt;/p&gt;
</description>
            <pubDate>Tue, 09 Jun 2020 21:06:00 +0300</pubDate>
        </item>
        <item>
            <title>lparallel</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0093-lparallel.html</link>
            <description>&lt;p&gt;Today I want to tell you about this great library which makes it very easy to speed up your program in an easy way.&lt;/p&gt;
&lt;p&gt;LParallel provides a convenient to use a thread pool. It allows you to run your code on multiple CPUs without bothering with threading et all.&lt;/p&gt;
&lt;p&gt;Here is a quick demo which allows us to run calculations in parallel by changing a call to &lt;code&gt;mapcar&lt;/code&gt; with a call to &lt;code&gt;lparallel:pmapcar&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; First we need to create a pool of 4 workers:
POFTHEDAY&amp;gt; (setf lparallel:*kernel*
                 (lparallel:make-kernel 4))
#&amp;lt;LPARALLEL.KERNEL:KERNEL
   :NAME &amp;quot;lparallel&amp;quot;
   :WORKER-COUNT 4
   :USE-CALLER NIL
   :ALIVE T
   :SPIN-COUNT 2000 {1002FB64D3}&amp;gt;

;; And here is the easiest way to use it:
POFTHEDAY&amp;gt; (lparallel:pmapcar
            (lambda (idx)
              (loop for iteration from 1 to 10
                    do (format t &amp;quot;~A task is processing ~A iteration~%&amp;quot;
                               idx iteration)
                       (sleep (random 1.0))
                    finally (return (format nil &amp;quot;~A worker result&amp;quot;
                                            idx))))
              (alexandria:iota 10))
0 task is processing 1 iteration
3 task is processing 1 iteration
0 task is processing 2 iteration
3 task is processing 2 iteration
3 task is processing 3 iteration
0 task is processing 3 iteration
...
7 task is processing 7 iteration
7 task is processing 8 iteration
7 task is processing 9 iteration
7 task is processing 10 iteration
(&amp;quot;0 worker result&amp;quot; &amp;quot;1 worker result&amp;quot; &amp;quot;2 worker result&amp;quot; &amp;quot;3 worker result&amp;quot;
 &amp;quot;4 worker result&amp;quot; &amp;quot;5 worker result&amp;quot; &amp;quot;6 worker result&amp;quot; &amp;quot;7 worker result&amp;quot;
 &amp;quot;8 worker result&amp;quot; &amp;quot;9 worker result&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A number of workers depend on the reason why do you want to parallelize execution. There are two possible situations:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;you have a CPU intensive tasks and want to use more power;&lt;/li&gt;&lt;li&gt;you have an IO-bound tasks and want to make more operations in   parallel.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;In the first case there is no sense to make more workers than a number of CPU&apos;s on your machine. In the second scenario, the number of workers can be higher.&lt;/p&gt;
&lt;p&gt;There is also a lower-level API for offloading work to workers through channels. In the next example, I pass a function to the pool and then receive the result:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *chan*
             (lparallel:make-channel))

POFTHEDAY&amp;gt; (lparallel:submit-task
            *chan*
            (lambda (param)
              (format t &amp;quot;Processing ~A~%&amp;quot; param)
              (sleep 3)
              (format t &amp;quot;Processing is done~%&amp;quot;)
              :result-of-processing)
            100500)
; No values
Processing 100500
Processing is done
POFTHEDAY&amp;gt; (lparallel:receive-result *chan*)
:RESULT-OF-PROCESSING&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LParallel has more great features like promises, futures and many ways to run jobs in parallel. It is one of the few Common Lisp projects that have excellent documentation. I recommend you to read it:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lparallel.org/&quot;&gt;https://lparallel.org/&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Mon, 08 Jun 2020 19:06:26 +0300</pubDate>
        </item>
        <item>
            <title>lime</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0092-lime.html</link>
            <description>&lt;p&gt;Lime is a standalone SWANK client. It can be used to programmatically connect to the SWANK server without Emacs.&lt;/p&gt;
&lt;p&gt;One useful thing, you might do is to make a command-line client to send a command to your server. One practical task is code hot-reload. Here is an &lt;a href=&quot;https://lispcookbook.github.io/cl-cookbook/web.html#hot-reload&quot;&gt;example&lt;/a&gt; of how to implement it using &lt;a href=&quot;http://quickdocs.org/swank-client/&quot;&gt;another SWANK client&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Example from Lime&apos;s sources shows how to create a REPL connected to the SWANK. However, this example creates a SWANK server in the same process. I think it will be more realistic to connect from one lisp to another.&lt;/p&gt;
&lt;p&gt;So, I modified example to make it connect to the localhost 20100, where we&apos;ll start a separate ClozureCL process with SWANK:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;Clozure Common Lisp Version 1.12 (v1.12) DarwinX8664

For more information about CCL, please see http://ccl.clozure.com.

CCL is free software.  It is distributed under the terms of the Apache
Licence, Version 2.0.
? (ql:quickload :swank)
To load &amp;quot;swank&amp;quot;:
  Load 1 ASDF system:
    swank
; Loading &amp;quot;swank&amp;quot;

? (swank:create-server :port 20100 :dont-close t :style :spawn)
;; Swank started at port: 20100.
20100&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we need a function which will make a connection and provide us with the remote REPL.&lt;/p&gt;
&lt;p&gt;I just removed the code which starts  SWANK in the same process and replaced &lt;code&gt;(uiop:hostname)&lt;/code&gt; with &quot;localhost&quot;, because &lt;code&gt;(uiop:hostname)&lt;/code&gt; didn&apos;t work for me:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun repl ()
             &amp;quot;Start the REPL.&amp;quot;
             (let ((conn (lime:make-connection &amp;quot;localhost&amp;quot;
                                               20100)))
               (lime:connect conn)

               (format t &amp;quot;Swank server running on ~A ~A~%&amp;quot;
                       (lime:connection-implementation-name conn)
                       (lime:connection-implementation-version conn))
               
               (loop
                 ;; Read all events
                 (sleep 0.05)
                 (let ((events (lime:pull-all-events conn)))
                   (loop for event in events do
                     (typecase event
                       (lime:write-string-event
                        (write-string (lime:event-string event)))
                       (lime:debugger-event
                        (write-string &amp;quot;Entered debugger!&amp;quot;))
                       (t
                        t))))
                 ;; Take input
                 (if (lime:connection-reader-waiting-p conn)
                     ;; Read a line to send as standard input
                     (progn
                       (format t &amp;quot;~%Read: &amp;quot;)
                       (let ((input (read-line)))
                         (lime:send-input conn input)))
                     ;; Read regular code
                     (progn
                       (format t &amp;quot;~A&amp;gt; &amp;quot; (lime:connection-package conn))
                       (let ((input (read)))
                         (lime:evaluate conn
                                        (with-standard-io-syntax
                                          (prin1-to-string input)))))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can connect to our ClozureCL process and have a fun!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; We are connecting from SBCL to CCL
POFTHEDAY&amp;gt; (lisp-implementation-type)
&amp;quot;SBCL&amp;quot;
POFTHEDAY&amp;gt; (lisp-implementation-version)
&amp;quot;2.0.2&amp;quot;

POFTHEDAY&amp;gt; (repl)
Swank server running on ccl Version 1.12 (v1.12) DarwinX8664

COMMON-LISP-USER&amp;gt; (lisp-implementation-type)
&amp;quot;Clozure Common Lisp&amp;quot;

COMMON-LISP-USER&amp;gt; (lisp-implementation-version)
&amp;quot;Version 1.12 (v1.12) DarwinX8664&amp;quot;

COMMON-LISP-USER&amp;gt; (+ 1 2)
3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you are going to try &lt;code&gt;Lime&lt;/code&gt; on CCL, use the patched &lt;code&gt;swank-protocol&lt;/code&gt; system with &lt;a href=&quot;https://github.com/eudoxia0/swank-protocol/pull/2&quot;&gt;this fix&lt;/a&gt;. Without the fix Lime will not work because of the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;&amp;lt;INFO&amp;gt; [23:48:47] swank-protocol swank-protocol.lisp (read-message) -
  Read message SWANK-PROTOCOL::RESULT: (:READER-ERROR
                                        &amp;quot;(:emacs-rex (swank-repl:listener-eval #A((7) common-lisp:base-char . \&amp;quot;(+ 1 2)\&amp;quot;)) \&amp;quot;COMMON-LISP-USER\&amp;quot; :repl-thread 5)
&amp;quot;
                                        &amp;quot;Reader error on #&amp;lt;STRING-INPUT-STREAM  :CLOSED #x30200139FB9D&amp;gt;:
reader macro #A used without a rank integer&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I experienced the same error with &lt;a href=&quot;https://github.com/cxxxr/lem&quot;&gt;Lem&lt;/a&gt; editor. And it was fixed with a &lt;a href=&quot;https://github.com/cxxxr/lem/pull/471/files&quot;&gt;similar patch&lt;/a&gt;.&lt;/p&gt;
</description>
            <pubDate>Mon, 08 Jun 2020 00:27:06 +0300</pubDate>
        </item>
        <item>
            <title>defclass-std</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0091-defclass-std.html</link>
            <description>&lt;p&gt;This library provides a shortcut macro to define &lt;code&gt;CLOS&lt;/code&gt; classes. Today I needed to define a class which will store stock candles data. It will keep data in the columns.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;defclass-std&lt;/code&gt; we can define such class like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass-std:defclass/std candles ()
             ((timestamps
               lows highs
               opens closes
               volumes)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will be expand into the &lt;code&gt;defclass&lt;/code&gt; full of accessors, init forms, etc:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defclass candles nil
  ((timestamps :accessor timestamps
               :initarg :timestamps
               :initform nil)
   (lows :accessor lows
         :initarg :lows
         :initform nil)
   (highs :accessor highs
          :initarg :highs
          :initform nil)
   (opens :accessor opens
          :initarg :opens
          :initform nil)
   (closes :accessor closes
           :initarg :closes
           :initform nil)
   (volumes :accessor volumes
            :initarg :volumes
            :initform nil)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what I really want is a class with custom initforms and readers, prefixed by class name.&lt;/p&gt;
&lt;p&gt;Here is the class definition I had before discovered the &lt;code&gt;defclass-std&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defclass candles ()
  ((timestamps :reader candles-timestamps
               :initform (make-time-vector)
               :initarg :timestamps)
   (lows :reader candles-lows
         :initform (make-price-vector)
         :initarg :lows)
   (highs :reader candles-highs
          :initform (make-price-vector)
          :initarg :highs)
   (opens :reader candles-opens
          :initform (make-price-vector)
          :initarg :opens)
   (closes :reader candles-closes
           :initform (make-price-vector)
           :initarg :closes)
   (volumes :reader candles-volumes
            :initform (make-volume-vector)
            :initarg :volumes))
  (:documentation
   &amp;quot;This is stock candles candles.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how &lt;code&gt;defclass-std&lt;/code&gt; can make this definition shorter and &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defclass-std:defclass/std candles ()
  ((timestamps
    :ri :with-prefix
    :std (make-time-vector))
   (volumes
    :ri :with-prefix
    :std (make-volume-vector))
   ;; Columns, having common options
   ;; can be grouped together!
   (lows highs opens closes
    :ri :with-prefix
    :std (make-price-vector)))
  (:documentation
   &amp;quot;This is stock candles storage.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will write &lt;code&gt;:initarg&lt;/code&gt; and &lt;code&gt;:reader&lt;/code&gt; for each slot. Also, slot&apos;s &lt;code&gt;:initform&lt;/code&gt; will have the value, provided after the &lt;code&gt;:std&lt;/code&gt; keyword.&lt;/p&gt;
&lt;p&gt;The syntax can be made even shorter, but such format is not supported yet:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defclass-std:defclass/std candles ()
  ((timestamps
    :std (make-time-vector))
   (volumes
    :std (make-volume-vector))
   (lows highs opens closes
    :std (make-price-vector)))
  (:default-slot-opts :ri :with-prefix)
  (:documentation
   &amp;quot;This is stock candles storage.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This can make class definitions as concise as defstruct.&lt;/p&gt;
</description>
            <pubDate>Sat, 06 Jun 2020 20:58:34 +0300</pubDate>
        </item>
        <item>
            <title>defmain</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0090-defmain.html</link>
            <description>&lt;p&gt;Today I want to tell about my own library for command-line arguments parsing. &lt;code&gt;Defmain&lt;/code&gt; provides a macro for defining the main function.&lt;/p&gt;
&lt;p&gt;All you need is to declare required and optional arguments like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defmain:defmain main
               ((debug &amp;quot;Show traceback instead of short message.&amp;quot;
                       :flag t)
                (log   &amp;quot;Filename to write log to.&amp;quot;)
                (token &amp;quot;GitHub personal access token.&amp;quot;
                       :env-var &amp;quot;TOKEN&amp;quot;)
                &amp;amp;rest repositories)
             &amp;quot;Utility to analyze github forks.&amp;quot;
             
             (format t
                     &amp;quot;Repositories: ~{~S~^, ~}~%~
                      Debug: ~S~%~
                      Log: ~S~%~
                      Token: ~S~%&amp;quot;
                     repositories
                     debug
                     log
                     token))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code expands to a lot of low-level code which uses &lt;a href=&quot;https://twitter.com/didierverna&quot;&gt;@didierverna&lt;/a&gt;&apos;s &lt;code&gt;net.didierverna.clon&lt;/code&gt; for actual arguments parsing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(progn
 (defun main (&amp;amp;rest defmain/defmain::argv)
   (declare (ignorable))
   (let ((defmain/defmain::synopsis
          (net.didierverna.clon:defsynopsis (:postfix &amp;quot;REPOSITORY...&amp;quot;
                                             :make-default nil)
            (defmain/defmain::text :contents &amp;quot;Utility to analyze github forks.&amp;quot;)
            (defmain/defmain::flag :long-name &amp;quot;help&amp;quot; :env-var nil :description
             &amp;quot;Show help on this program.&amp;quot; :short-name &amp;quot;h&amp;quot;)
            (defmain/defmain::flag :long-name &amp;quot;debug&amp;quot; :env-var nil :description
             &amp;quot;Show traceback instead of short message.&amp;quot; :short-name &amp;quot;d&amp;quot;)
            (defmain/defmain::stropt :long-name &amp;quot;log&amp;quot; :env-var nil :description
             &amp;quot;Filename to write log to.&amp;quot; :short-name &amp;quot;l&amp;quot;)
            (defmain/defmain::stropt :long-name &amp;quot;token&amp;quot; :env-var &amp;quot;TOKEN&amp;quot;
             :description &amp;quot;GitHub personal access token.&amp;quot; :short-name &amp;quot;t&amp;quot;)))
         (defmain/defmain::argv
          (or defmain/defmain::argv (uiop/image:command-line-arguments))))
     (change-class defmain/defmain::synopsis &amp;#039;defmain/defmain::cool-synopsis
                   :command &amp;#039;main)
     (net.didierverna.clon:make-context :cmdline
                                        (cons &amp;quot;main&amp;quot; defmain/defmain::argv)
                                        :synopsis defmain/defmain::synopsis))
   (let ((defmain/defmain::%rest-arguments (net.didierverna.clon:remainder)))
     (declare (ignorable defmain/defmain::%rest-arguments))
     (flet ((defmain/defmain::%pop-argument (defmain/defmain::name)
              &amp;quot;This local function is used to pop positional arguments from the command line.&amp;quot;
              (unless defmain/defmain::%rest-arguments
                (check-type defmain/defmain::name symbol)
                (error &amp;#039;defmain/defmain::argument-is-required-error :name
                       defmain/defmain::name))
              (pop defmain/defmain::%rest-arguments)))
       (let ((net.didierverna.clon:help
              (net.didierverna.clon:getopt :long-name &amp;quot;help&amp;quot;))
             (debug (net.didierverna.clon:getopt :long-name &amp;quot;debug&amp;quot;))
             (log (net.didierverna.clon:getopt :long-name &amp;quot;log&amp;quot;))
             (token (net.didierverna.clon:getopt :long-name &amp;quot;token&amp;quot;)))
         (when net.didierverna.clon:help
           (net.didierverna.clon:help)
           (uiop/image:quit 1))
         (handler-bind ((sb-sys:interactive-interrupt
                         (lambda (defmain/defmain::c)
                           (declare (ignorable defmain/defmain::c))
                           (uiop/image:quit 0)))
                        (defmain/defmain::argument-is-required-error
                         (lambda (defmain/defmain::c)
                           (format t &amp;quot;~A~%&amp;quot; defmain/defmain::c)
                           (uiop/image:quit 1)))
                        (error
                         (lambda (condition)
                           (uiop/image:print-condition-backtrace condition
                                                                 :stream
                                                                 *error-output*)
                           (uiop/image:quit 1))))
           (let ((repositories defmain/defmain::%rest-arguments))
             (flet ()
               (setf (logical-pathname-translations &amp;quot;TEMPORARY-FILES&amp;quot;)
                       `((&amp;quot;*.*.*&amp;quot;
                          ,(uiop/package:symbol-call :cl-fad
                                                     &amp;#039;defmain/defmain::get-default-temporary-directory))))
               (uiop/stream:setup-temporary-directory)
               (format t &amp;quot;Repositories: ~{~S~^, ~}~%~
                          Debug: ~S~%~
                          Log: ~S~%~
                          Token: ~S~%&amp;quot;
                       repositories debug log token)
               nil)))))))
 (setf (get &amp;#039;main :arguments) &amp;#039;(debug log token)
       (documentation &amp;#039;main &amp;#039;function) &amp;quot;Utility to analyze github forks.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&apos;s try to call our main function to check how  it processes command-line arguments.&lt;/p&gt;
&lt;p&gt;Defmain calls &lt;code&gt;uiop:quit&lt;/code&gt; at the end of the function on after the printing help message. To suppress this behaviour, I&apos;ll redefine this function to just print to the screen:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun uiop:quit (&amp;amp;optional (code 0))
             (format t &amp;quot;Quit was called with code=~A~%&amp;quot;
                     code))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can pass it different combinations of arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (main)
Repositories: 
Debug: NIL
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: NIL
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;--log&amp;quot; &amp;quot;app.log&amp;quot;&amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: &amp;quot;app.log&amp;quot;
Token: NIL

;; Now we&amp;#039;ll check how it will
;; process environment variable:
POFTHEDAY&amp;gt; (setf (uiop:getenv &amp;quot;TOKEN&amp;quot;)
                 &amp;quot;$ome $ecret 7oken&amp;quot;)

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;--log&amp;quot; &amp;quot;app.log&amp;quot;&amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: &amp;quot;app.log&amp;quot;
Token: &amp;quot;$ome $ecret 7oken&amp;quot;
NIL
POFTHEDAY&amp;gt; (main &amp;quot;--help&amp;quot;)
Usage: main main [-hd] [OPTIONS] REPOSITORY...

Utility to analyze github forks.
  -h, --help                  Show help on this program.
  -d, --debug                 Show traceback instead of short message.
  -l, --log=STR               Filename to write log to.
  -t, --token=STR             GitHub personal access token.
                              Environment: TOKEN
Quit was called with code=1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Defmain&lt;/code&gt; is not in Quicklisp distribution, but you can install it from &lt;a href=&quot;https://ultralisp.org/&quot;&gt;Ultralisp.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are looking to something simpler, you might take a look at &lt;code&gt;unix-opts&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/03/0006-unix-opts.html&quot;&gt;reviewed in the #0006 #poftheday&lt;/a&gt; post.&lt;/p&gt;
</description>
            <pubDate>Fri, 05 Jun 2020 22:24:53 +0300</pubDate>
        </item>
        <item>
            <title>lambda-fiddle</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0089-lambda-fiddle.html</link>
            <description>&lt;p&gt;This library serves a single purpose - to help macro writers to parse lambda lists. In this sense, it is similar to &lt;code&gt;parse-declarations&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0067-parse-declarations.html&quot;&gt;reviewed on 13 May&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The library has a number of functions to extract or remove exact parts of the lambda list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lambda-fiddle:remove-aux-part
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(FOO BAR &amp;amp;KEY BAZ)

POFTHEDAY&amp;gt; (lambda-fiddle:aux-lambda-vars
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(SOMETHING ALTOGETHER)

POFTHEDAY&amp;gt; (lambda-fiddle:extract-all-lambda-vars
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(FOO BAR BAZ SOMETHING ALTOGETHER)

POFTHEDAY&amp;gt; (lambda-fiddle:split-lambda-list
            &amp;#039;(&amp;amp;whole wide world &amp;amp;key roles))
((WORLD) WIDE NIL NIL NIL NIL (ROLES) NIL)

POFTHEDAY&amp;gt; (lambda-fiddle:with-destructured-lambda-list
               (:required req :optional opt)
               &amp;#039;(foo bar &amp;amp;optional baz)
             (list :required req
                   :optional opt))
(:REQUIRED (FOO BAR) :OPTIONAL (BAZ))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It also provides a higher-level macro to extract particular pieces all at once:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lambda-fiddle:with-destructured-lambda-list
               (:required req :optional opt)
               &amp;#039;(foo bar &amp;amp;optional baz)
             (list :required req
                   :optional opt))
(:REQUIRED (FOO BAR) :OPTIONAL (BAZ))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@Shinmera&lt;/a&gt;&apos;s &quot;legit&quot; contains &lt;a href=&quot;https://github.com/Shinmera/legit/blob/f822ac7aa8ed5aec7f2c63b146f790b0410f8502/toolkit.lisp#L31-L45&quot;&gt;a practical example&lt;/a&gt; of the &lt;code&gt;with-destructured-lambda-list&lt;/code&gt; usage.&lt;/p&gt;
&lt;p&gt;This code replaces optional arguments with keywords and adds optional predicates which can be used to check if a keyword argument was provided:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defmacro define-git-wrapper (name &amp;amp;rest argdefs)
  (lambda-fiddle:with-destructured-lambda-list (:required req :optional opt :key key) argdefs
    (let* ((purereq (purify-args req))
           (purekey (purify-args key))
           (pureopt (purify-args opt))
           (augkeys (mapcar (lambda (a)
                              `(,a NIL ,(p-symb a)))
                            (append pureopt purekey))))
      `(defun ,name (,@purereq &amp;amp;key ,@augkeys)
         (declare (ignorable ,@(mapcar #&amp;#039;third augkeys)))
         (run-git
          ,(subseq (string-downcase name) 4)
          ,@(loop for arg in req 
                  when (front-arg-p arg)
                    collect (parse-rargdef arg))
          ,@(loop for arg in opt
                  when (front-arg-p arg)
                    collect (parse-oargdef arg))
          ,@(mapcar #&amp;#039;parse-kargdef key)
          ,@(loop for arg in req
                  unless (front-arg-p arg)
                    collect (parse-rargdef arg))
          ,@(loop for arg in opt
                  unless (front-arg-p arg)
                    collect
                    (parse-oargdef arg)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. If you want to parse lambda lists, use this little helper instead of searching &amp;optional, &amp;rest, &amp;misc, etc by hand.&lt;/p&gt;
</description>
            <pubDate>Thu, 04 Jun 2020 23:51:31 +0300</pubDate>
        </item>
        <item>
            <title>group-by</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0088-group-by.html</link>
            <description>&lt;p&gt;This small utility library implements a really handy facility. It allows you to group items by one or many keys.&lt;/p&gt;
&lt;p&gt;Here is how it works. In the next example we&apos;ll group names by their first letter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (group-by:group-by
            &amp;#039;(&amp;quot;Alice&amp;quot;
              &amp;quot;Bob&amp;quot;
              &amp;quot;Ashley&amp;quot;
              &amp;quot;Katie&amp;quot;
              &amp;quot;Brittany&amp;quot;
              &amp;quot;Jessica&amp;quot;
              &amp;quot;Daniel&amp;quot;
              &amp;quot;Josh&amp;quot;)
            :key (lambda (name)
                   (elt name 0))
            :value #&amp;#039;identity)

((#\A &amp;quot;Alice&amp;quot;
      &amp;quot;Ashley&amp;quot;)
 (#\B &amp;quot;Bob&amp;quot;
      &amp;quot;Brittany&amp;quot;)
 (#\K &amp;quot;Katie&amp;quot;)
 (#\J &amp;quot;Jessica&amp;quot;
      &amp;quot;Josh&amp;quot;)
 (#\D &amp;quot;Daniel&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we are going to group by the first letter and next by the second, we need to use &lt;code&gt;group-by-repeated&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((first-letter (name)
                    (elt name 0))
                  (second-letter (name)
                    (elt name 1)))
             (group-by:group-by-repeated
              &amp;#039;(&amp;quot;Alice&amp;quot;
                &amp;quot;Bob&amp;quot;
                &amp;quot;Ashley&amp;quot;
                &amp;quot;Katie&amp;quot;
                &amp;quot;Brittany&amp;quot;
                &amp;quot;Jessica&amp;quot;
                &amp;quot;Daniel&amp;quot;
                &amp;quot;Josh&amp;quot;)
            :keys (list #&amp;#039;first-letter
                       #&amp;#039;second-letter)))

((#\D (#\a &amp;quot;Daniel&amp;quot;))
 (#\J (#\o &amp;quot;Josh&amp;quot;)
      (#\e &amp;quot;Jessica&amp;quot;))
 (#\K (#\a &amp;quot;Katie&amp;quot;))
 (#\B (#\r &amp;quot;Brittany&amp;quot;)
      (#\o &amp;quot;Bob&amp;quot;))
 (#\A (#\s &amp;quot;Ashley&amp;quot;)
      (#\l &amp;quot;Alice&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library also provides a way to accumulate grouped items into a special object. This could be useful when you don&apos;t have all items right away, but receiving them one by one from some source.&lt;/p&gt;
&lt;p&gt;Here is how it can be used in the simplest case. First, we&apos;ll request names from the user and will be collecting them into a special grouped list data structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((first-letter (name)
                    (elt name 0))
                  (second-letter (name)
                    (elt name 1))
                  (request-name ()
                    (format t &amp;quot;Enter a name: &amp;quot;)
                    (read)))
             (loop with accumulator = (group-by:make-grouped-list
                                       nil
                                       :keys (list #&amp;#039;first-letter
                                                   #&amp;#039;second-letter))
                   for name = (request-name)
                     then (request-name)
                   while name
                   do (group-by:add-item-to-grouping
                       name
                       accumulator)
                   finally (return accumulator)))
Enter a name: &amp;quot;Markus&amp;quot;
Enter a name: &amp;quot;Bob&amp;quot;
Enter a name: &amp;quot;Betty&amp;quot;
Enter a name: &amp;quot;Mery&amp;quot;
Enter a name: &amp;quot;Oleg&amp;quot;
Enter a name: &amp;quot;Marianna&amp;quot;
Enter a name: nil
#&amp;lt;GROUP-BY:GROUPED-LIST {1006D3EC43}&amp;gt;

POFTHEDAY&amp;gt; (defparameter *grouping* *)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At any time we can access the data structure to work with already collected items. Let&apos;s write a recursive function to see what we&apos;ve collected so far:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun print-tree (grouping &amp;amp;optional (depth 0))
             (let ((prefix (make-string depth :initial-element #\Space))
                   (key (group-by:key-value grouping))
                   (items (group-by:items-in-group grouping))
                   (subgroups (group-by:child-groupings grouping)))
               (when key
                 (format t &amp;quot;~A~A~&amp;amp;&amp;quot; prefix key)
                 (incf depth))

               (if subgroups
                   (loop for child in subgroups
                         do (print-tree child depth))
                   (loop for item in items
                         do (format t &amp;quot;~A - ~A~%&amp;quot;
                                    prefix
                                    item)))))

POFTHEDAY&amp;gt; (print-tree *grouping*)
O
 l
  - Oleg
B
 e
  - Betty
 o
  - Bob
M
 e
  - Mery
 a
  - Marianna
  - Markus&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library is powerful enough to have it in your toolbox. Go and group something now!&lt;/p&gt;
</description>
            <pubDate>Wed, 03 Jun 2020 20:44:42 +0300</pubDate>
        </item>
    </channel>
</rss>