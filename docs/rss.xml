<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>conduit-packages</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/09/0179-conduit-packages.html</link>
            <description>&lt;p&gt;This system is pretty old. It does not have its own revision control and &lt;a href=&quot;http://beta.quicklisp.org/orphans/tfeb/conduit-packages.lisp&quot;&gt;is hosted here&lt;/a&gt;. It provides the replacement for the &lt;code&gt;defpackage&lt;/code&gt; macro. This replacement makes easy to &quot;inherit&quot; your package from another and to replace some symbols with your own.&lt;/p&gt;
&lt;p&gt;For example, &lt;a href=&quot;https://twitter.com/stylewarning&quot;&gt;@stylewarning&lt;/a&gt;&apos;s &lt;code&gt;cl-generic-arithmetic&lt;/code&gt; uses it to redefine some functions from &lt;code&gt;cl&lt;/code&gt; package. It defines a new package which uses &lt;code&gt;cl&lt;/code&gt; and reexports all symbols except some which are defined in by the &lt;code&gt;cl-generic-arithmetic&lt;/code&gt; as generic functions.&lt;/p&gt;
&lt;p&gt;Let&apos;s repeat this to make &lt;code&gt;+&lt;/code&gt; a function generic!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (org.tfeb.clc:defpackage cl-generic
             (:extends/excluding #:cl
                                 #:+)
             (:export #:+))

;; For simplicity, I&amp;#039;ll define this operation as
;; binary. But for real implementation it should
;; support variadic arguments.
POFTHEDAY&amp;gt; (defgeneric cl-generic:+ (left right)
             (:method ((left number) (right number))
               (cl:+ left right))
             (:method ((left string) (right string))
               (concatenate &amp;#039;string left right))
             (:method ((left string) (right number))
               (format nil &amp;quot;~A~A&amp;quot; left right)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can define another package which will use this generic function. Note, I&apos;ll just &lt;code&gt;:use&lt;/code&gt; this new package instead of standard &lt;code&gt;:cl&lt;/code&gt; package:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defpackage foo
             (:use :cl-generic))

POFTHEDAY&amp;gt; (in-package foo)

FOO&amp;gt; (+ 1 2)
3

FOO&amp;gt; (+ &amp;quot;Hello &amp;quot; &amp;quot;World!&amp;quot;)
&amp;quot;Hello World!&amp;quot;

;; Other function are standard, becase they are inherited
;; from the standard package:
FOO&amp;gt; (- 5 3)
2

FOO&amp;gt; (- &amp;quot;Hello &amp;quot; &amp;quot;World!&amp;quot;)
; Debugger entered on #&amp;lt;TYPE-ERROR expected-type: NUMBER datum: &amp;quot;Hello &amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By the way, you can get the same effect by using &lt;code&gt;uiop:define-package&lt;/code&gt;. But it will be a little bit wordy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (uiop:define-package cl-generic2
             (:use #:cl)
             (:shadow #:+)
             (:reexport #:cl))
#&amp;lt;PACKAGE &amp;quot;CL-GENERIC2&amp;quot;&amp;gt;

POFTHEDAY&amp;gt; (defgeneric cl-generic2:+ (left right)
             (:method ((left number) (right number))
               (cl:+ left right))
             (:method ((left string) (right string))
               (concatenate &amp;#039;string left right))
             (:method ((left string) (right number))
               (format nil &amp;quot;~A~A&amp;quot; left right)))

POFTHEDAY&amp;gt; (defpackage foo2
             (:use :cl-generic2))

POFTHEDAY&amp;gt; (in-package foo)

POFTHEDAY&amp;gt; (in-package foo2)

FOO2&amp;gt; (+ 1 2)
3

FOO2&amp;gt; (+ &amp;quot;Hello &amp;quot; &amp;quot;World!&amp;quot;)
&amp;quot;Hello World!&amp;quot;

FOO2&amp;gt; (- 5 3)
2

FOO2&amp;gt; (- &amp;quot;Hello &amp;quot; &amp;quot;World!&amp;quot;)
; Debugger entered on #&amp;lt;TYPE-ERROR expected-type: NUMBER datum: &amp;quot;Hello &amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Probably I missed some of the &lt;code&gt;conduit-packages&lt;/code&gt; features. Please, read its &lt;a href=&quot;http://beta.quicklisp.org/orphans/tfeb/conduit-packages.lisp&quot;&gt;sources&lt;/a&gt; and tell me if you will find something interesting!&lt;/p&gt;
</description>
            <pubDate>Fri, 04 Sep 2020 20:52:13 +0300</pubDate>
        </item>
        <item>
            <title>scriba</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/09/0178-scriba.html</link>
            <description>&lt;p&gt;The previous post was about &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/09/0177-geneva.html&quot;&gt;Geneva&lt;/a&gt; - the CL documentation system. &lt;a href=&quot;https://twitter.com/VPostnicov&quot;&gt;Vasily Postnicov&lt;/a&gt; &lt;a href=&quot;https://twitter.com/VPostnicov/status/1301009915092365312&quot;&gt;mentioned on twitter&lt;/a&gt; another Lisp documentation tool called Codex.&lt;/p&gt;
&lt;p&gt;Codex is based on &lt;code&gt;Scriba&lt;/code&gt; markup and today we&apos;ll look at how to use it.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (scriba.parser:parse-string &amp;quot;Blah minor&amp;quot;)
(:DOCUMENT &amp;quot;Blah minor&amp;quot;)


POFTHEDAY&amp;gt; (scriba.parser:parse-string &amp;quot;@b(Blah) minor&amp;quot;)
(:DOCUMENT (:NAME &amp;quot;b&amp;quot; :ATTRS NIL :BODY (&amp;quot;Blah&amp;quot;)) &amp;quot; minor&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But this is an internal AST representation. &lt;code&gt;Scriba&lt;/code&gt; is based on other Fernando Boretti&apos;s library - &lt;code&gt;CommonDoc&lt;/code&gt; and they should be used in tandem:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (make-instance &amp;#039;scriba:scriba)
#&amp;lt;SCRIBA:SCRIBA {10023FD193}&amp;gt;

POFTHEDAY&amp;gt; (defparameter *format* (make-instance &amp;#039;scriba:scriba))
*FORMAT*

POFTHEDAY&amp;gt; (common-doc.format:parse-document *format* &amp;quot;@b(Hello) @i(World)!&amp;quot;)
#&amp;lt;COMMON-DOC:DOCUMENT &amp;quot;&amp;quot;&amp;gt;

POFTHEDAY&amp;gt; (common-doc.format:emit-to-string *format* *)
&amp;quot;@title()

@b(Hello)@i(World)!
&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also another CL library, also made by Fernando - &lt;code&gt;pandocl&lt;/code&gt;. It can be used when you need to convert the document into &lt;code&gt;HTML&lt;/code&gt; or another format.&lt;/p&gt;
&lt;p&gt;For example, here how we can render our hello world into the HTML:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (pandocl:parse-string
            &amp;quot;@b(Hello) @i(World)!&amp;quot;
            :scriba)
#&amp;lt;COMMON-DOC:DOCUMENT &amp;quot;&amp;quot;&amp;gt;

POFTHEDAY&amp;gt; (pandocl:emit  * &amp;quot;hello.html&amp;quot;)
#&amp;lt;COMMON-DOC:DOCUMENT &amp;quot;&amp;quot;&amp;gt;

POFTHEDAY&amp;gt; (alexandria:read-file-into-string &amp;quot;hello.html&amp;quot;)
&amp;quot;&amp;lt;!DOCTYPE html&amp;gt;
 &amp;lt;html&amp;gt;
   &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
   &amp;lt;body&amp;gt;
     &amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt;&amp;lt;i&amp;gt;World&amp;lt;/i&amp;gt;!
   &amp;lt;/body&amp;gt;
 &amp;lt;/html&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what I&apos;m really interested in is Scriba&apos;s extensibility. The text consists of inline and multiline blocks. Each block has a name and optional attributes.&lt;/p&gt;
&lt;p&gt;Let&apos;s pretend, everyday we are writing texts, mentioning different twitter users and want a shorthand syntax for them! When rendering into HTML, these tags should be transformed into the link and real user name.&lt;/p&gt;
&lt;p&gt;Naive approach does not work, because we did nothing to extend the protocol:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (common-doc.format:parse-document *format*
                                             &amp;quot;Hello @twitter(bob)!&amp;quot;)
; Debugger entered on #&amp;lt;SIMPLE-ERROR &amp;quot;No node with name twitter&amp;quot; {100324FCC3}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But I found the way to do this. Thanks to the CLOS!&lt;/p&gt;
&lt;p&gt;What we need, is to define the &lt;code&gt;twitter&lt;/code&gt; node, using this &lt;code&gt;CommonDoc&lt;/code&gt; macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (common-doc:define-node twitter (common-doc:markup)
                                   ()
                                   (:tag-name &amp;quot;twitter&amp;quot;))

POFTHEDAY&amp;gt; (common-html.emitter::define-emitter (node twitter)
             (let* ((username (common-doc:text (first (common-doc:children node))))
                    (url (format nil &amp;quot;https://twitter/~A&amp;quot; username))
                    (name (format nil &amp;quot;@~A&amp;quot; username)))
               (common-html.emitter::with-tag (&amp;quot;a&amp;quot; node :attributes `((&amp;quot;href&amp;quot; . ,url)))
                                              (write-string name
                                                            common-html.emitter::*output-stream*))))

POFTHEDAY&amp;gt; (common-doc.format:parse-document *format* &amp;quot;Hello @twitter(bob)!&amp;quot;)
#&amp;lt;COMMON-DOC:DOCUMENT &amp;quot;&amp;quot;&amp;gt;

POFTHEDAY&amp;gt; (pandocl:emit  * &amp;quot;hello.html&amp;quot;)
#&amp;lt;COMMON-DOC:DOCUMENT &amp;quot;&amp;quot;&amp;gt;

POFTHEDAY&amp;gt; (alexandria:read-file-into-string &amp;quot;hello.html&amp;quot;)
&amp;quot;&amp;lt;!DOCTYPE html&amp;gt;
 &amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
       Hello &amp;lt;a href=\&amp;quot;https://twitter/bob\&amp;quot;&amp;gt;@bob&amp;lt;/a&amp;gt;!
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, I&apos;ve used a bunch of internal symbols, to extend &lt;code&gt;Common HTML&lt;/code&gt; and make it work the way I need. Probably it will be a good idea to make this API public.&lt;/p&gt;
&lt;p&gt;Anyway, I like Scriba and Common Doc because it was relatively easy to hack and do what I need.&lt;/p&gt;
</description>
            <pubDate>Thu, 03 Sep 2020 21:05:10 +0300</pubDate>
        </item>
        <item>
            <title>geneva</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/09/0177-geneva.html</link>
            <description>&lt;p&gt;This is yet another project by Max Rottenkolber (&lt;a href=&quot;https://twitter.com/eugeneia_&quot;&gt;@eugeneia_&lt;/a&gt;). Geneva is the documentation system. It includes a few subsystems:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;the core;&lt;/li&gt;&lt;li&gt;the markup language;&lt;/li&gt;&lt;li&gt;renderers for HTML, LaTeX and plain text.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Geneva separates a document structure from its representation.&lt;/p&gt;
&lt;p&gt;Core package provides the way to define a document&apos;s structure using calls to Lisp functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (geneva:make-document
            (list
             (geneva:make-section (list &amp;quot;First section&amp;quot;)
                (list
                 (geneva:make-paragraph (list &amp;quot;Foo bar&amp;quot;))
                 (geneva:make-paragraph (list &amp;quot;Blah minor&amp;quot;))))
             (geneva:make-section (list &amp;quot;Second section&amp;quot;)
                 (list
                  (geneva:make-paragraph (list (geneva:make-bold &amp;quot;Hello World!&amp;quot;)))))))
((:SECTION (&amp;quot;First section&amp;quot;)
  ((:PARAGRAPH (&amp;quot;Foo bar&amp;quot;))
   (:PARAGRAPH (&amp;quot;Blah minor&amp;quot;))))
 (:SECTION (&amp;quot;Second section&amp;quot;)
  ((:PARAGRAPH ((:BOLD &amp;quot;Hello World!&amp;quot;))))))

POFTHEDAY&amp;gt; (geneva.html:render-html * :index-p nil)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, the document is a bunch of Lisp lists. It easily can be rendered into the HTML:&lt;/p&gt;
&lt;h4&gt;Code&lt;/h4&gt;&lt;pre&gt;&lt;code class=&apos;html :render&apos;&gt;&amp;lt;SECTION&amp;gt;
  &amp;lt;HEADER&amp;gt;
    &amp;lt;A NAME=&amp;quot;section-1&amp;quot;&amp;gt;
      &amp;lt;H1&amp;gt;&amp;lt;SPAN CLASS=&amp;quot;geneva-index&amp;quot;&amp;gt;1&amp;lt;/SPAN&amp;gt; First section&amp;lt;/H1&amp;gt;
    &amp;lt;/A&amp;gt;
  &amp;lt;/HEADER&amp;gt;
  &amp;lt;P&amp;gt;Foo bar&amp;lt;/P&amp;gt;
  &amp;lt;P&amp;gt;Blah minor&amp;lt;/P&amp;gt;
&amp;lt;/SECTION&amp;gt;

&amp;lt;SECTION&amp;gt;
  &amp;lt;HEADER&amp;gt;
    &amp;lt;A NAME=&amp;quot;section-2&amp;quot;&amp;gt;
      &amp;lt;H1&amp;gt;&amp;lt;SPAN CLASS=&amp;quot;geneva-index&amp;quot;&amp;gt;2&amp;lt;/SPAN&amp;gt; Second section&amp;lt;/H1&amp;gt;
    &amp;lt;/A&amp;gt;
  &amp;lt;/HEADER&amp;gt;
  &amp;lt;P&amp;gt;&amp;lt;B&amp;gt;Hello World!&amp;lt;/B&amp;gt;&amp;lt;/P&amp;gt;
&amp;lt;/SECTION&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;Result&lt;/h4&gt;&lt;SECTION&gt;
  &lt;HEADER&gt;
    &lt;A NAME=&quot;section-1&quot;&gt;
      &lt;H1&gt;&lt;SPAN CLASS=&quot;geneva-index&quot;&gt;1&lt;/SPAN&gt; First section&lt;/H1&gt;
    &lt;/A&gt;
  &lt;/HEADER&gt;
  &lt;P&gt;Foo bar&lt;/P&gt;
  &lt;P&gt;Blah minor&lt;/P&gt;
&lt;/SECTION&gt;

&lt;SECTION&gt;
  &lt;HEADER&gt;
    &lt;A NAME=&quot;section-2&quot;&gt;
      &lt;H1&gt;&lt;SPAN CLASS=&quot;geneva-index&quot;&gt;2&lt;/SPAN&gt; Second section&lt;/H1&gt;
    &lt;/A&gt;
  &lt;/HEADER&gt;
  &lt;P&gt;&lt;B&gt;Hello World!&lt;/B&gt;&lt;/P&gt;
&lt;/SECTION&gt;&lt;p&gt;Or you might want to render it into the plain text:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (geneva.plain-text:render-plain-text * :index-p nil)

1 First section

   Foo bar

   Blah minor

2 Second section

   Hello World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Humans usually prefer to use specialized markup languages. Geneva provides MK2 markup language to define a rich text. For example, text from the previous example can be written like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((text &amp;quot;
&amp;lt; First section

  Foo bar

  Blah minor

&amp;gt;

&amp;lt; Second section

  *Hello World!*

&amp;gt;&amp;quot;))
             (with-input-from-string (s text)
               (geneva.mk2:read-mk2 s)))
((:SECTION (&amp;quot;First section&amp;quot;)
  ((:PARAGRAPH (&amp;quot;Foo bar&amp;quot;))
   (:PARAGRAPH (&amp;quot;Blah minor&amp;quot;))))
 (:SECTION (&amp;quot;Second section&amp;quot;)
  ((:PARAGRAPH ((:BOLD &amp;quot;Hello World!&amp;quot;))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a system to process documentation strings into the Geneva document. It can be used to render documentation for your own system. Docstrings can be written in MK2 markup.&lt;/p&gt;
&lt;p&gt;Now we&apos;ll create a test Lisp package and fill it with a variable, function and macro.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defpackage foo
             (:use #:cl)
             (:documentation &amp;quot;This is an example
                              of the package.

                              Documentation can be written in *MK2 format*.

                              And include _rich_ text with links.&amp;quot;))

POFTHEDAY&amp;gt; (defun foo::bar (minor)
             &amp;quot;Makes some tranformation.

              *Arguments*:

              {minor} - an object to transform.&amp;quot;

             ;; do the job
             (values))

POFTHEDAY&amp;gt; (defvar foo::*blah* :blah
             &amp;quot;Switches between two modes: {:blah} and {:minor}&amp;quot;)

POFTHEDAY&amp;gt; (defmacro foo::with-minor (&amp;amp;body body)
             &amp;quot;Runs {body} with {:minor} mode applied.&amp;quot;
             `(let ((foo::*blah* :minor))
                ,@body))

POFTHEDAY&amp;gt; (export &amp;#039;(foo::*blah* foo::bar foo::with-minor)
                   :foo)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can build documentation for this package in two simple steps:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (geneva.cl:api-document :foo)
((:SECTION (&amp;quot;foo (Package)&amp;quot;)
  ((:PARAGRAPH (&amp;quot;This is an example of the package.&amp;quot;))
   (:PARAGRAPH (&amp;quot;Documentation can be written in &amp;quot; (:BOLD &amp;quot;MK2 format&amp;quot;) &amp;quot;.&amp;quot;))
   (:PARAGRAPH (&amp;quot;And include &amp;quot; (:ITALIC &amp;quot;rich&amp;quot;) &amp;quot; text with links.&amp;quot;))
   (:SECTION (&amp;quot;*blah* (Variable)&amp;quot;)
    ((:PARAGRAPH ((:BOLD &amp;quot;Initial Value:&amp;quot;)))
     (:PARAGRAPH ((:FIXED-WIDTH &amp;quot;:BLAH&amp;quot;)))
     (:PARAGRAPH
      (&amp;quot;Switches between two modes: &amp;quot; (:FIXED-WIDTH &amp;quot;:blah&amp;quot;) &amp;quot; and &amp;quot;
       (:FIXED-WIDTH &amp;quot;:minor&amp;quot;)))))
   (:SECTION (&amp;quot;bar (Function)&amp;quot;)
    ((:PARAGRAPH ((:BOLD &amp;quot;Syntax:&amp;quot;)))
     (:PARAGRAPH (&amp;quot;&amp;#x2014; Function: &amp;quot; (:BOLD &amp;quot;bar&amp;quot;) &amp;quot; &amp;quot; (:ITALIC &amp;quot;minor&amp;quot;)))
     (:PARAGRAPH (&amp;quot;Makes some tranformation.&amp;quot;))
     (:PARAGRAPH ((:BOLD &amp;quot;Arguments&amp;quot;) &amp;quot;:&amp;quot;))
     (:PARAGRAPH ((:FIXED-WIDTH &amp;quot;minor&amp;quot;) &amp;quot; - an object to transform.&amp;quot;))))
   (:SECTION (&amp;quot;with-minor (Macro)&amp;quot;)
    ((:PARAGRAPH ((:BOLD &amp;quot;Syntax:&amp;quot;)))
     (:PARAGRAPH
      (&amp;quot;&amp;#x2014; Macro: &amp;quot; (:BOLD &amp;quot;with-minor&amp;quot;) &amp;quot; &amp;quot; (:FIXED-WIDTH &amp;quot;&amp;amp;body&amp;quot;) &amp;quot; &amp;quot;
       (:ITALIC &amp;quot;body&amp;quot;)))
     (:PARAGRAPH
      (&amp;quot;Runs &amp;quot; (:FIXED-WIDTH &amp;quot;body&amp;quot;) &amp;quot; with &amp;quot; (:FIXED-WIDTH &amp;quot;:minor&amp;quot;)
       &amp;quot; mode applied.&amp;quot;)))))))

POFTHEDAY&amp;gt; (geneva.html:render-html * :index-p nil)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will render this HTML:&lt;/p&gt;
&lt;SECTION&gt;&lt;HEADER&gt;&lt;A NAME=&quot;section-1&quot;&gt;&lt;H1&gt;&lt;SPAN CLASS=&quot;geneva-index&quot;&gt;1&lt;/SPAN&gt; foo (Package)&lt;/H1&gt;&lt;/A&gt;&lt;/HEADER&gt;&lt;P&gt;This is an example of the package.&lt;/P&gt;&lt;P&gt;Documentation can be written in &lt;B&gt;MK2 format&lt;/B&gt;.&lt;/P&gt;&lt;P&gt;And include &lt;I&gt;rich&lt;/I&gt; text with links.&lt;/P&gt;&lt;SECTION&gt;&lt;HEADER&gt;&lt;A NAME=&quot;section-1-1&quot;&gt;&lt;H2&gt;&lt;SPAN CLASS=&quot;geneva-index&quot;&gt;1.1&lt;/SPAN&gt; *blah* (Variable)&lt;/H2&gt;&lt;/A&gt;&lt;/HEADER&gt;&lt;P&gt;&lt;B&gt;Initial Value:&lt;/B&gt;&lt;/P&gt;&lt;P&gt;&lt;CODE&gt;:BLAH&lt;/CODE&gt;&lt;/P&gt;&lt;P&gt;Switches between two modes: &lt;CODE&gt;:blah&lt;/CODE&gt; and &lt;CODE&gt;:minor&lt;/CODE&gt;&lt;/P&gt;&lt;/SECTION&gt;&lt;SECTION&gt;&lt;HEADER&gt;&lt;A NAME=&quot;section-1-2&quot;&gt;&lt;H2&gt;&lt;SPAN CLASS=&quot;geneva-index&quot;&gt;1.2&lt;/SPAN&gt; bar (Function)&lt;/H2&gt;&lt;/A&gt;&lt;/HEADER&gt;&lt;P&gt;&lt;B&gt;Syntax:&lt;/B&gt;&lt;/P&gt;&lt;P&gt;— Function: &lt;B&gt;bar&lt;/B&gt; &lt;I&gt;minor&lt;/I&gt;&lt;/P&gt;&lt;P&gt;Makes some tranformation.&lt;/P&gt;&lt;P&gt;&lt;B&gt;Arguments&lt;/B&gt;:&lt;/P&gt;&lt;P&gt;&lt;CODE&gt;minor&lt;/CODE&gt; - an object to transform.&lt;/P&gt;&lt;/SECTION&gt;&lt;SECTION&gt;&lt;HEADER&gt;&lt;A NAME=&quot;section-1-3&quot;&gt;&lt;H2&gt;&lt;SPAN CLASS=&quot;geneva-index&quot;&gt;1.3&lt;/SPAN&gt; with-minor (Macro)&lt;/H2&gt;&lt;/A&gt;&lt;/HEADER&gt;&lt;P&gt;&lt;B&gt;Syntax:&lt;/B&gt;&lt;/P&gt;&lt;P&gt;— Macro: &lt;B&gt;with-minor&lt;/B&gt; &lt;CODE&gt;&amp;amp;body&lt;/CODE&gt; &lt;I&gt;body&lt;/I&gt;&lt;/P&gt;&lt;P&gt;Runs &lt;CODE&gt;body&lt;/CODE&gt; with &lt;CODE&gt;:minor&lt;/CODE&gt; mode applied.&lt;/P&gt;&lt;/SECTION&gt;&lt;/SECTION&gt;&lt;p&gt;Of cause, you can provide your own CSS stylesheets to make the page looks like you want.&lt;/p&gt;
&lt;p&gt;I think Geneva might become a great replacement to reStructured text for documentation of my own libraries. Thank you, &lt;a href=&quot;https://twitter.com/eugeneia_&quot;&gt;@eugeneia_&lt;/a&gt;!.&lt;/p&gt;
&lt;p&gt;Though, it would be wonderful to add a little extensibility and ability to cross-referencing between different documentation sections.&lt;/p&gt;
&lt;p&gt;By the way, in Geneva&apos;s sources I found an interesting way to keep DRY principle. This piece of code reuses &lt;code&gt;(content-values text-token)&lt;/code&gt; 5 times.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defun render-text (text)
  &amp;quot;Render TEXT as HTML.&amp;quot;
  (dolist (text-token text)
    (ecase (content-type text-token)
      (:plain (text #1=(content-values text-token)))
      (:bold (b #1#))
      (:italic (i #1#))
      (:fixed-width (code #1#))
      (:url (multiple-value-bind (string url) #1#
              (a [:href (or url string)] (or string url)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I don&apos;t know the proper name of the Lisp&apos;s feature, but it allows to refer to the piece of data-structure defined earslier. The most common usage I&apos;ve seen before is a circular list&apos;s definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; &amp;#039;#1=(1 2 3 . #1#)
(1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3 1 2 3
 1 2 3 1 2 ...)&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Tue, 01 Sep 2020 23:56:50 +0300</pubDate>
        </item>
        <item>
            <title>cl-ltsv</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0176-cl-ltsv.html</link>
            <description>&lt;p&gt;This system implements an LTSV logs parser and serializer. LTSV is based on TSV format but each field has a name. This lets us easily add new fields and to process logs in a manageable way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-ltsv:alist-ltsv &amp;#039;((&amp;quot;message&amp;quot; . &amp;quot;Hello world!&amp;quot;)
                                 (&amp;quot;request_id&amp;quot; . 100500)))
&amp;quot;message:Hello world!	request_id:100500&amp;quot;

POFTHEDAY&amp;gt; (cl-ltsv:parse-line *)
((&amp;quot;message&amp;quot; . &amp;quot;Hello world!&amp;quot;)
 (&amp;quot;request_id&amp;quot; . &amp;quot;100500&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LTSV is based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Tab-separated_values&quot;&gt;TSV format&lt;/a&gt; which has some escaping rules for tabs, newlines and backslashes, but LTSV FAQ says &lt;a href=&quot;http://ltsv.org/faq.html#doesnt-it-have-to-have-escaping-in-its-spec&quot;&gt;forget about escaping&lt;/a&gt;, we don&apos;t need it for our access logs.&lt;/p&gt;
&lt;p&gt;I think this decision makes LTSV unusable for general-purpose logs.&lt;/p&gt;
&lt;p&gt;For example, if you have newlines or tabs in the logged value, a log will be broken:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (concatenate &amp;#039;string
                        &amp;quot;Hello&amp;quot;
                        &amp;#039;(#\Newline #\Tab)
                        &amp;quot;World!&amp;quot;)
&amp;quot;Hello
	World!&amp;quot;

;; This call should produce a single line,
;; replacing a newline with \n and tab with \t:
POFTHEDAY&amp;gt; (cl-ltsv:alist-ltsv (list (cons &amp;quot;message&amp;quot; *)))
&amp;quot;message:Hello
	World!&amp;quot;

;; Parsing does not process escaped symbols either:

POFTHEDAY&amp;gt; (cl-ltsv:parse-line &amp;quot;message:Hello\\n\\tWorld!&amp;quot;)
((&amp;quot;message&amp;quot; . &amp;quot;Hello\\n\\tWorld!&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is all I have for today. Probably tomorrow we&apos;ll catch a more interesting library.&lt;/p&gt;
</description>
            <pubDate>Mon, 31 Aug 2020 22:52:40 +0300</pubDate>
        </item>
        <item>
            <title>smug</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0175-smug.html</link>
            <description>&lt;p&gt;This system provides a framework for building parsers in a functional way.&lt;/p&gt;
&lt;p&gt;Smug parsers are lisp functions which can be combined together to process complex grammar. Actually, it can process anything, not only the text - any data source which can be read token by token is suitable.&lt;/p&gt;
&lt;p&gt;Documentation on &lt;code&gt;smug&lt;/code&gt; is extremely good! I&apos;ll how only the basics. Good job, &lt;a href=&quot;https://twitter.com/drewcrampsie&quot;&gt;@drewcrampsie&lt;/a&gt;. Read &lt;a href=&quot;http://smug.drewc.ca/tutorial.html&quot;&gt;the official tutorial&lt;/a&gt; to learn in deep how this sytem works!&lt;/p&gt;
&lt;p&gt;Today we&apos;ll create a parser which will be able to transform texts like &quot;3 days ago&quot; into the &lt;code&gt;local-time-duration:duration&lt;/code&gt; objects.&lt;/p&gt;
&lt;p&gt;To start, let&apos;s create a simple parser which will match a digit character:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun .digit ()
             (smug:.is #&amp;#039;digit-char-p))

POFTHEDAY&amp;gt; (smug:run (.digit)
                     &amp;quot;17 hours ago&amp;quot;)
((#\1 . &amp;quot;7 hours ago&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can use &lt;code&gt;.map&lt;/code&gt; to capture a sequence of digits matched to the parser:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (smug:run (smug:.map &amp;#039;list (.digit))
                     &amp;quot;17 hours ago&amp;quot;)
(((#\1 #\7) . &amp;quot; hours ago&amp;quot;)
 ((#\1)     . &amp;quot;7 hours ago&amp;quot;))

;; We also might produce strings:
POFTHEDAY&amp;gt; (smug:run (smug:.map &amp;#039;string (.digit))
                     &amp;quot;17 hours ago&amp;quot;)
((&amp;quot;17&amp;quot; . &amp;quot; hours ago&amp;quot;)
 (&amp;quot;1&amp;quot;  . &amp;quot;7 hours ago&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now it is time to transform it into the number. I&apos;ll wrap all code into the parser function and use &lt;code&gt;smug:.bind&lt;/code&gt; to process the captured values:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun .integer ()
             (smug:.bind (smug:.map &amp;#039;string (.digit))
                         (lambda (text)
                           (smug:.identity (read-from-string text)))))

POFTHEDAY&amp;gt; (smug:run (.integer)
                     &amp;quot;17 hours ago &amp;quot;)
((17 . &amp;quot; hours ago &amp;quot;)
 (1 . &amp;quot;7 hours ago &amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is time to parse time units:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (smug:run (smug:.prog1 (smug:.string-equal &amp;quot;hour&amp;quot;)
                                  ;; This will &amp;quot;eat&amp;quot; the &amp;quot;s&amp;quot; letter
                                  ;; on the end of the plural form
                                  ;; if it is used:
                                  (smug:.string-equal &amp;quot;s&amp;quot;))
                    &amp;quot;hours ago&amp;quot;)
((&amp;quot;hour&amp;quot; . &amp;quot; ago&amp;quot;))

;; Again, we&amp;#039;ll want to convert the string into the keyword and to wrap
;; the parser into a function:

POFTHEDAY&amp;gt; (defun .unit ()
             (smug:.bind (smug:.prog1 (smug:.or (smug:.string-equal &amp;quot;hour&amp;quot;)
                                                (smug:.string-equal &amp;quot;minute&amp;quot;)
                                                (smug:.string-equal &amp;quot;second&amp;quot;))
                                      ;; This will &amp;quot;eat&amp;quot; the &amp;quot;s&amp;quot; letter
                                      ;; on the end of the plural form
                                      ;; if it is used:
                                      (smug:.or (smug:.string-equal &amp;quot;s&amp;quot;)
                                                (smug:.identity nil)))
                         (lambda (text)
                           (smug:.identity (alexandria:make-keyword
                                            (string-upcase text))))))

POFTHEDAY&amp;gt; (smug:run (.unit)
                     &amp;quot;hours ago&amp;quot;)
((:HOUR . &amp;quot; ago&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally, we need a parser to process optional suffix pointing to the time in past:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun .in-past-p ()
             (smug:.or (smug:.string-equal &amp;quot;ago&amp;quot;)
                       (smug:.identity nil)))

POFTHEDAY&amp;gt; (smug:run (.in-past-p)
                     &amp;quot;ago&amp;quot;)
((&amp;quot;ago&amp;quot; . &amp;quot;&amp;quot;))

POFTHEDAY&amp;gt; (smug:run (.in-past-p)
                     &amp;quot;some&amp;quot;)
((NIL . &amp;quot;some&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is time to combine our parsers into a more complex one which will return a &lt;code&gt;local-time-duration&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun .whitespace ()
             (smug:.is #&amp;#039;member
                       &amp;#039;(#\Space #\Tab #\Newline)))

POFTHEDAY&amp;gt; (defun .duration ()
             (smug:.let* ((value (.integer))
                          (_ (.whitespace))
                          (unit (.unit))
                          (_ (.whitespace))
                          (in-past (.in-past-p)))
               (let* ((seconds
                        (* value
                           (ecase unit
                             (:hour (* 60 60))
                             (:minute 60)
                             (:second 1))
                           (if in-past
                               -1
                               1)))
                      (duration
                        (make-instance &amp;#039;local-time-duration:duration
                                       :sec seconds)))
                 
                 (smug:.identity duration))))

;; A few checks if everything is OK:

POFTHEDAY&amp;gt; (smug:parse (.duration)
                       &amp;quot;17 hours ago&amp;quot;)
#&amp;lt;LOCAL-TIME-DURATION:DURATION [0/-61200/0]  -17 hours&amp;gt;

POFTHEDAY&amp;gt; (smug:parse (.duration)
                       &amp;quot;5 minute &amp;quot;)
#&amp;lt;LOCAL-TIME-DURATION:DURATION [0/300/0]  5 minutes&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it for today. And again, to learn more, read SMUG&apos;s documentation. It is one of the best-documented Lisp systems I&apos;ve ever seen:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://smug.drewc.ca/smug.html&quot;&gt;http://smug.drewc.ca/smug.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Thank you, @drewcrampsie!&lt;/p&gt;
</description>
            <pubDate>Sun, 30 Aug 2020 22:50:00 +0300</pubDate>
        </item>
        <item>
            <title>list-named-class</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0174-list-named-class.html</link>
            <description>&lt;p&gt;This is &lt;a href=&quot;https://github.com/phoe/list-named-class&quot;&gt;the library&lt;/a&gt; by Michał &quot;phoe&quot; Herda. It extends CLOS allowing to use lists of symbols as class names:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (list-named-class:defclass (:user :model) ()
             ())

POFTHEDAY&amp;gt; (list-named-class:defclass (:user :view) ()
             ())

POFTHEDAY&amp;gt; (list-named-class:defgeneric render (obj))

POFTHEDAY&amp;gt; (list-named-class:defmethod render ((obj (:user :view)))
             (format nil &amp;quot;Rendered User View&amp;quot;))

POFTHEDAY&amp;gt; (list-named-class:make-instance &amp;#039;(:user :view))
#&amp;lt;(:USER :VIEW) {10076F6CC3}&amp;gt;

POFTHEDAY&amp;gt; (render *)
&amp;quot;Rendered User View&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This can be useful when classes are defined using some macros. Not sure why somebody should prefer such class-names instead of symbols.&lt;/p&gt;
&lt;p&gt;Here are some examples of &lt;code&gt;list-named-class&lt;/code&gt; usage I found in the wild:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/RaptorLauncher/Gateway/blob/5fc2d404cd53854f570b8debbd869053d3a71043/wip/messages/hello.lisp&quot;&gt;https://github.com/RaptorLauncher/Gateway/blob/5fc2d404cd53854f570b8debbd869053d3a71043/wip/messages/hello.lisp&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/RaptorLauncher/Gateway/blob/035701b804873265b9eb59e1b97a92645aa4388b/wip/library/base/impl/standard-message.lisp&quot;&gt;https://github.com/RaptorLauncher/Gateway/blob/035701b804873265b9eb59e1b97a92645aa4388b/wip/library/base/impl/standard-message.lisp&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
            <pubDate>Sat, 29 Aug 2020 23:31:36 +0300</pubDate>
        </item>
        <item>
            <title>temporal-functions</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0173-temporal-functions.html</link>
            <description>&lt;p&gt;This is a small library by &lt;a href=&quot;https://twitter.com/thebaggers/&quot;&gt;@thebaggers&lt;/a&gt; allows you to define functions which work only specified amount of time. You can use it to define a named function or to create a lambda.&lt;/p&gt;
&lt;p&gt;This will print a greeting only 10 seconds since definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (temporal-functions:defun-t foo ()
             (temporal-functions:before (temporal-functions:seconds 10)
               (print &amp;quot;Hello Lisp World!&amp;quot;)))

POFTHEDAY&amp;gt; (foo)
&amp;quot;Hello Lisp World!&amp;quot; 
&amp;quot;Hello Lisp World!&amp;quot;

POFTHEDAY&amp;gt; (foo)
&amp;quot;Hello Lisp World!&amp;quot; 
&amp;quot;Hello Lisp World!&amp;quot;

POFTHEDAY&amp;gt; (foo)
NIL

POFTHEDAY&amp;gt; (temporal-functions:expiredp (foo))
T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is possible to create a function which starts doing something after the specified amount of time:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (temporal-functions:tlambda ()
             (temporal-functions:after (temporal-functions:seconds 10)
               (print &amp;quot;Now I&amp;#039;m working!&amp;quot;)))
#&amp;lt;CLOSURE (LAMBDA ()) {1001D5183B}&amp;gt;

POFTHEDAY&amp;gt; (funcall *)
NIL

POFTHEDAY&amp;gt; (funcall **)

&amp;quot;Now I&amp;#039;m working!&amp;quot; 
&amp;quot;Now I&amp;#039;m working!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also other constructions like &lt;code&gt;then&lt;/code&gt;, &lt;code&gt;repeat&lt;/code&gt;, &lt;code&gt;each&lt;/code&gt;, &lt;code&gt;until&lt;/code&gt; and &lt;code&gt;once&lt;/code&gt;. But I wasn&apos;t able to figure out the right way to use them. It would be wonderful if  &lt;a href=&quot;https://twitter.com/thebaggers/&quot;&gt;@thebaggers&lt;/a&gt; update the documentation!&lt;/p&gt;
</description>
            <pubDate>Fri, 28 Aug 2020 23:05:12 +0300</pubDate>
        </item>
        <item>
            <title>lazy</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0172-lazy.html</link>
            <description>&lt;p&gt;This is a small library by &lt;a href=&quot;https://twitter.com/codeninja_blog&quot;&gt;@codeninja_blog&lt;/a&gt;. It provides only a macro to wrap and remember any form and a function to force its evaluation.&lt;/p&gt;
&lt;p&gt;For example, let&apos;s create a few functions which accept and return lazy objects:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun request-name ()
             (lazy:lazy
               (format t &amp;quot;What is your name?~%&amp;quot;)
               (read-line)))


POFTHEDAY&amp;gt; (defun greet (name)
             (lazy:lazy
               (format nil &amp;quot;Hello ~A!~%&amp;quot;
                       (lazy:lazy-value name))))

POFTHEDAY&amp;gt; (greet (request-name))
#&amp;lt;LAZY::THUNK UNREALIZED&amp;gt;

POFTHEDAY&amp;gt; (lazy:lazy-value *)
What is your name?
Bob
&amp;quot;Hello Bob!
&amp;quot;

;; Second attempt to get the greeting value
;; is not request for the user&amp;#039;s name:
POFTHEDAY&amp;gt; (lazy:lazy-value **)
&amp;quot;Hello Bob!
&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or we can build a simple lazy sequences library.&lt;/p&gt;
&lt;p&gt;This function will create a sequence of numbers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun make-lazy-sequence (&amp;amp;optional (start 0) (step 1))
             (lazy:lazy
               (values start
                       (make-lazy-sequence (+ start step)
                                           step))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This one will skip a number of items:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun lazy-skip (n lazy-sequence)
             (lazy:lazy
               (loop do
                 (multiple-value-bind (item rest)
                     (lazy:lazy-value lazy-sequence)
                   (when (zerop n)
                     (return (values item rest)))
                   (decf n)
                   (setf lazy-sequence rest)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And this one will force lazy evaluation and transform the sequence into the list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun lazy-to-list (n lazy-sequence)
             (loop with result = nil
                   do (multiple-value-bind (item rest)
                          (lazy:lazy-value lazy-sequence)
                        (when (zerop n)
                          (return (nreverse result)))
                        (push item result)
                        (setf lazy-sequence rest)
                        (decf n))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And of cause we need a generic map function to apply transformations:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun lazy-mapcar (func sequence)
             (lazy:lazy
               (multiple-value-bind (item rest)
                   (lazy:lazy-value sequence)
                 (values (funcall func item)
                         (lazy-mapcar func rest)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how we can apply these functions to process a lazy sequence:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (make-lazy-sequence)

POFTHEDAY&amp;gt; (lazy-skip 5 *)

POFTHEDAY&amp;gt; (lazy-mapcar (lambda (x)
                          (format t &amp;quot;Multiplying ~A to ~A~%&amp;quot;
                                  x x)
                          (* x x))
                        *)

POFTHEDAY&amp;gt; (lazy-to-list 3 *)
Multiplying 5 to 5
Multiplying 6 to 6
Multiplying 7 to 7
Multiplying 8 to 8
(25 36 49)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But this will work only with my &lt;a href=&quot;https://github.com/massung/lazy/pull/1&quot;&gt;pull request&lt;/a&gt; which makes the &lt;code&gt;lazy-value&lt;/code&gt; return all values, returned by original form.&lt;/p&gt;
&lt;p&gt;Anyway, &lt;code&gt;lazy&lt;/code&gt; is a small and very nice library. Thank you,  &lt;a href=&quot;https://twitter.com/codeninja_blog&quot;&gt;@codeninja_blog&lt;/a&gt;.&lt;/p&gt;
</description>
            <pubDate>Wed, 26 Aug 2020 23:47:24 +0300</pubDate>
        </item>
        <item>
            <title>dynamic-classes</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0171-dynamic-classes.html</link>
            <description>&lt;p&gt;This library allows to dynamically create CLOS classes as a mixin composition. Mixins are choosen depending on parameters given to the constructor.&lt;/p&gt;
&lt;p&gt;For example, if we have in our system users, which can be authenticated and additionally can be admins, then we can to define their classes like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ())

POFTHEDAY&amp;gt; (defclass authenticated ()
             ((email :initarg :email)))

POFTHEDAY&amp;gt; (defclass admin ()
             ())&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we need to tell the system how to apply our mixins when different parameters are passed. If there is &lt;code&gt;:email&lt;/code&gt;, then the user will be considered authenticated. If there is &lt;code&gt;:is-admin t&lt;/code&gt; - he is the admin.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dynamic-classes:add-parameter-&amp;gt;dynamic-class
            :user :email &amp;#039;authenticated)
NIL
POFTHEDAY&amp;gt; (dynamic-classes:add-parameter-&amp;gt;dynamic-class
            :user :is-admin &amp;#039;admin)
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We also have to declare these methods to make the framework do its job. Probably this can be avoided if only the default implementation was specialized not on &lt;code&gt;class-type (eql nil)&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defmethod dynamic-classes:include-class-dependencies
               ((class-type (eql :user))
                dynamic-class class-list &amp;amp;rest parameters)
             &amp;quot;This method can modify list of classes used to combine into a new class
              for given parameters. Or some restrictions can be applied.&amp;quot;
             (declare (ignorable dynamic-class parameters))
             class-list)

POFTHEDAY&amp;gt; (defmethod dynamic-classes:existing-subclass
               ((class-type (eql :user)) class-list)
             &amp;quot;This method allows to return a custom class. If it returns nil,
              the first class from the class-list will be choosen.&amp;quot;
             (declare (ignorable class-list))
             (values nil))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s check how it works. There is a function to create and return the class depending on the parameters:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dynamic-classes:determine-dynamic-class :user &amp;#039;user)
USER

POFTHEDAY&amp;gt; (dynamic-classes:determine-dynamic-class :user &amp;#039;user :email &amp;quot;some@gmail.com&amp;quot;)
USER-AND-AUTHENTICATED

POFTHEDAY&amp;gt; (dynamic-classes:determine-dynamic-class :user &amp;#039;user :email nil)
USER-AND-AUTHENTICATED

POFTHEDAY&amp;gt; (dynamic-classes:determine-dynamic-class :user &amp;#039;user
                                                    :email &amp;quot;some@gmail.com&amp;quot;
                                                    :is-admin t)
USER-AND-AUTHENTICATED-AND-ADMIN

POFTHEDAY&amp;gt; (dynamic-classes:determine-dynamic-class :user &amp;#039;user
                                                    :is-admin t)
USER-AND-ADMIN&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Do you see there a strange behavior? We can pass the &lt;code&gt;nil&lt;/code&gt; as an email and user will be considered &lt;code&gt;authenticated&lt;/code&gt; or we can use &lt;code&gt;:is-admin&lt;/code&gt; without email and will get unauthenticated admin class!&lt;/p&gt;
&lt;p&gt;Fortunately, there is a hook to apply additional restrictions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defmethod dynamic-classes:include-class-dependencies
               ((class-type (eql :user))
                dynamic-class class-list &amp;amp;rest parameters)
             (declare (ignorable dynamic-class parameters))

             ;; If email is not given we don&amp;#039;t want consider
             ;; the user authenticated:
             (when (and (member :email parameters)
                        (null (getf parameters :email)))
               (rutils:removef class-list &amp;#039;authenticated))

             ;; And if :is-admin nil then he is not an admin:
             (when (and (member :is-admin parameters)
                        (null (getf parameters :is-admin)))
               (rutils:removef class-list &amp;#039;admin))

             ;; Also, we need admins always be authenticated:
             (when (and (member &amp;#039;admin class-list)
                        (not (member &amp;#039;authenticated class-list)))
               (error &amp;quot;Admin should have an email!&amp;quot;))

             class-list)

POFTHEDAY&amp;gt; (dynamic-classes:determine-dynamic-class :user &amp;#039;user
                                                    :email &amp;quot;some@gmail.com&amp;quot;
                                                    :is-admin t)
USER-AND-AUTHENTICATED-AND-ADMIN

POFTHEDAY&amp;gt; (dynamic-classes:determine-dynamic-class :user &amp;#039;user
                                                    :email &amp;quot;some@gmail.com&amp;quot;
                                                    :is-admin nil)
USER-AND-AUTHENTICATED

POFTHEDAY&amp;gt; (dynamic-classes:determine-dynamic-class :user &amp;#039;user
                                                    :email nil
                                                    :is-admin nil)
USER

POFTHEDAY&amp;gt; (dynamic-classes:determine-dynamic-class :user &amp;#039;user
                                                    :email nil
                                                    :is-admin t)
; Debugger entered on #&amp;lt;SIMPLE-ERROR &amp;quot;Admin should have an email!&amp;quot; {100B6CAD73}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we need to wrap this into a single constructor &lt;code&gt;make-user&lt;/code&gt; which will return objects of different class depending on arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun make-user (&amp;amp;rest args &amp;amp;key email is-admin)
             (declare (ignore email is-admin))
             (let ((class (apply #&amp;#039;dynamic-classes:determine-dynamic-class
                                 :user &amp;#039;user
                                 args)))
               (apply #&amp;#039;make-instance class
                      ;; We don&amp;#039;t store is-admin as the slot:
                      (rutils:remove-from-plist args :is-admin))))

POFTHEDAY&amp;gt; (make-user)
#&amp;lt;USER {1006704893}&amp;gt;

POFTHEDAY&amp;gt; (make-user :email &amp;quot;blah@min.or&amp;quot;)
#&amp;lt;USER-AND-AUTHENTICATED {1006779083}&amp;gt;

POFTHEDAY&amp;gt; (make-user :email &amp;quot;blah@min.or&amp;quot; :is-admin t)
#&amp;lt;USER-AND-AUTHENTICATED-AND-ADMIN {10067C26C3}&amp;gt;

POFTHEDAY&amp;gt; (make-user :is-admin t)
; Debugger entered on #&amp;lt;SIMPLE-ERROR &amp;quot;Admin should have an email!&amp;quot; {10067D0193}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To make these classes print in a human-readable way, use &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/07/0145-utilities.print-items.html&quot;&gt;print-items&lt;/a&gt; library, reviewed in the &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/07/0145-utilities.print-items.html&quot;&gt;post #0145&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The more sophisticated use of the &lt;code&gt;dynamic-classes&lt;/code&gt; can be found in the &lt;a href=&quot;https://github.com/gwkkwg/cl-containers/blob/810927e19d933bcf38ffeb7a23ce521efc432d45/dev/dynamic-class-defs.lisp&quot;&gt;cl-containers&lt;/a&gt; library. It uses dynamic-classes to mix container and iterator classes to give them different traits depending on constructor&apos;s parameters.&lt;/p&gt;
</description>
            <pubDate>Wed, 26 Aug 2020 10:53:32 +0300</pubDate>
        </item>
        <item>
            <title>portable-threads</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0170-portable-threads.html</link>
            <description>&lt;p&gt;This system is similar to &lt;a href=&quot;https://sionescu.github.io/bordeaux-threads/&quot;&gt;bordeaux-threads&lt;/a&gt; but has some unique features.&lt;/p&gt;
&lt;p&gt;What I like is that &lt;code&gt;portable-threads&lt;/code&gt; forces you to give the thread a name. No more Anonumous threads!&lt;/p&gt;
&lt;p&gt;Also, there is a shortcut macro to start any code in a thread without wrapping it into an explicit lambda:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (portable-threads:spawn-form 
             (format t &amp;quot;Running in ~S thread&amp;quot;
                     (portable-threads:thread-name
                      (portable-threads:current-thread))))

Running in &amp;quot;Form (FORMAT T ...)&amp;quot; thread
#&amp;lt;SB-THREAD:THREAD &amp;quot;Form (FORMAT T ...)&amp;quot; FINISHED values: NIL {10051E61C3}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or there is also a shortcut to run periodical tasks in the thread:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun periodic ()
             (format t &amp;quot;[~A] Running in ~S thread~%&amp;quot;
                     (local-time:now)
                     (portable-threads:thread-name
                      (portable-threads:current-thread))))

POFTHEDAY&amp;gt; (portable-threads:spawn-periodic-function
            #&amp;#039;periodic
            5
            :count 3
            :verbose t)

;; Spawning periodic-function thread for...
#&amp;lt;SB-THREAD:THREAD &amp;quot;Periodic Function&amp;quot; RUNNING {100466CDB3}&amp;gt;
[2020-08-23T14:00:35.207071+03:00] Running in &amp;quot;Periodic Function&amp;quot; thread
[2020-08-23T14:00:40.214253+03:00] Running in &amp;quot;Periodic Function&amp;quot; thread
[2020-08-23T14:00:45.215454+03:00] Running in &amp;quot;Periodic Function&amp;quot; thread
;; Exiting periodic-function thread&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another cool feature not found in &lt;code&gt;bordeaux-threads&lt;/code&gt; is thread hibernation. Any thread can fall asleep and be awakened later:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun do-the-job ()
             (format t &amp;quot;Started a thread ~A~%&amp;quot;
                     (portable-threads:thread-name
                      (portable-threads:current-thread)))
             ;; Now we&amp;#039;ll fall asleep until somebody will
             ;; call awake.
             (portable-threads:hibernate-thread)
             (format t &amp;quot;Thread ~A works again!~%&amp;quot;
                     (portable-threads:thread-name
                      (portable-threads:current-thread))))

POFTHEDAY&amp;gt; (defparameter *thread*
             (portable-threads:spawn-thread &amp;quot;Worker&amp;quot;
                                            #&amp;#039;do-the-job))
Started a thread Worker

POFTHEDAY&amp;gt; (portable-threads:thread-whostate *thread*)
&amp;quot;Alive&amp;quot;

;; Now we wake thread up:

POFTHEDAY&amp;gt; (portable-threads:awaken-thread *thread*)
Thread Worker works again!
0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are other interesting helpers like protected calls to work with lists.&lt;/p&gt;
&lt;p&gt;Read &lt;a href=&quot;http://gbbopen.org/hyperdoc/ref-portable-thread-entities.html&quot;&gt;the documentation&lt;/a&gt; to find more gems!&lt;/p&gt;
</description>
            <pubDate>Sun, 23 Aug 2020 14:05:34 +0300</pubDate>
        </item>
        <item>
            <title>snakes</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0169-snakes.html</link>
            <description>&lt;p&gt;This system makes it very easy to create and use a generator in Python style.&lt;/p&gt;
&lt;p&gt;This code demostrates how a simple generator works in Python. The generator creates an iterable object and values can be extracted by calling the &lt;code&gt;next&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;python&apos;&gt;In [1]: def simple():
   ...:     yield 1
   ...:     print(&amp;#039;LOG: Going to the second yield&amp;#039;)
   ...:     yield 2
   ...:

In [2]: simple()
Out[2]: &amp;lt;generator object simple at 0x10752a050&amp;gt;

In [3]: next(_2)
Out[3]: 1

In [4]: next(_2)
LOG: Going to the second yield
Out[4]: 2

In [5]: next(_2)
------------------
StopIteration&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The similar generator can be implemented with &lt;code&gt;snakes&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (snakes:defgenerator simple ()
             (snakes:yield 1)
             (format t &amp;quot;LOG: Going to the second yield~%&amp;quot;)
             (snakes:yield 2))

POFTHEDAY&amp;gt; (simple)
#&amp;lt;SNAKES:BASIC-GENERATOR {1008454D4B}&amp;gt;

POFTHEDAY&amp;gt; (funcall *)
LOG: Going to the second yield
1

POFTHEDAY&amp;gt; (funcall **)
2

POFTHEDAY&amp;gt; (funcall ***)
SNAKES:GENERATOR-STOP&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the more interesting example of the generator which produces an infinite sequence of Fibonacci numbers:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (snakes:defgenerator fib ()
             (loop with a = 0
                   with b = 1
                   for new-b = (+ a b)
                   do (snakes:yield a)
                      (setf a b
                            b new-b)))

POFTHEDAY&amp;gt; (snakes:take 20 (fib))
(0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181)

;; Or we can skip first 50 numbers and output 5 next:
POFTHEDAY&amp;gt; (snakes:generator-&amp;gt;list
            (snakes:islice (fib)
                           50 55))
(12586269025 20365011074 32951280099 53316291173 86267571272)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also other features like:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;anonymous generators;&lt;/li&gt;&lt;li&gt;yield-from form;&lt;/li&gt;&lt;li&gt;forms to iterate over generators;&lt;/li&gt;&lt;li&gt;functions ported from Python&apos;s &lt;code&gt;itertools&lt;/code&gt;;&lt;/li&gt;&lt;li&gt;integration with &lt;code&gt;iterate&lt;/code&gt; library.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Snakes&lt;/code&gt; has &lt;a href=&quot;http://quickdocs.org/snakes/&quot;&gt;a comprehensive documentation&lt;/a&gt; which covers all its features.&lt;/p&gt;
</description>
            <pubDate>Sat, 22 Aug 2020 22:27:25 +0300</pubDate>
        </item>
        <item>
            <title>texp</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0168-texp.html</link>
            <description>&lt;p&gt;This is a little wrapper around TeX language to make it compatible with Lisp&apos;s sexps. Written by &lt;a href=&quot;https://twitter.com/eugeneia_&quot;&gt;@eugeneia_&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here is a little example, I&apos;ve taken from the documentation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun tex-menu (menu)
             (texp:deftex item (caption price)
               (texp:$ caption) &amp;quot; &amp;quot; (texp:$ (texp:escape &amp;quot;$&amp;quot;)) (texp:$ price)
               (texp:br)
               (texp::bigskip))
             (loop for (caption price) in menu
                   do (texp:tex (item {(texp:$ (texp:escape caption))}
                                      {(texp:$ (texp:escape price))})))
             (texp:tex (bye)))


POFTHEDAY&amp;gt; (tex-menu &amp;#039;((&amp;quot;Mozzarella Sticks&amp;quot; &amp;quot;5.99&amp;quot;)
                       (&amp;quot;Onion Rings&amp;quot; &amp;quot;4.99&amp;quot;)
                       (&amp;quot;Spinach&amp;quot; &amp;quot;5.99&amp;quot;)))
\def \item #1#2{#1 \$#2

\bigskip }

\item {Mozzarella Sticks}{5.99}\item {Onion Rings}{4.99}\item {Spinach}{5.99}\bye&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To render the DVI file, save this output into the file &lt;code&gt;example.tex&lt;/code&gt; and run &lt;code&gt;tex example.tex&lt;/code&gt;. (On OSX you can install TeX using &lt;code&gt;brew cask install mactex&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;This command will generate example.tex file which will look like that:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0168/example.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;With this system, you can use full power or the Lisp to write publishing systems. For example, &lt;a href=&quot;https://github.com/eugeneia/geneva&quot;&gt;Geneva&lt;/a&gt; documentation system uses it to generate TeX and LaTeX outputs.&lt;/p&gt;
</description>
            <pubDate>Fri, 21 Aug 2020 20:35:42 +0300</pubDate>
        </item>
        <item>
            <title>cl-flat-tree</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0167-cl-flat-tree.html</link>
            <description>&lt;p&gt;This system implements an interesting algorithm suitable for storing binary tries or transmitting them over the wire without overhead on storing pointers.&lt;/p&gt;
&lt;p&gt;There is almost no information about this algorithm on the internet. The best description I found is:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://datprotocol.github.io/book/ch01-01-flat-tree.html&quot;&gt;https://datprotocol.github.io/book/ch01-01-flat-tree.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Also, there are versions for Go, C, JS, Rust and Kotlin listed here:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mafintosh/flat-tree&quot;&gt;https://github.com/mafintosh/flat-tree&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let&apos;s try to serialize a binary tree, represented by lists into a flat vector. First, we need to prepare a vector which size depends on the depth of the tree:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Here is a tree:
;;            /
;;       *
;;   +     15   100.0
;; A   B

POFTHEDAY&amp;gt; (defparameter *structure*
             &amp;#039;(/ (* (+ a b)
                    15)
                 100.0))

POFTHEDAY&amp;gt; (defparameter *depth*
             (rutils:tree-depth *structure*))

POFTHEDAY&amp;gt; *depth*
4

POFTHEDAY&amp;gt; (defparameter *size* (expt 2 *depth*))

POFTHEDAY&amp;gt; (defparameter *data*
             (make-array (list (expt 2 *depth*))
                         :initial-element nil))
#(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Missing nodes are filled with nils.&lt;/p&gt;
&lt;p&gt;Flat-tree is not a data-structure; it is an algorithm to calculate the tree node&apos;s index in the flat vector.&lt;/p&gt;
&lt;p&gt;That is why we need to write a function which will take lists forming a binary tree and dump it into the vector as a &quot;flat-tree&quot;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun fill-tree (vector obj depth offset)
             (let ((index (flat-tree:index depth offset)))
               (cond
                 ((listp obj)
                  (setf (aref vector index)
                        (first obj))
                  (fill-tree vector (second obj)
                             (1- depth) 0)
                  (fill-tree vector (third obj)
                             (1- depth) 1))
                 ;; If it is a symbol
                 (t
                  (setf (aref vector index)
                        obj))))
             (values vector
                     obj))

POFTHEDAY&amp;gt; (fill-tree *data* *structure* 3 0)

;; The first value is a resulting vector
#(A + B * NIL 15 NIL / NIL NIL NIL 100.0 NIL NIL NIL NIL)

;; And the second is original data-structure
(/ (* (+ A B) 15) 100.0)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We also can define a function to print our tree in a readable form.&lt;/p&gt;
&lt;p&gt;If you are more skilled in ASCII Art than me, maybe you can provide a more advanced version?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun print-flat-tree (vector)
             (loop for item across vector
                   for index upfrom 0
                   for as-str = (format nil &amp;quot;~S&amp;quot; item)
                   for depth = (flat-tree:depth index)
                   for padded = (str:pad-left (* depth 5) as-str)
                   when item
                     do (format t &amp;quot;~A~%&amp;quot;
                                padded)))

POFTHEDAY&amp;gt; (print-flat-tree *data*)
A
    +
B
         *
   15
              /
     100.0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As a home task, I&apos;ll leave a function which restores the lisp data-structure from the vector. The solution should work with sparse tries like this one:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; read-flat-tree(#(A + B * NIL 15 NIL / NIL NIL NIL 100.0 NIL NIL NIL NIL))

(/ (* (+ A B)
      15)
   100.0)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Hope to see you tomorrow in the next #poftheday post!&lt;/p&gt;
</description>
            <pubDate>Thu, 20 Aug 2020 22:55:56 +0300</pubDate>
        </item>
        <item>
            <title>breeze</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0166-breeze.html</link>
            <description>&lt;p&gt;This project is still in the development phase but I like its idea. &lt;a href=&quot;https://github.com/fstamour/breeze&quot;&gt;Breeze&lt;/a&gt; tries to improve the development process. An especially interesting feature: its ability to run tests on function redefinition!&lt;/p&gt;
&lt;p&gt;To make it work, you have to use &lt;code&gt;defun&lt;/code&gt; and &lt;code&gt;deftest&lt;/code&gt; from &lt;code&gt;breeze&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (breeze:defun foo ()
             100)

;; When we define the test, it is immediately
;; run in a separate thread:
POFTHEDAY&amp;gt; (breeze:deftest test-foo
             (unless (= (foo) 42)
               (error &amp;quot;Foo should return 42&amp;quot;)))
Running all tests...
WARNING: 
Test TEST-FOO failed with condition Foo should return 42

Test &amp;quot;TEST-FOO&amp;quot; failed with condition:
&amp;quot;Foo should return 42&amp;quot;
Done [0/1] tests passed.

;; Now I&amp;#039;m going to fix it.
;; Pay attention on the output. Breeze automatically
;; runs tests of the &amp;#039;foo function in a separate thread:
POFTHEDAY&amp;gt; (breeze:defun foo ()
             42)
Running all tests....
Done [1/1] tests passed.

;; Now let&amp;#039;s break it again!
POFTHEDAY&amp;gt; (breeze:defun foo ()
             77)
FOO
Running all tests...
WARNING: 
Test TEST-FOO failed with condition Foo should return 42

Test &amp;quot;TEST-FOO&amp;quot; failed with condition:
&amp;quot;Foo should return 42&amp;quot;
Done [0/1] tests passed.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also some extension for Emacs and SLIME, but I didn&apos;t test it yet. I hope the author will make this system more usable.&lt;/p&gt;
&lt;p&gt;The first feature which comes to mind is support for existing unit-testing frameworks. The second is an indicator for the Emacs mode-line if some tests failed after I hit &lt;code&gt;C-c C-c&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To conclude, make good tooling! Tooling should be convenient!&lt;/p&gt;
</description>
            <pubDate>Wed, 19 Aug 2020 23:32:01 +0300</pubDate>
        </item>
        <item>
            <title>lyrics</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0165-lyrics.html</link>
            <description>&lt;p&gt;Today we&apos;ll have some fun because this library allows us to search for music text and sing together!&lt;/p&gt;
&lt;p&gt;Install the library and do this in the REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lyrics:lyrics &amp;quot;Bob Kanefsky&amp;quot; &amp;quot;eternal flame&amp;quot;)
&amp;quot;I was taught Assembler in my second year of school.
It&amp;#039;s kinda like construction work --
with a toothpick for a tool.
So when I made my senior year,
I threw my code away,
And learned the way to program
that I still prefer today.

Now, some folks on the Internet
put their faith in C++.
They swear that it&amp;#039;s so powerful,
it&amp;#039;s what God used for us.
And maybe He lets mortals dredge
their objects from the C.
But I think that explains
why only God can make a tree.

For God wrote in Lisp code
When he filled the leaves with green.
The fractal flowers and recursive roots:
The most lovely hack I&amp;#039;ve seen.
And when I ponder snowflakes,
never finding two the same,
I know God likes a language
with its own four-letter name.

Now, I&amp;#039;ve used a SUN under Unix,
so I&amp;#039;ve seen what C can hold.
I&amp;#039;ve surfed for Perls, found what Fortran&amp;#039;s for,
Got that Java stuff down cold.
Though the chance that I&amp;#039;d write COBOL code
is a SNOBOL&amp;#039;s chance in Hell.
And I basically hate hieroglyphs,
so I won&amp;#039;t use APL.

Now, God must know all these languages,
and a few I haven&amp;#039;t named.
But the Lord made sure, when each sparrow falls,
that its flesh will be reclaimed.
And the Lord could not count grains of sand
with a 32-bit word.
Who knows where we would go to
if Lisp weren&amp;#039;t what he preferred?

And God wrote in Lisp code
Every creature great and small.
Don&amp;#039;t search the disk drive for man.c,
When the listing&amp;#039;s on the wall.
And when I watch the lightning burn
Unbelievers to a crisp,
I know God had six days to work,
So he wrote it all in Lisp.

Yes, God had a deadline.
So he wrote it all in Lisp.&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is also can grep all texts you&apos;ve ever found. For example, we can find all lines which mention the LISP:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lyrics:search-song &amp;quot;lisp&amp;quot;)
((&amp;quot;Bob Kanefsky&amp;quot; &amp;quot;eternal flame&amp;quot; &amp;quot;For God wrote in Lisp code&amp;quot;)
 (&amp;quot;Bob Kanefsky&amp;quot; &amp;quot;eternal flame&amp;quot; &amp;quot;if Lisp weren&amp;#039;t what he preferred?&amp;quot;)
 (&amp;quot;Bob Kanefsky&amp;quot; &amp;quot;eternal flame&amp;quot; &amp;quot;And God wrote in Lisp code&amp;quot;)
 (&amp;quot;Bob Kanefsky&amp;quot; &amp;quot;eternal flame&amp;quot; &amp;quot;So he wrote it all in Lisp.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Ok, enough coding, let&apos;s sing together! If you don&apos;t know the tune, open this video:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=u-7qFAuFGao&quot;&gt;https://www.youtube.com/watch?v=u-7qFAuFGao&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Or open these chords for the guitar:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/jimweirich/6181853&quot;&gt;https://gist.github.com/jimweirich/6181853&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Tue, 18 Aug 2020 23:52:17 +0300</pubDate>
        </item>
        <item>
            <title>simple-tasks</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0164-simple-tasks.html</link>
            <description>&lt;p&gt;This is a &lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@Shinmera&lt;/a&gt;&apos;s library for task processing. It implements abstraction over multithreading/multiprocessing which operates by means of a runner and a task.&lt;/p&gt;
&lt;p&gt;A runner in the &lt;code&gt;simple-task&lt;/code&gt; is an object responsible for task scheduling. By default, only a simple &lt;code&gt;queued-runner&lt;/code&gt; is implemented. It executes all task in a single thread one by one.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;simple-task&lt;/code&gt; has &lt;a href=&quot;https://shinmera.github.io/simple-tasks/&quot;&gt;good documentation&lt;/a&gt; but there is no big example showing the essence of the runner/task concept. Let&apos;s fix it!&lt;/p&gt;
&lt;p&gt;Next example creates a single thread for the runner and starts separate threads where each thread executes a task in a different way.&lt;/p&gt;
&lt;p&gt;First, we need to start the runner:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *thread*
             (simple-tasks:make-runner-thread *runner*))

;; It is the third in this list:

POFTHEDAY&amp;gt; (bt:all-threads)
(#&amp;lt;SB-THREAD:THREAD &amp;quot;sly-channel-1-mrepl-remote-1&amp;quot; RUNNING {10037F5B93}&amp;gt;
 #&amp;lt;SB-THREAD:THREAD &amp;quot;reader-thread&amp;quot; RUNNING {10026F8103}&amp;gt;
 #&amp;lt;SB-THREAD:THREAD &amp;quot;runner thread&amp;quot; waiting on:
      #&amp;lt;WAITQUEUE task-runner-condition {1003231D63}&amp;gt;
    {100323F833}&amp;gt;
 #&amp;lt;SB-THREAD:THREAD &amp;quot;slynk-indentation-cache-thread&amp;quot; waiting on:
      #&amp;lt;WAITQUEUE  {1002700143}&amp;gt;
    {10026F8233}&amp;gt;
 #&amp;lt;SB-THREAD:THREAD &amp;quot;main thread&amp;quot; RUNNING {1001538543}&amp;gt;
 #&amp;lt;SB-THREAD:THREAD &amp;quot;Slynk Sentinel&amp;quot; waiting on:
      #&amp;lt;WAITQUEUE  {10025300B3}&amp;gt;
    {1002529253}&amp;gt;
 #&amp;lt;SB-THREAD:THREAD &amp;quot;control-thread&amp;quot; waiting on:
      #&amp;lt;WAITQUEUE  {10026F8343}&amp;gt;
    {10026F5D73}&amp;gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, we&apos;ll start our tasks. Each of them will print the current thread. This way we&apos;ll ensure all of them are running in the runner&apos;s thread:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun print-and-return-current-thread ()
             (let ((name (bt:thread-name (bt:current-thread))))
               (format t &amp;quot;Running in \&amp;quot;~A\&amp;quot; thread.~%&amp;quot;
                       name)
               (values name)))

POFTHEDAY&amp;gt; (defvar *first-task*
             (make-instance
              &amp;#039;simple-tasks:call-task
              :func #&amp;#039;print-and-return-current-thread))

POFTHEDAY&amp;gt; (simple-tasks:status *first-task*)
:CREATED

POFTHEDAY&amp;gt; (simple-tasks:schedule-task *first-task*
                                       *runner*)
Running in &amp;quot;runner thread&amp;quot; thread.

POFTHEDAY&amp;gt; (simple-tasks:status *first-task*)
:COMPLETED

POFTHEDAY&amp;gt; (simple-tasks:return-values *first-task*)
&amp;quot;runner thread&amp;quot;

POFTHEDAY&amp;gt; (defvar *second-task*
             (make-instance
              &amp;#039;simple-tasks:blocking-call-task
              :func #&amp;#039;print-and-return-current-thread))

POFTHEDAY&amp;gt; (simple-tasks:schedule-task *second-task*
                                       *runner*)
Running in &amp;quot;runner thread&amp;quot; thread.

POFTHEDAY&amp;gt; (simple-tasks:return-values *second-task*)
&amp;quot;runner thread&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also a few shortcuts:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (simple-tasks:call-as-task #&amp;#039;print-and-return-current-thread
                                      *runner*)
Running in &amp;quot;runner thread&amp;quot; thread.
&amp;quot;runner thread&amp;quot;

;; Or

POFTHEDAY&amp;gt; (simple-tasks:with-body-as-task (*runner*)
             (print-and-return-current-thread))
Running in &amp;quot;runner thread&amp;quot; thread.
&amp;quot;runner thread&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library can be useful when you are working with some subsystems or external libraries which should be accessed only from the single thread.&lt;/p&gt;
&lt;p&gt;For example, &lt;a href=&quot;https://common-lisp.net/project/rcl/&quot;&gt;RCL&lt;/a&gt; (CL interface to the R language) library uses it to interop with &lt;a href=&quot;https://www.r-project.org/&quot;&gt;R language&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are interested in other solutions for multithreading and multiprocessing, look at #poftheday posts grouped by corresponding tags:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/tags/threads.html&quot;&gt;threads&lt;/a&gt;;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/tags/multiprocessing.html&quot;&gt;multiprocessing&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;
</description>
            <pubDate>Mon, 17 Aug 2020 23:27:19 +0300</pubDate>
        </item>
        <item>
            <title>trivial-string-template</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0163-trivial-string-template.html</link>
            <description>&lt;p&gt;This is a simple templating engine. It will be useful if you want to use user&apos;s input as the templates and dont want to give a user the full power of Lisp&apos;s &lt;code&gt;format&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;There is a function which replaces placeholders in the template:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (trivial-string-template:substitute &amp;quot;$who likes $what&amp;quot;
                                               :who &amp;quot;Bob&amp;quot;
                                               :what &amp;quot;Common Lisp&amp;quot;)
&amp;quot;Bob likes Common Lisp&amp;quot;

;; Also, you can use curly braces around the placeholder:

POFTHEDAY&amp;gt; (trivial-string-template:substitute &amp;quot;${who} likes ${what}&amp;quot;
                                               :who &amp;quot;Bob&amp;quot;
                                               :what &amp;quot;Common Lisp&amp;quot;)
&amp;quot;Bob likes Common Lisp&amp;quot;

;; If some variable wasn&amp;#039;t given, it will raise an error:

POFTHEDAY&amp;gt; (trivial-string-template:substitute &amp;quot;${who} likes ${what}&amp;quot;
                                               :who &amp;quot;Bob&amp;quot;)
; Debugger entered on #&amp;lt;SIMPLE-ERROR &amp;quot;Missing variable ~A~A information.&amp;quot; {100687A6C3}&amp;gt;

;; But there is a safe version of the function which just ignores:

POFTHEDAY&amp;gt; (trivial-string-template:safe-substitute &amp;quot;${who} likes ${what}&amp;quot;
                                                    :who &amp;quot;Bob&amp;quot;)
&amp;quot;Bob likes $what&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you can define a template object. It will be funcallable and can be used in two ways.&lt;/p&gt;
&lt;p&gt;The first way - to create a template object and funcall it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (trivial-string-template:template &amp;quot;${who} likes ${what}&amp;quot;)
#&amp;lt;TRIVIAL-STRING-TEMPLATE:TEMPLATE {10076CA14B}&amp;gt;

POFTHEDAY&amp;gt; (funcall *
                    :who &amp;quot;Bob&amp;quot;
                    :what &amp;quot;Common Lisp&amp;quot;)
&amp;quot;Bob likes Common Lisp&amp;quot;

POFTHEDAY&amp;gt; (funcall **
                    :who &amp;quot;Mary&amp;quot;
                    :what &amp;quot;Common Lisp&amp;quot;)
&amp;quot;Mary likes Common Lisp&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The second way is to define a function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (trivial-string-template:define-template who-&amp;#x2665;&amp;#xFE0F;-what ()
                                                    &amp;quot;${who} likes ${what}&amp;quot;)
#&amp;lt;TRIVIAL-STRING-TEMPLATE:TEMPLATE {100635045B}&amp;gt;

POFTHEDAY&amp;gt; (describe &amp;#039;who-&amp;#x2665;&amp;#xFE0F;-what)

POFTHEDAY::WHO-&amp;#x2665;&amp;#xFE0F;-WHAT
  [symbol]

WHO-&amp;#x2665;&amp;#xFE0F;-WHAT names a compiled function:
  Lambda-list: (&amp;amp;KEY (WHO NIL WHO-SUPPLIED-P)
                (WHAT NIL WHAT-SUPPLIED-P))
  Derived type: (FUNCTION (&amp;amp;KEY (:WHO T) (:WHAT T))
                 (VALUES SIMPLE-STRING &amp;amp;OPTIONAL))
  Source form:
    (LAMBDA (&amp;amp;KEY (WHO NIL WHO-SUPPLIED-P) (WHAT NIL WHAT-SUPPLIED-P))
      (PROGN
       (UNLESS WHO-SUPPLIED-P
         (ERROR
          #1=&amp;quot;The variable ~A~A is not supplied, which must be supplied in non-safe mode.&amp;quot;
          #\$ &amp;quot;who&amp;quot;))
       (UNLESS WHAT-SUPPLIED-P (ERROR #1# #\$ &amp;quot;what&amp;quot;))
       (FORMAT NIL &amp;quot;~A likes ~A&amp;quot; WHO WHAT)))

POFTHEDAY&amp;gt; (who-&amp;#x2665;&amp;#xFE0F;-what :who &amp;quot;Bob&amp;quot; :what &amp;quot;LISP&amp;quot;)
&amp;quot;Bob likes LISP&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;What is interesting is that the template object uses this meta class: &lt;code&gt;closer-mop:funcallable-standard-class&lt;/code&gt;. It makes possible to create instances which can be called the same way as the functions.&lt;/p&gt;
&lt;p&gt;Here is an example of how to make a class for which instances will be funcallable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass foo ()
             ()
             (:metaclass closer-mop:funcallable-standard-class))
#&amp;lt;SB-MOP:FUNCALLABLE-STANDARD-CLASS POFTHEDAY::FOO&amp;gt;

POFTHEDAY&amp;gt; (defmethod initialize-instance :after ((this foo) &amp;amp;key)
             (closer-mop:set-funcallable-instance-function
              this
              (lambda ()
                (format t &amp;quot;Hello Lisp World!~%&amp;quot;))))
#&amp;lt;STANDARD-METHOD COMMON-LISP:INITIALIZE-INSTANCE :AFTER (FOO) {10020B09B3}&amp;gt;

POFTHEDAY&amp;gt; (make-instance &amp;#039;foo)
#&amp;lt;FOO {10020B585B}&amp;gt;

POFTHEDAY&amp;gt; (funcall *)
Hello Lisp World!
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Such objects can be used instead of closure in cases where you will need to redefine some of the instance slots after the object was created.&lt;/p&gt;
&lt;p&gt;Ok, now it is time to say goodbye. See you tomorrow in the next #poftheday post!&lt;/p&gt;
</description>
            <pubDate>Sun, 16 Aug 2020 21:56:15 +0300</pubDate>
        </item>
        <item>
            <title>shuffletron</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0162-shuffletron.html</link>
            <description>&lt;p&gt;Shuffletron is a console music player. Today there will not be much of code, because I wasn&apos;t able to run this player on OSX. It crashes inside a &lt;code&gt;libao&lt;/code&gt; C library:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;[poftheday] qlot exec ./shuffletron.ros
This is Shuffletron 0.0.5
Library contains 1 files.
        0 Baby Gramps, Rogue&amp;#039;s Gallery: Pirate Ballads, Sea Songs, and Chanteys,  1: Cape Cod Girls
library&amp;gt;
Unhandled DIVISION-BY-ZERO in thread #&amp;lt;SB-THREAD:THREAD &amp;quot;Mixer thread 44,100 Hz&amp;quot; RUNNING
                                        {1001593EA3}&amp;gt;:
  arithmetic error DIVISION-BY-ZERO signalled

Backtrace for: #&amp;lt;SB-THREAD:THREAD &amp;quot;Mixer thread 44,100 Hz&amp;quot; RUNNING {1001593EA3}&amp;gt;
0: (&amp;quot;bogus stack frame&amp;quot;)
1: (&amp;quot;foreign function: _ZN17SincKernelFactory19ReferenceSincKernelEiidd&amp;quot;)
2: (&amp;quot;foreign function: _ZN10Resampler2C2Eddiiidb&amp;quot;)
3: (&amp;quot;foreign function: _ZN19SampleRateConverter16ReplaceResamplerEv&amp;quot;)
4: (&amp;quot;foreign function: _ZN19PCMConverterFactory6AddSRCER14StreamDescPairRK18ChainBuildSettingsRNSt3__16vectorIP22BufferedAudioConverterNS5_9allocatorIS8_EEEE&amp;quot;)
5: (&amp;quot;foreign function: _ZN19PCMConverterFactory19BuildConverterChainERK14StreamDescPairRK18ChainBuildSettingsP19AudioConverterChainPS_&amp;quot;)
6: (&amp;quot;foreign function: _AudioConverterNewInternal&amp;quot;)
7: (&amp;quot;foreign function: DefaultOutputAUFactory&amp;quot;)
8: (&amp;quot;foreign function: DefaultOutputAUFactory&amp;quot;)
9: (&amp;quot;foreign function: DefaultOutputAUFactory&amp;quot;)
10: (&amp;quot;foreign function: DefaultOutputAUFactory&amp;quot;)
11: (&amp;quot;foreign function: DefaultOutputAUFactory&amp;quot;)
12: (&amp;quot;foreign function: DefaultOutputAUFactory&amp;quot;)
13: (&amp;quot;foreign function: ao_plugin_open&amp;quot;)
14: (&amp;quot;foreign function: _open_device&amp;quot;)
15: (MIXALOT::AO-OPEN-LIVE :INVALID-VALUE-FOR-UNESCAPED-REGISTER-STORAGE #.(SB-SYS:INT-SAP #X06043FE0) :INVALID-VALUE-FOR-UNESCAPED-REGISTER-STORAGE)
16: (MIXALOT::OPEN-AO :RATE 44100)
17: ((LAMBDA NIL :IN MIXALOT:CREATE-MIXER))
18: ((LABELS BORDEAUX-THREADS::%BINDING-DEFAULT-SPECIALS-WRAPPER :IN BORDEAUX-THREADS::BINDING-DEFAULT-SPECIALS))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how it should look like when up and running:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0162/shuffletron.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;The only thing I can share right now is this small Roswell script I&apos;ve used instead of overcomplicated Shuffletron&apos;s build scripts:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 &amp;quot;$@&amp;quot;
|#
(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp
  (ql:quickload &amp;#039;(:shuffletron)
                :silent t))

(defpackage :ros.script.shuffletron
  (:use :cl))
(in-package :ros.script.shuffletron)


(defun main (&amp;amp;rest argv)
  (declare (ignorable argv))
  (shuffletron:run))

;;; vim: set ft=lisp lisp:&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With this script you&apos;ll be able to run the program as &lt;code&gt;./shuffletron.ros&lt;/code&gt; or to build a binary with &lt;code&gt;ros build shuffletron.ros&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;On OSX you have to do &lt;code&gt;brew install libao&lt;/code&gt; to install required C library.&lt;/p&gt;
&lt;p&gt;Please, try it on your system whether it is OSX or Linux and let me know it started successfuly.&lt;/p&gt;
</description>
            <pubDate>Sat, 15 Aug 2020 23:31:00 +0300</pubDate>
        </item>
        <item>
            <title>cl-svg</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0161-cl-svg.html</link>
            <description>&lt;p&gt;This is a library for SVG generation. It has &lt;a href=&quot;https://github.com/wmannis/cl-svg/blob/master/docs/API.md&quot;&gt;nice documentation&lt;/a&gt;. I will show only a simple example of how to create the SVG with a circle filled with the gradient:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-svg:with-svg-to-file (svg &amp;#039;cl-svg:svg-1.1-toplevel :height 200 :width 200)
               (&amp;quot;docs/media/0161/test.svg&amp;quot; :if-exists :supersede)
             (cl-svg:draw svg
                 (:circle :cx 100 :cy 100 :r 100)
                 :fill (cl-svg:xlink-href
                        (cl-svg:make-linear-gradient svg
                            (:id :fill
                             :x1 &amp;quot;0%&amp;quot; :y1 &amp;quot;0%&amp;quot;
                             :x2 &amp;quot;100%&amp;quot; :y2 &amp;quot;100%&amp;quot;)
                          (cl-svg:stop :color &amp;quot;red&amp;quot; :offset &amp;quot;0%&amp;quot;)
                          (cl-svg:stop :color &amp;quot;blue&amp;quot; :offset &amp;quot;100%&amp;quot;)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the result:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;xml&apos;&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; standalone=&amp;quot;no&amp;quot;?&amp;gt;
&amp;lt;!DOCTYPE svg PUBLIC &amp;quot;-//W3C//DTD SVG 1.1//EN&amp;quot; 
  &amp;quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&amp;quot;&amp;gt;
&amp;lt;svg width=&amp;quot;200&amp;quot; height=&amp;quot;200&amp;quot; version=&amp;quot;1.1&amp;quot; id=&amp;quot;toplevel&amp;quot;
    xmlns=&amp;quot;http://www.w3.org/2000/svg&amp;quot;
    xmlns:xlink=&amp;quot;http://www.w3.org/1999/xlink&amp;quot;&amp;gt;
  &amp;lt;defs&amp;gt;
    &amp;lt;linearGradient id=&amp;quot;FILL&amp;quot; x1=&amp;quot;0%&amp;quot; y1=&amp;quot;0%&amp;quot; x2=&amp;quot;100%&amp;quot; y2=&amp;quot;100%&amp;quot;&amp;gt;
      &amp;lt;stop stop-color=&amp;quot;red&amp;quot; stop-opacity=&amp;quot;1.00&amp;quot; offset=&amp;quot;0%&amp;quot;/&amp;gt;
      &amp;lt;stop stop-color=&amp;quot;blue&amp;quot; stop-opacity=&amp;quot;1.00&amp;quot; offset=&amp;quot;100%&amp;quot;/&amp;gt;
    &amp;lt;/linearGradient&amp;gt;
  &amp;lt;/defs&amp;gt;
  &amp;lt;circle cx=&amp;quot;100&amp;quot; cy=&amp;quot;100&amp;quot; r=&amp;quot;100&amp;quot; fill=&amp;quot;url(#FILL)&amp;quot;/&amp;gt;
&amp;lt;/svg&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;img src=&quot;../../media/0161/test.svg&quot; /&gt;&lt;p&gt;There are more drawing primitives covered by the documentation. Read the docs and create more interesting pictures. Also, you can combine these SVGs with JS code produced by &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0071-parenscript.html&quot;&gt;Parenscript&lt;/a&gt;, to create interactive graphics!&lt;/p&gt;
</description>
            <pubDate>Fri, 14 Aug 2020 23:39:13 +0300</pubDate>
        </item>
        <item>
            <title>moira</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/08/0160-moira.html</link>
            <description>&lt;p&gt;This small library, made by &lt;a href=&quot;https://twitter.com/ruricolist&quot;&gt;@ruricolist&lt;/a&gt;, implements an abstraction over &lt;code&gt;bordeaux-threads&lt;/code&gt;. It is able to restart threads in case of errors. &lt;code&gt;Moira&lt;/code&gt; monitors all started threads.&lt;/p&gt;
&lt;p&gt;In the next example, I&apos;m creating a thread which runs 5 iterations and fails. When the same thread restarted, it ends without an error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (moira:start-monitor)

POFTHEDAY&amp;gt; (let ((num-attempts 1))
             (moira:spawn &amp;quot;Counter&amp;quot;
                (format t &amp;quot;Starting the thread~%&amp;quot;)
                (loop for i from 0 upto 5
                      do (format t &amp;quot;Iteration ~A~%&amp;quot; i)
                         (sleep 1)
                      finally (when (&amp;gt; num-attempts 0)
                                (decf num-attempts)
                                (format t &amp;quot;Exiting with error~%&amp;quot;)
                                (error &amp;quot;Some shit happened!&amp;quot;)))))
Starting the thread
Iteration 0
#&amp;lt;SB-THREAD:THREAD &amp;quot;Counter&amp;quot; RUNNING {10028CBD93}&amp;gt;
#&amp;lt;MOIRA::MONITORED-THREAD Counter&amp;gt;
Iteration 1
Iteration 2
Iteration 3
Iteration 4
Iteration 5
Exiting with error

Starting the thread
Iteration 0
Iteration 1
Iteration 2
Iteration 3
Iteration 4
Iteration 5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Without &lt;code&gt;num-attempts&lt;/code&gt; trick, a thread will be restarted eternally. This is useful for long-running threads which should be kept alive.&lt;/p&gt;
</description>
            <pubDate>Thu, 13 Aug 2020 22:04:49 +0300</pubDate>
        </item>
    </channel>
</rss>