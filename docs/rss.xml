<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>the-cost-of-nothing</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0100-the-cost-of-nothing.html</link>
            <description>&lt;p&gt;This is a library by Marco Heisig. It is convenient to use when you want to decide which data structure to use or whether some function is too slow.&lt;/p&gt;
&lt;p&gt;Of cause, you can measure execution time with the &lt;code&gt;time&lt;/code&gt; macro. But in this case, you&apos;ll have to select a number of iteration and to parse &lt;code&gt;time&lt;/code&gt;&apos;s output and do some time manipulation.&lt;/p&gt;
&lt;p&gt;The-cost-of-nothing does everything for you. It runs given form in chunks, measures an execution time for each chunk, divides and calculates average execution time.&lt;/p&gt;
&lt;p&gt;Let&apos;s see how long does it take to access an element in the hash-table.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (time
              (loop repeat 1000000000
                    do (gethash :foo h))))
Evaluation took:
  0.271 seconds of real time
  0.270554 seconds of total run time (0.270170 user, 0.000384 system)
  100.00% CPU
  597,543,804 processor cycles
  0 bytes consed

;; Now we have to calculate a speed of the
;; single operation:
POFTHEDAY&amp;gt; (/ 0.271
              1000000000)
2.71e-10&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I had to guess a number of iteration to get meaningful execution time and also did some arithmetics after that.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:benchmark
              (gethash :foo h)))
1.11d-8

;; You also can receive a human readable value:
POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:bench
              (gethash :foo h)))
11.36 nanoseconds&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we see result 11 nanoseconds, however with &lt;code&gt;time&lt;/code&gt; macro we received only 0.271 nanoseconds. Probably this is because the overhead introduced by &lt;code&gt;the-cost-of-nothing&lt;/code&gt;. It tries to subtract overhead time from the result, but seems it does works for very fast operations.&lt;/p&gt;
&lt;p&gt;In case if you are measuring the cost of very fast operations it is better to make a loop even when using the-cost-of-nothing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (/ (the-cost-of-nothing:benchmark
                 (loop repeat 1000
                       do (gethash :foo h)))
                1000))
2.59d-10&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;How does &lt;code&gt;benchmark&lt;/code&gt; macro work?&lt;/p&gt;
&lt;p&gt;It has two parameters: &lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;min-sample-time&lt;/code&gt;. A tested form gets wrapped into the lambda function and executed in the loop a number of times to measure samples.&lt;/p&gt;
&lt;p&gt;On each iteration, the form is executed in another loop where the number of iterations is automatically tuned to make this inner loop run no less than &lt;code&gt;min-sample-time&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After that, an average overall sampled times is calculated and &lt;code&gt;overhead&lt;/code&gt; time is subtracted. Overhead time is precalculated as the cost of nil form execution.&lt;/p&gt;
&lt;p&gt;On my system, overhead value is 2.7e-9.&lt;/p&gt;
&lt;p&gt;I tried to rewrite the function which measures a sample&apos;s time to make the calculation fairer, but without significant result.&lt;/p&gt;
&lt;p&gt;Here is what I&apos;ve got:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun sample-execution-time-of-thunk (thunk min-sample-time)
  &amp;quot;Measure the execution time of invoking THUNK more and more often, until
the execution time exceeds MIN-SAMPLE-TIME.&amp;quot;
  (declare (optimize (speed 3) (debug 1)))
  
  (loop with started-at of-type integer = (get-internal-run-time)
        with run-until of-type integer = (+ started-at
                                             (round (* min-sample-time
                                                       internal-time-units-per-second)))
        for iterations of-type integer = 1 then (* iterations 2)
        summing iterations into total-iterations
        do (loop repeat iterations
                 do (funcall thunk))
        when (&amp;gt;= (get-internal-run-time)
                 run-until)
          do (return (/ (- (get-internal-run-time)
                            started-at)
                        internal-time-units-per-second
                        total-iterations))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I removed a call to an additional function and to &lt;code&gt;local-time:timestamp-difference&lt;/code&gt;, but result is not much better - only 10.71 nanoseconds.&lt;/p&gt;
&lt;p&gt;Am I missing something? Maybe compiler does some optimizations, when it sees a gethash call in a loop which does not change the dict?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:bench
              (gethash :foo h)))
10.71 nanoseconds&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another interesting thing about &lt;code&gt;the-cost-of-nothing&lt;/code&gt; is that it includes a benchmark which measures some the cost of some common operations.&lt;/p&gt;
&lt;p&gt;Even if they are not precise, it is interesting to compare their relative values. Here are numbers received on my Macbook Pro.&lt;/p&gt;
&lt;p&gt;Pay attention to how does cost grow for calling the function with multiple keyword arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (asdf:test-system :the-cost-of-nothing)

= The Cost Of Nothing =
Implementation: SBCL 2.0.2
Machine: X86-64 Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
Hostname: art-2osx

== Memory Management ==
Cost of allocating a cons cell: 6.76 nanoseconds
Cost of garbage collection: 10.68 milliseconds
Cost of full garbage collection: 107.05 milliseconds

== Functions ==
FUNCALL with zero mandatory arguments: 2.71 nanoseconds
FUNCALL with one mandatory argument: 2.68 nanoseconds
FUNCALL with two mandatory arguments: 2.52 nanoseconds
FUNCALL with three mandatory arguments: 2.43 nanoseconds
FUNCALL with four mandatory arguments: 2.74 nanoseconds
FUNCALL with five mandatory arguments: 2.62 nanoseconds
FUNCALL with six mandatory arguments: 2.78 nanoseconds
FUNCALL with zero optional arguments: 2.71 nanoseconds
FUNCALL with one optional argument: 3.24 nanoseconds
FUNCALL with two optional arguments: 3.00 nanoseconds
FUNCALL with three optional arguments: 3.23 nanoseconds
FUNCALL with four optional arguments: 3.09 nanoseconds
FUNCALL with five optional arguments: 3.42 nanoseconds
FUNCALL with six optional arguments: 3.38 nanoseconds
FUNCALL with zero keyword arguments: 2.71 nanoseconds
FUNCALL with one keyword argument: 5.35 nanoseconds
FUNCALL with two keyword arguments: 5.76 nanoseconds
FUNCALL with three keyword arguments: 8.34 nanoseconds
FUNCALL with four keyword arguments: 12.45 nanoseconds
FUNCALL with five keyword arguments: 14.88 nanoseconds
FUNCALL with six keyword arguments: 17.58 nanoseconds
FUNCALL with zero rest arguments: 2.71 nanoseconds
FUNCALL with one rest argument: 2.65 nanoseconds
FUNCALL with two rest arguments: 2.53 nanoseconds
FUNCALL with three rest arguments: 2.48 nanoseconds
FUNCALL with four rest arguments: 2.79 nanoseconds
FUNCALL with five rest arguments: 2.91 nanoseconds
FUNCALL with six rest arguments: 2.66 nanoseconds

== Numerics ==
Flops (single-float): 4.25 gigaflops
Flops (double-float): 2.71 gigaflops&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I think it would be great to make this library to output some statistics about collected samples - a number of samples, standard deviation, like IPython does:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; python&apos;&gt;Python 3.7.7 (default, Mar 10 2020, 15:43:33)
Type &amp;#039;copyright&amp;#039;, &amp;#039;credits&amp;#039; or &amp;#039;license&amp;#039; for more information
IPython 7.14.0 -- An enhanced Interactive Python. Type &amp;#039;?&amp;#039; for help.

In [1]: d = {&amp;#039;what&amp;#039;: 42}

In [2]: %timeit d[&amp;#039;what&amp;#039;]
35.7 ns &amp;#xB1; 0.405 ns per loop (mean &amp;#xB1; std. dev. of 7 runs, 10000000 loops each)

In [3]:&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Mon, 15 Jun 2020 22:19:19 +0300</pubDate>
        </item>
        <item>
            <title>teddy</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0099-teddy.html</link>
            <description>&lt;p&gt;I always wanted to work from Common Lisp with data like we do in Python. That is how does Teddy born.&lt;/p&gt;
&lt;p&gt;Teddy make it possible to define a data frame full of data, to slice it in different ways, to join data frames, see some statistics about the data and render plots.&lt;/p&gt;
&lt;p&gt;This is a proof of the concept and API will be changed. Check the ChangeLog.md to learn about new abilities and refactoring details.&lt;/p&gt;
&lt;p&gt;Here is how we can create a simple data frame:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/data-frame:make-data-frame
            &amp;#039;(&amp;quot;Idx&amp;quot; &amp;quot;Integers&amp;quot; &amp;quot;Uniform floats&amp;quot; &amp;quot;Gaussian&amp;quot;)
            :rows
            (loop repeat 10
                  for idx upfrom 0
                  collect (list idx
                                (random 100)
                                (random 1.0)
                                (statistics:random-normal
                                 :mean 5.0
                                 :sd 0.2))))
+-----+----------+----------------+----------+
| Idx | Integers | Uniform floats | Gaussian |
+-----+----------+----------------+----------+
|   0 |       41 |           0.27 |   4.89d0 |
|   1 |       98 |           0.08 |   4.93d0 |
|   2 |        8 |           0.45 |   5.15d0 |
|   3 |       56 |           0.63 |   4.87d0 |
|   4 |       79 |           0.42 |   4.72d0 |
|   5 |       19 |           0.04 |   4.73d0 |
|   6 |        1 |           0.34 |   4.93d0 |
|   7 |       79 |           0.60 |   5.25d0 |
|   8 |       42 |           0.08 |   5.10d0 |
|   9 |        7 |           0.86 |   5.31d0 |
+-----+----------+----------------+----------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can slice it by columns, rows or both:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/data-frame:head *d* 2)
+-----+----------+----------------+----------+
| Idx | Integers | Uniform floats | Gaussian |
+-----+----------+----------------+----------+
|   0 |       41 |           0.27 |   4.89d0 |
|   1 |       98 |           0.08 |   4.93d0 |
+-----+----------+----------------+----------+
POFTHEDAY&amp;gt; (teddy/data-frame:tail *d* 2)
+-----+----------+----------------+----------+
| Idx | Integers | Uniform floats | Gaussian |
+-----+----------+----------------+----------+
|   8 |       42 |           0.08 |   5.10d0 |
|   9 |        7 |           0.86 |   5.31d0 |
+-----+----------+----------------+----------+
POFTHEDAY&amp;gt; (teddy/data-frame:slice
            *d*
            :columns &amp;#039;(&amp;quot;idx&amp;quot; &amp;quot;gaussian&amp;quot;))
+-----+----------+
| Idx | Gaussian |
+-----+----------+
|   0 |   4.89d0 |
|   1 |   4.93d0 |
|   2 |   5.15d0 |
|   3 |   4.87d0 |
|   4 |   4.72d0 |
|   5 |   4.73d0 |
|   6 |   4.93d0 |
|   7 |   5.25d0 |
|   8 |   5.10d0 |
|   9 |   5.31d0 |
+-----+----------+
POFTHEDAY&amp;gt; (teddy/data-frame:slice *d*
            :columns &amp;#039;(&amp;quot;idx&amp;quot; &amp;quot;gaussian&amp;quot;)
            :from 4
            :to 6)
+-----+----------+
| Idx | Gaussian |
+-----+----------+
|   4 |   4.72d0 |
|   5 |   4.73d0 |
+-----+----------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, we might want to see some descriptive statistical data about our data frame. This is pretty easy with Teddy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/stats:stats *d*)
+----------------+--------+--------+--------+--------+--------+-------+-------+---------+
| Column         | Min    | p25    | p50    | p75    | Max    | Mean  | SD    | Sum     |
+----------------+--------+--------+--------+--------+--------+-------+-------+---------+
| Idx            |      0 |      2 |   4.50 |      7 |      9 |  4.50 |  3.03 |      45 |
| Integers       |      1 |      8 |  41.50 |     79 |     98 | 43.00 | 34.40 |     430 |
| Uniform floats |   0.04 |   0.08 |   0.38 |   0.60 |   0.86 |  0.38 |  0.27 |    3.75 |
| Gaussian       | 4.72d0 | 4.87d0 | 4.93d0 | 5.15d0 | 5.31d0 |  4.99 |  0.20 | 49.88d0 |
+----------------+--------+--------+--------+--------+--------+-------+-------+---------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Probably, we can make some extandable protocol to calculate other properties.&lt;/p&gt;
&lt;p&gt;Data frame stores data as columns. Each column is a vector of a particular type. If you want to process a row, you can create an iterator and use it to go through rows like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (loop with iterator = (teddy/data-frame:make-iterator *d*)
                 for row = (funcall iterator)
                 while row
                 do (format t &amp;quot;Row: ~S~%&amp;quot;
                            row))
Row: (0 41 0.26806116 4.887522971759381d0)
Row: (1 98 0.081421256 4.928584134866222d0)
Row: (2 8 0.45165908 5.147222819038834d0)
Row: (3 56 0.62647486 4.874349648519968d0)
Row: (4 79 0.41671002 4.7239718274963485d0)
Row: (5 19 0.04152584 4.727268395019779d0)
Row: (6 1 0.3369373 4.93339303609316d0)
Row: (7 79 0.59791017 5.2466443304900965d0)
Row: (8 42 0.076958776 5.103448455243024d0)
Row: (9 7 0.85732913 5.310498824093041d0)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Plotting facilities as rudimentary, but should be improved.. All functions related to plotting are in the &lt;code&gt;teddy/plot&lt;/code&gt; package. Right now &lt;code&gt;GNUPlot&lt;/code&gt; is used via &lt;a href=&quot;http://quickdocs.org/eazy-gnuplot/&quot;&gt;eazy-gnuplot&lt;/a&gt; library.&lt;/p&gt;
&lt;p&gt;Here is how we can plot our data from all columns:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/plot:plot *d*
            &amp;quot;docs/media/0099/simple-plot.png&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0099/simple-plot.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;If we want to plot only gaussian, then it will be wrong, because we need a histogram type of plot. This feature is &quot;to be done&quot;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/plot:plot
            (teddy/data-frame:slice *d*
                                    :columns &amp;#039;(&amp;quot;Idx&amp;quot; &amp;quot;Gaussian&amp;quot;))
            &amp;quot;docs/media/0099/gaussian.png&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0099/gaussian.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Another type of plots &lt;code&gt;Teddy&lt;/code&gt; is able to render right now is a &quot;timeseries&quot;.&lt;/p&gt;
&lt;p&gt;Let&apos;s plot how does Moscow&apos;s population was changed over years:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *moscow-population*
             (teddy/data-frame:make-data-frame
              &amp;#039;(&amp;quot;Date&amp;quot; &amp;quot;Population&amp;quot;)
              :rows &amp;#039;((&amp;quot;1350-01-01&amp;quot; 30000)
                      (&amp;quot;1840-01-01&amp;quot; 349000)
                      (&amp;quot;1907-01-01&amp;quot; 1345700)
                      (&amp;quot;1967-01-01&amp;quot; 6422000)
                      (&amp;quot;1994-01-01&amp;quot; 9066000)
                      (&amp;quot;2010-01-01&amp;quot; 11500000)
                      (&amp;quot;2020-01-01&amp;quot; 12680000))))
*MOSCOW-POPULATION*
POFTHEDAY&amp;gt; (teddy/plot:plot-timeseries
            *moscow-population* &amp;quot;docs/media/0099/moscow2.png&amp;quot;
            :title &amp;quot;Moscow population&amp;quot;)
&amp;quot;docs/media/0099/moscow.png&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0099/moscow.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Right now, Teddy installable only from Ultralisp, because it is the best place to host unstable fast-changing Common Lisp libraries.&lt;/p&gt;
&lt;p&gt;Join the effort to make &lt;code&gt;Teddy&lt;/code&gt; really useful for data analysis!&lt;/p&gt;
&lt;p&gt;Send your pull-requests to:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/40ants/teddy&quot;&gt;https://github.com/40ants/teddy&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Sun, 14 Jun 2020 23:31:39 +0300</pubDate>
        </item>
        <item>
            <title>cl-store</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0098-cl-store.html</link>
            <description>&lt;p&gt;I use this library in a few of my projects. It is much like Python&apos;s &lt;a href=&quot;https://docs.python.org/3/library/pickle.html&quot;&gt;pickle module&lt;/a&gt;, but a lot more extensible.&lt;/p&gt;
&lt;p&gt;CL-Store is able to store and restore back almost any Lisp object. For example, &lt;code&gt;lfarm&lt;/code&gt;, &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0094-lfarm.html&quot;&gt;reviewed four days ago&lt;/a&gt; uses it to serialize and deserialize parameters when executing remote jobs on the server.&lt;/p&gt;
&lt;p&gt;To demonstrate how it works, I&apos;ll create a vector of objects. Then we&apos;ll save this vector to the file and restore it back:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ((name :initarg :name
                    :reader user-name)))

POFTHEDAY&amp;gt; (defmethod print-object ((user user) stream)
             (print-unreadable-object (user stream :type t)
               (format stream &amp;quot;~A&amp;quot;
                       (user-name user))))

POFTHEDAY&amp;gt; (defparameter *users*
             (make-array 2
                         :initial-contents
                         (list (make-instance &amp;#039;user :name &amp;quot;Bob&amp;quot;)
                               (make-instance &amp;#039;user :name &amp;quot;Alice&amp;quot;))))

POFTHEDAY&amp;gt; *users*
#(#&amp;lt;USER Bob&amp;gt; #&amp;lt;USER Alice&amp;gt;)

;; Now we are ready to store our data to the file
POFTHEDAY&amp;gt; (cl-store:store *users* #P&amp;quot;/tmp/users.bin&amp;quot;)

;; and to restore it back:
POFTHEDAY&amp;gt; (cl-store:restore #P&amp;quot;/tmp/users.bin&amp;quot;)
#(#&amp;lt;USER Bob&amp;gt; #&amp;lt;USER Alice&amp;gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the resulting file. Don&apos;t be deceived by the readable content. This is the binary format and it might contain nonreadable characters:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; text&apos;&gt;[art@poftheday] cat /tmp/users.bin
CLCL
#USER#  POFTHEDAY
#NAMEBobAlice&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CL-Store can be extended. Originally it also provided a backend to serialize data into the XML. But now this backend is considered as deprecated.&lt;/p&gt;
&lt;p&gt;Previously I didn&apos;t write backends for CL-Store, but today I found in its docs an example, &lt;a href=&quot;https://common-lisp.net/project/cl-store/docs/cl-store_5.html#SEC19&quot;&gt;how to write a backend&lt;/a&gt;, compatible with  Python&apos;s pickle.&lt;/p&gt;
&lt;p&gt;Documentation is 13 years old, let&apos;s see if we&apos;ll be able to reproduce it!&lt;/p&gt;
&lt;p&gt;First, we need to define a new backend:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-store:defbackend pickle
             :stream-type &amp;#039;character)
#&amp;lt;PICKLE {100369EBB3}&amp;gt;

;; This small call expands into this huge amount of code:

(eval-when (:load-toplevel :execute)
  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defclass pickle (cl-store:backend) nil
              (:documentation
               &amp;quot;Autogenerated cl-store class for backend pickle.&amp;quot;))
    (defmacro defstore-pickle
              ((cl-store::var type stream &amp;amp;optional cl-store::qualifier)
               &amp;amp;body cl-store::body)
      (cl-store::with-gensyms (cl-store::gbackend)
        `(defmethod cl-store:internal-store-object ,@(if cl-store::qualifier
                                                         (list
                                                          cl-store::qualifier)
                                                         nil)
                    ((,cl-store::gbackend ,&amp;#039;pickle) (,cl-store::var ,type)
                     ,stream)
           ,(format nil &amp;quot;Definition for storing an object of type ~A with ~
 backend ~A&amp;quot;
                    type &amp;#039;pickle)
           (declare (ignorable ,cl-store::gbackend))
           ,@cl-store::body)))
    (defmacro defrestore-pickle
              ((type cl-store::place &amp;amp;optional cl-store::qualifier)
               &amp;amp;body cl-store::body)
      (cl-store::with-gensyms (cl-store::gbackend cl-store::gtype)
        `(defmethod cl-store::internal-restore-object ,@(if cl-store::qualifier
                                                            (list
                                                             cl-store::qualifier)
                                                            nil)
                    ((,cl-store::gbackend ,&amp;#039;pickle)
                     (,cl-store::gtype (eql &amp;#039;,type)) (,cl-store::place t))
           (declare (ignorable ,cl-store::gbackend ,cl-store::gtype))
           ,@cl-store::body))))
  (cl-store::register-backend &amp;#039;pickle &amp;#039;pickle nil &amp;#039;character &amp;#039;nil &amp;#039;nil))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use &lt;code&gt;defstore-pickle&lt;/code&gt; and &lt;code&gt;defrestore-pickle&lt;/code&gt; macroses to define rules for the processing of different data types.&lt;/p&gt;
&lt;p&gt;Here is where all real work is done:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *pickle-mapping*
             &amp;#039;((#\S . string))
             &amp;quot;A mapping from Pickle&amp;#039;s char codes
              to a Lisp data type&amp;quot;)

POFTHEDAY&amp;gt; (defmethod cl-store:get-next-reader ((backend pickle) (stream stream))
             &amp;quot;This method is responsible for recognizing what
              type of object should be read next.&amp;quot;
             (let ((type-code (read-char stream)))
               (or (cdr (assoc type-code *pickle-mapping*))
                   (values nil (format nil &amp;quot;Type ~A&amp;quot; type-code)))))

POFTHEDAY&amp;gt; (defrestore-pickle (noop stream)
             &amp;quot;We&amp;#039;ll skip unknown objects&amp;quot;)

POFTHEDAY&amp;gt; (defstore-pickle (obj string stream)
             &amp;quot;Here is how string should be written in Pickle&amp;#039;s format.&amp;quot;
             (format stream &amp;quot;S&amp;#039;~A&amp;#039;~%p0~%.&amp;quot; obj))

POFTHEDAY&amp;gt; (defrestore-pickle (string stream)
             &amp;quot;And this is a code to read string back&amp;quot;
             (let ((val (read-line stream)))
               (read-line stream) ;; remove the PUSH op
               (read-line stream) ;; remove the END op
               (subseq val 1 (1- (length val)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is time to test our functions. To make this old example work, I had to use old Python2.7, because Python3&apos;s pickle serializes into a little bit different format.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; python&apos;&gt;[art@poftheday] python2.7

&amp;gt;&amp;gt;&amp;gt; with open(&amp;#039;/tmp/word.pickle&amp;#039;, &amp;#039;w&amp;#039;) as f:
...     pickle.dump(&amp;#039;Hello Lisp World!&amp;#039;, f, protocol=0)
...
&amp;gt;&amp;gt;&amp;gt; ^D

[art@poftheday] cat /tmp/word.pickle
S&amp;#039;Hello Lisp World!&amp;#039;
p0
.

# Here is what I&amp;#039;ve got under Python3:

In [9]: with open(&amp;#039;/tmp/word.pickle&amp;#039;, &amp;#039;bw&amp;#039;) as f:
   ...:     pickle.dump(&amp;#039;Hello Lisp World!&amp;#039;, f, protocol=0)
   ...:

In [10]: !cat /tmp/word.pickle
VHello Lisp World!
p0
.
# This cl-store backend does not support V type code.
# Seems, it stands for a Unicode string.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can read this file from Lisp and write it back:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-store:restore #P&amp;quot;/tmp/word.pickle&amp;quot;
                             &amp;#039;pickle)
&amp;quot;Hello Lisp World!&amp;quot;

POFTHEDAY&amp;gt; (cl-store:store &amp;quot;Howdy, Python!&amp;quot;
                           #P&amp;quot;/tmp/word.pickle&amp;quot;
                           &amp;#039;pickle)
&amp;quot;Howdy, Python!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally, to ensure our backend works as expected, we&apos;ll read this response in Python2:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; python&apos;&gt;&amp;gt;&amp;gt;&amp;gt; import pickle
&amp;gt;&amp;gt;&amp;gt; with open(&amp;#039;/tmp/word.pickle&amp;#039;) as f:
...     pickle.load(f)
...
&amp;#039;Howdy, Python!&amp;#039;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. If you need a time-proved serialization library, check out the CL-Store! To extend it, just read the &lt;a href=&quot;https://common-lisp.net/project/cl-store/docs/cl-store.html&quot;&gt;docs&lt;/a&gt;.&lt;/p&gt;
</description>
            <pubDate>Sat, 13 Jun 2020 23:53:16 +0300</pubDate>
        </item>
        <item>
            <title>sblint</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0097-sblint.html</link>
            <description>&lt;p&gt;Today I want to review not a library but a tool. &lt;code&gt;SBLint&lt;/code&gt; is a program, which can be run from the command-line. It loads your lisp code and outputs all warnings and notes from SBCL compiler.&lt;/p&gt;
&lt;p&gt;I must admit, that SBLint&apos;s output is very readable. You&apos;ll see where you left unused variables or called a function with wrong parameters.&lt;/p&gt;
&lt;p&gt;To show you an example, I&apos;ve added this bad code to one of my libraries:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(declaim (ftype (function (fixnum fixnum)
                          fixnum)
                foo))
(defun foo (a b)
  (+ a 10))


(defun bar ()
  (foo))


(defun blah ()
  (foo 2
       3.14))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code is full of problems :) Let&apos;s see how SBLint will highlight them!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; bash&apos;&gt;[art@poftheday] sblint
src/appenders.lisp:41:0: style-warning: \
    The variable B is defined but never used.
src/appenders.lisp:46:2: simple-warning: \
    The function FOO is called with zero arguments, but wants exactly two.
src/appenders.lisp:50:2: type-warning: \
    Constant 3.14 conflicts with its asserted type FIXNUM.
WARNING: Compilation failed in a system &amp;quot;log4cl-extras&amp;quot;.

# But return code is still SUCCESS:
[art@poftheday] echo $?
0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, all errors are caught. However, &lt;code&gt;SBLint&lt;/code&gt; itself exited with 0 exit code. Because of this, we can&apos;t add it into our CI pipeline.&lt;/p&gt;
&lt;p&gt;I consider this is a bug and will made a pull-request to fix it. Hopefully, the current maintainer will merge it soon:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cxxxr/sblint/pull/19&quot;&gt;https://github.com/cxxxr/sblint/pull/19&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Fri, 12 Jun 2020 23:43:40 +0300</pubDate>
        </item>
        <item>
            <title>cl-reddit</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0096-cl-reddit.html</link>
            <description>&lt;p&gt;This is an API wrapper for Reddit.&lt;/p&gt;
&lt;p&gt;Today I found &lt;a href=&quot;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&quot;&gt;an interesting thread from SpaceX&lt;/a&gt;, where it&apos;s software developers answer the questions. I wondered if there was a discussion around Lisp in the Space?&lt;/p&gt;
&lt;p&gt;But this post has about 8000 comments and I didn&apos;t found a search in a single post&apos;s comments on the Reddit. So, I decided to use &lt;code&gt;cl-reddit&lt;/code&gt; to fetch all post comments and to search through them a &quot;lisp&quot; term.&lt;/p&gt;
&lt;p&gt;Here is how you can connect to the Reddit and list of your subreddits:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *user*
             (cl-reddit:api-login
              :username &amp;quot;svetlyak40wt&amp;quot;
              :password *password*))

;; This is how we can retrieve a list of my subreddits:

POFTHEDAY&amp;gt; (mapcar #&amp;#039;cl-reddit:subreddit-title
                   (cl-reddit::get-reddits-mine *user*))
(&amp;quot;programming&amp;quot; &amp;quot;Lisp Advocates&amp;quot; &amp;quot;Lisp&amp;quot; &amp;quot;Scheme Programming Language articles&amp;quot;
 &amp;quot;M-x emacs-reddit&amp;quot; &amp;quot;Web Startups&amp;quot; &amp;quot;Common Lisp&amp;quot; &amp;quot;Filmmakers&amp;quot; &amp;quot;coding&amp;quot;
 &amp;quot;Github: social coding&amp;quot; &amp;quot;EarthPorn: Amazing images of light and landscape&amp;quot;
 &amp;quot;LISP ja&amp;quot; &amp;quot;Learn Lisp&amp;quot; &amp;quot;Startup Accelerators&amp;quot; &amp;quot;defunkydrummer&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot;
 &amp;quot;Steel Bank Common Lisp&amp;quot;
 &amp;quot;(find-if (alexandria:conjoin #&amp;#039;funny-p #&amp;#039;about-lisp-p) *reddit*)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But we want to run a search in the post comments, right?&lt;/p&gt;
&lt;p&gt;Then we need to extract post id from this link:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&quot;&gt;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;and to fetch comments tree using &lt;code&gt;cl-reddit&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-reddit::get-comments &amp;quot;gxb7j1&amp;quot; *user*)

(#&amp;lt;CL-REDDIT:COMMENT {1002009693}&amp;gt; #&amp;lt;CL-REDDIT:COMMENT {10020098F3}&amp;gt;
 #&amp;lt;CL-REDDIT:COMMENT {1002016BF3}&amp;gt; #&amp;lt;CL-REDDIT:COMMENT {1002016CB3}&amp;gt;
 ...
 #&amp;lt;CL-REDDIT:COMMENT {1002016D73}&amp;gt; #&amp;lt;CL-REDDIT:MORE {1002016E33}&amp;gt;)

POFTHEDAY&amp;gt; (length *)
151&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Well, we received 151 comments, but real comments count is about 7.7k. This is because other items either replies or &lt;code&gt;CL-REDDIT:MORE&lt;/code&gt; objects which contain ids of the replies:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; &apos;&gt;POFTHEDAY&amp;gt; (defparameter *comments*
              (cl-reddit::get-comments &amp;quot;gxb7j1&amp;quot; *user*))

POFTHEDAY&amp;gt; (rutils:last-elt *comments*)
#&amp;lt;CL-REDDIT:MORE {1002016E33}&amp;gt;

POFTHEDAY&amp;gt; (cl-reddit:more-children *)
(&amp;quot;ft35r7m&amp;quot; &amp;quot;ft0rpxi&amp;quot; &amp;quot;ft0jn61&amp;quot; &amp;quot;ft34002&amp;quot; &amp;quot;ft4b6z4&amp;quot;
 ...
 &amp;quot;ft0pado&amp;quot; ...)

POFTHEDAY&amp;gt; (cl-reddit:comment-replies
               (first *comments*))
(#&amp;lt;CL-REDDIT:MORE {1003607093}&amp;gt;)

POFTHEDAY&amp;gt; (cl-reddit:comment-replies
               (second *comments*))
(#&amp;lt;CL-REDDIT:COMMENT {1007607293}&amp;gt;)

POFTHEDAY&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We need to write a comment walker which &lt;code&gt;cl-reddit&lt;/code&gt; does not provide.&lt;/p&gt;
&lt;p&gt;This walker will expand all &lt;code&gt;MORE&lt;/code&gt; items and collect comments into the flat list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((post-id &amp;quot;gxb7j1&amp;quot;))
             (uiop:while-collecting (collect)
               (labels ((visit (item)
                          (etypecase item
                            (cl-reddit:comment
                             (collect item)
                             (mapc #&amp;#039;visit
                                   (cl-reddit:comment-replies
                                    item)))
                            (cl-reddit:more
                             (expand-more item))))
                        (expand-more (more)
                          (loop for id in (cl-reddit:more-children more)
                                for comments = (cl-reddit::get-comments
                                                post-id
                                                *user*
                                                :comment id)
                                do (mapc #&amp;#039;visit
                                         comments))))
                 (mapcar #&amp;#039;visit
                         (cl-reddit::get-comments post-id
                                                  *user*)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When I started this code the first time, it broke my Lisp. A quick investigation showed a resource leak. This library uses &lt;a href=&quot;https://edicl.github.io/drakma/&quot;&gt;Drakma&lt;/a&gt; for data fetching and instead of receiving response bodies, request a stream.&lt;/p&gt;
&lt;p&gt;Drakma&apos;s documentation says, that you might need to close the stream. If you don&apos;t - a connection to the server remains opene.&lt;/p&gt;
&lt;p&gt;Seems, the library&apos;s author never used it for making thousands of requests.&lt;/p&gt;
&lt;p&gt;I&apos;ve fixed this leak, but comments fetching still was too slow - about 2 comments per second. This is because &lt;code&gt;MORE&lt;/code&gt; item contains comment ids and I have to fetch them individually one by one.&lt;/p&gt;
&lt;p&gt;I tried to parallelize the fetching process using lparallel, reviewed two days ago:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *all-comments*
             (let ((post-id &amp;quot;gxb7j1&amp;quot;)
                 (counter 0))
               (uiop:while-collecting (collect)
                 (labels ((visit (item)
                            (etypecase item
                              (cl-reddit:comment
                               (collect item)
                               (incf counter)
                               (when (zerop (mod counter 10))
                                 (log:info &amp;quot;~A comments collected&amp;quot;
                                           counter))
                               (mapc #&amp;#039;visit (cl-reddit:comment-replies item)))
                              (cl-reddit:more
                               (expand-more item))))
                          (expand-more (more)
                            (log:info &amp;quot;Expanding&amp;quot; more)
                            (loop with more-ids = (cl-reddit:more-children more)
                                  with replies = (lparallel:pmapcar
                                                  (lambda (id)
                                                    (cl-reddit::get-comments
                                                     post-id
                                                     *user*
                                                     :comment id))
                                                  more-ids)
                                  for comments in replies
                                  do (lparallel:pmapc #&amp;#039;visit comments))))
                   (lparallel:pmapc #&amp;#039;visit
                           (cl-reddit::get-comments post-id
                                                    *user*))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But encountered these strange errors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;The condition Socket error in &amp;quot;connect&amp;quot;: EINTR (Interrupted system call) occurred with errno: 0.

Condition USOCKET:TIMEOUT-ERROR was signalled.
   [Condition of type USOCKET:TIMEOUT-ERROR]

Restarts:
 0: [TRANSFER-ERROR] Transfer this error to a dependent thread, if one exists.
 1: [KILL-ERRORS] Kill errors in workers (remove debugger instances).
 2: [ABORT] abort thread (#&amp;lt;THREAD &amp;quot;lparallel&amp;quot; RUNNING {10071B3DE3}&amp;gt;)

Backtrace:
 0: (USOCKET::HANDLE-CONDITION #&amp;lt;SB-EXT:TIMEOUT {10059E7C53}&amp;gt; #&amp;lt;USOCKET:STREAM-USOCKET {100871AB43}&amp;gt; &amp;quot;www.reddit.com&amp;quot;)
 1: (SB-KERNEL::%SIGNAL #&amp;lt;SB-EXT:TIMEOUT {10059E7C53}&amp;gt;)
 2: (ERROR SB-EXT:TIMEOUT)
 3: (USOCKET:SOCKET-CONNECT &amp;quot;www.reddit.com&amp;quot; 80 :PROTOCOL :STREAM :ELEMENT-TYPE FLEXI-STREAMS:OCTET :TIMEOUT 20 :DEADLINE NIL :NODELAY :IF-SUPPORTED :LOCAL-HOST NIL :LOCAL-PORT NIL)
 4: (DRAKMA:HTTP-REQUEST #&amp;lt;PURI:URI http://www.reddit.com/comments/gxb7j1.json?comment=ft3odzl&amp;gt; :METHOD :GET :USER-AGENT &amp;quot;cl-reddit/0.2 (common lisp api wrapper)&amp;quot; :COOKIE-JAR #&amp;lt;DRAKMA:COOKIE-JAR (with 5 c..
 5: (CL-REDDIT::GET-JSON &amp;quot;http://www.reddit.com/comments/gxb7j1.json?comment=ft3odzl&amp;quot; #&amp;lt;CL-REDDIT:USER {10079B9973}&amp;gt;)
 6: (CL-REDDIT:GET-COMMENTS &amp;quot;gxb7j1&amp;quot; #&amp;lt;CL-REDDIT:USER {10079B9973}&amp;gt; :ARTICLE NIL :COMMENT &amp;quot;ft3odzl&amp;quot; :CONTEXT NIL :DEPTH NIL :LIMIT NIL :SORT NIL :THREADED NIL :SHOWMORE NIL)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tried to switch to the Dexador instead of Drakma, but found another bug - it is not able to work in multiple threads:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fukamachi/dexador/issues/88&quot;&gt;https://github.com/fukamachi/dexador/issues/88&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So, we&apos;ll never know if SpaceX developers are using Lisp in their space ships :)&lt;/p&gt;
</description>
            <pubDate>Thu, 11 Jun 2020 23:45:15 +0300</pubDate>
        </item>
        <item>
            <title>cl-gearman</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0095-cl-gearman.html</link>
            <description>&lt;p&gt;Yesterday, we &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0094-lfarm.html&quot;&gt;talked about&lt;/a&gt; distributing jobs across a cluster using &lt;code&gt;lfarm&lt;/code&gt;. &lt;code&gt;lfarm&lt;/code&gt; is not well suited to environments where worker hosts can go down and return back later.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gearman.org/&quot;&gt;Gearman&lt;/a&gt; is the RPC server. Multiple workers can connect to this server and advertise which functions they are supporting. A client can call these functions and receive a result.&lt;/p&gt;
&lt;p&gt;Here is the diagram showing how does it work in the common case:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0095/gearman-cluster.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A cool feature of Gearman is its language independence. Workers can be written in any language. This means that in your distributed system some functions can be written in Lisp, others in Python or even in Bash and some UNIX tools.&lt;/p&gt;
&lt;p&gt;Now we&apos;ll see how to write a simple worker in Common Lisp and call it. But first, let&apos;s start Gearman server in the Docker container:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; bash&apos;&gt;[art@poftheday:~]% docker run --rm -p 4730:4730 artefactual/gearmand:1.1.19.1-alpine
Unable to find image &amp;#039;artefactual/gearmand:1.1.19.1-alpine&amp;#039; locally
1.1.19.1-alpine: Pulling from artefactual/gearmand
cbdbe7a5bc2a: Pull complete
33291983401c: Pull complete
b4a2ffd9f406: Pull complete
c5f0c79c81bd: Pull complete
c3b95f315fd4: Pull complete
e8fb3c47a5c3: Pull complete
Digest: sha256:585921f3509b86a9e78aac6c3512c894e0f0a8e0497d194483bafc5ebc275edc
Status: Downloaded newer image for artefactual/gearmand:1.1.19.1-alpine
   INFO 2020-06-10 13:34:35.722249 [  main ] Initializing Gear on port 4730 with SSL: false
   INFO 2020-06-10 13:34:35.000000 [  main ] Starting up with pid 1, verbose is set to INFO
   INFO 2020-06-10 13:34:35.000000 [  main ] Listening on 0.0.0.0:4730 (9)
   INFO 2020-06-10 13:34:35.000000 [  main ] Adding event for listening socket (9)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, we need to start a simple worker which supports two functions. It can reverse any string and report about it&apos;s Lisp implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-gearman:with-worker (worker &amp;quot;localhost:4730&amp;quot;)
             (cl-gearman:add-ability worker &amp;quot;get-implementation&amp;quot;
                                     (lambda (arg job)
                                       (declare (ignorable arg job))
                                       (format nil &amp;quot;~A ~A&amp;quot;
                                               (lisp-implementation-type)
                                               (lisp-implementation-version))))
             (cl-gearman:add-ability worker &amp;quot;reverse&amp;quot;
                                     (lambda (arg job)
                                       (declare (ignorable job))
                                       (reverse arg)))
             (loop (cl-gearman:work worker)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is how we can call these functions from the console:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; bash&apos;&gt;[art@poftheday:~]% echo &amp;#039;Hello Lisp World!&amp;#039; | gearman -f reverse
!dlroW psiL olleH

[art@poftheday:~]% echo &amp;#039;&amp;#039; | gearman -f get-implementation
SBCL 2.0.2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This way you can communicate with the Lisp from the outer world.&lt;/p&gt;
&lt;p&gt;If we want to call these functions from other Lisp program, then we can do it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;OTHER-LISP&amp;gt; (cl-gearman:with-client (client &amp;quot;localhost:4730&amp;quot;)
              (format t &amp;quot;~A&amp;quot;
                      (cl-gearman:submit-job client &amp;quot;reverse&amp;quot;
                                             :arg &amp;quot;Hello Lisp World!&amp;quot;)))
!dlroW psiL olleH

OTHER-LISP&amp;gt; (cl-gearman:with-client (client &amp;quot;localhost:4730&amp;quot;)
              (format t &amp;quot;~A&amp;quot;
                      (cl-gearman:submit-job client &amp;quot;get-implementation&amp;quot;)))
SBCL 2.0.2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gearman uses a very simple protocol. Every function accepts only one string as its argument. If you want to pass something complex, you&apos;ll need to use some sort of serialization.&lt;/p&gt;
&lt;p&gt;For example, here is how I use &lt;code&gt;cl-store&lt;/code&gt; and &lt;code&gt;base64&lt;/code&gt; to pass lisp data-structures between a worker and a client in Ultralisp.org:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ultralisp/ultralisp/blob/f52411bd89dc5b0bcb6701e4ba0712dd5aee128b/src/rpc/core.lisp#L23-L47&quot;&gt;https://github.com/ultralisp/ultralisp/blob/f52411bd89dc5b0bcb6701e4ba0712dd5aee128b/src/rpc/core.lisp#L23-L47&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;That is it for today. Play with both &lt;code&gt;lfarm&lt;/code&gt; and &lt;code&gt;cl-gearman&lt;/code&gt; to decide which one is better suited for your task.&lt;/p&gt;
</description>
            <pubDate>Wed, 10 Jun 2020 21:28:59 +0300</pubDate>
        </item>
        <item>
            <title>lfarm</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0094-lfarm.html</link>
            <description>&lt;p&gt;This library is similar to Python&apos;s multiprocessing which is also &lt;a href=&quot;https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.connection&quot;&gt;able to run processes on different hosts&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Use &lt;code&gt;lfarm&lt;/code&gt; when you need to run jobs on the cluster.&lt;/p&gt;
&lt;p&gt;The cool &lt;code&gt;lfarm&lt;/code&gt;&apos;s feature is the ability to run jobs on workers, running on different Common Lisp implementation.&lt;/p&gt;
&lt;p&gt;To demonstrate how it works, I started a LispWorks Personal edition on my laptop and SBCL with ClozureCL in the Docker containers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(ql:quickload :lfarm-server)

;; This how I started it on LispWorks
(lfarm-server:start-server &amp;quot;127.0.0.1&amp;quot; 10003)

;; inside the Docker:
(lfarm-server:start-server &amp;quot;0.0.0.0&amp;quot; 10000)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After that, I created a workers pool in my SBCL REPL and called &lt;code&gt;broadcast-task&lt;/code&gt; to run a function on every worker:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (setf lfarm:*kernel* (lfarm:make-kernel &amp;#039;((&amp;quot;127.0.0.1&amp;quot; 10001)
                                                     (&amp;quot;127.0.0.1&amp;quot; 10002)
                                                     (&amp;quot;127.0.0.1&amp;quot; 10003))))
#&amp;lt;LFARM-CLIENT.KERNEL:KERNEL :WORKER-COUNT 3 {1004E7C7C3}&amp;gt;

POFTHEDAY&amp;gt; (lfarm:broadcast-task
            (lambda ()
              (list :lisp (lisp-implementation-type)
                    :lisp-version (lisp-implementation-version)
                    :system (string-trim
                             (list #\Newline #\Space)
                             (with-output-to-string (s)
                               (uiop:run-program &amp;quot;uname -s -m -n&amp;quot;
                                                 :output s))))))
#((:LISP &amp;quot;LispWorks Personal Edition&amp;quot;
   :LISP-VERSION &amp;quot;7.1.2&amp;quot;
   :SYSTEM &amp;quot;Darwin lispbook x86_64&amp;quot;)
  (:LISP &amp;quot;SBCL&amp;quot;
   :LISP-VERSION &amp;quot;1.5.6&amp;quot;
   :SYSTEM &amp;quot;Linux 5d4cc1b96f7e x86_64&amp;quot;)
  (:LISP &amp;quot;Clozure Common Lisp&amp;quot;
   :LISP-VERSION &amp;quot;Version 1.11.5/v1.11.5  (LinuxX8664)&amp;quot;
   :SYSTEM &amp;quot;Linux d2c83144fce3 x86_64&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another great feature is API compatibility with &lt;code&gt;lparallel&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/06/0093-lparallel.html&quot;&gt;reviewed yesterday&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I took our yesterday code and modified it to be able to distinguish a machine processed a task:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lfarm:pmapcar
            (lambda (idx)
              (loop for iteration from 1 to 10
                    do (format t &amp;quot;~A task is processing ~A iteration~%&amp;quot;
                               idx iteration)
                       (sleep (random 1.0))
                    finally (return (format nil &amp;quot;~A result processed by ~A&amp;quot;
                                            idx
                                            (lisp-implementation-type)))))
              (alexandria:iota 10))
(&amp;quot;0 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;1 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;2 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;3 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;4 result processed by SBCL&amp;quot;
 &amp;quot;5 result processed by SBCL&amp;quot;
 &amp;quot;6 result processed by SBCL&amp;quot;
 &amp;quot;7 result processed by LispWorks Personal Edition&amp;quot;
 &amp;quot;8 result processed by LispWorks Personal Edition&amp;quot;
 &amp;quot;9 result processed by LispWorks Personal Edition&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The bad news is that &lt;code&gt;lfarm&lt;/code&gt; is not suite well to the cloud environment, where workers can disappear at any time and become available later.&lt;/p&gt;
&lt;p&gt;Some time ago, I tried to use &lt;code&gt;lfarm&lt;/code&gt; in Ultralisp, to run some jobs in separate containers, but found that &lt;code&gt;lfarm&lt;/code&gt; does not like when worker process disconnects.&lt;/p&gt;
&lt;p&gt;For example, if some of the workers aren&apos;t running, &lt;code&gt;make-kernel&lt;/code&gt; will hang forever. Or if some of the workers will go offline, then &lt;code&gt;broadcast-task&lt;/code&gt; also will hang.&lt;/p&gt;
&lt;p&gt;Tomorrow I&apos;ll tell you about another solution which helped me to solve this problem.&lt;/p&gt;
</description>
            <pubDate>Tue, 09 Jun 2020 21:06:00 +0300</pubDate>
        </item>
        <item>
            <title>lparallel</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0093-lparallel.html</link>
            <description>&lt;p&gt;Today I want to tell you about this great library which makes it very easy to speed up your program in an easy way.&lt;/p&gt;
&lt;p&gt;LParallel provides a convenient to use a thread pool. It allows you to run your code on multiple CPUs without bothering with threading et all.&lt;/p&gt;
&lt;p&gt;Here is a quick demo which allows us to run calculations in parallel by changing a call to &lt;code&gt;mapcar&lt;/code&gt; with a call to &lt;code&gt;lparallel:pmapcar&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; First we need to create a pool of 4 workers:
POFTHEDAY&amp;gt; (setf lparallel:*kernel*
                 (lparallel:make-kernel 4))
#&amp;lt;LPARALLEL.KERNEL:KERNEL
   :NAME &amp;quot;lparallel&amp;quot;
   :WORKER-COUNT 4
   :USE-CALLER NIL
   :ALIVE T
   :SPIN-COUNT 2000 {1002FB64D3}&amp;gt;

;; And here is the easiest way to use it:
POFTHEDAY&amp;gt; (lparallel:pmapcar
            (lambda (idx)
              (loop for iteration from 1 to 10
                    do (format t &amp;quot;~A task is processing ~A iteration~%&amp;quot;
                               idx iteration)
                       (sleep (random 1.0))
                    finally (return (format nil &amp;quot;~A worker result&amp;quot;
                                            idx))))
              (alexandria:iota 10))
0 task is processing 1 iteration
3 task is processing 1 iteration
0 task is processing 2 iteration
3 task is processing 2 iteration
3 task is processing 3 iteration
0 task is processing 3 iteration
...
7 task is processing 7 iteration
7 task is processing 8 iteration
7 task is processing 9 iteration
7 task is processing 10 iteration
(&amp;quot;0 worker result&amp;quot; &amp;quot;1 worker result&amp;quot; &amp;quot;2 worker result&amp;quot; &amp;quot;3 worker result&amp;quot;
 &amp;quot;4 worker result&amp;quot; &amp;quot;5 worker result&amp;quot; &amp;quot;6 worker result&amp;quot; &amp;quot;7 worker result&amp;quot;
 &amp;quot;8 worker result&amp;quot; &amp;quot;9 worker result&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A number of workers depend on the reason why do you want to parallelize execution. There are two possible situations:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;you have a CPU intensive tasks and want to use more power;&lt;/li&gt;&lt;li&gt;you have an IO-bound tasks and want to make more operations in   parallel.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;In the first case there is no sense to make more workers than a number of CPU&apos;s on your machine. In the second scenario, the number of workers can be higher.&lt;/p&gt;
&lt;p&gt;There is also a lower-level API for offloading work to workers through channels. In the next example, I pass a function to the pool and then receive the result:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *chan*
             (lparallel:make-channel))

POFTHEDAY&amp;gt; (lparallel:submit-task
            *chan*
            (lambda (param)
              (format t &amp;quot;Processing ~A~%&amp;quot; param)
              (sleep 3)
              (format t &amp;quot;Processing is done~%&amp;quot;)
              :result-of-processing)
            100500)
; No values
Processing 100500
Processing is done
POFTHEDAY&amp;gt; (lparallel:receive-result *chan*)
:RESULT-OF-PROCESSING&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;LParallel has more great features like promises, futures and many ways to run jobs in parallel. It is one of the few Common Lisp projects that have excellent documentation. I recommend you to read it:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lparallel.org/&quot;&gt;https://lparallel.org/&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Mon, 08 Jun 2020 19:06:26 +0300</pubDate>
        </item>
        <item>
            <title>lime</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0092-lime.html</link>
            <description>&lt;p&gt;Lime is a standalone SWANK client. It can be used to programmatically connect to the SWANK server without Emacs.&lt;/p&gt;
&lt;p&gt;One useful thing, you might do is to make a command-line client to send a command to your server. One practical task is code hot-reload. Here is an &lt;a href=&quot;https://lispcookbook.github.io/cl-cookbook/web.html#hot-reload&quot;&gt;example&lt;/a&gt; of how to implement it using &lt;a href=&quot;http://quickdocs.org/swank-client/&quot;&gt;another SWANK client&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Example from Lime&apos;s sources shows how to create a REPL connected to the SWANK. However, this example creates a SWANK server in the same process. I think it will be more realistic to connect from one lisp to another.&lt;/p&gt;
&lt;p&gt;So, I modified example to make it connect to the localhost 20100, where we&apos;ll start a separate ClozureCL process with SWANK:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;Clozure Common Lisp Version 1.12 (v1.12) DarwinX8664

For more information about CCL, please see http://ccl.clozure.com.

CCL is free software.  It is distributed under the terms of the Apache
Licence, Version 2.0.
? (ql:quickload :swank)
To load &amp;quot;swank&amp;quot;:
  Load 1 ASDF system:
    swank
; Loading &amp;quot;swank&amp;quot;

? (swank:create-server :port 20100 :dont-close t :style :spawn)
;; Swank started at port: 20100.
20100&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we need a function which will make a connection and provide us with the remote REPL.&lt;/p&gt;
&lt;p&gt;I just removed the code which starts  SWANK in the same process and replaced &lt;code&gt;(uiop:hostname)&lt;/code&gt; with &quot;localhost&quot;, because &lt;code&gt;(uiop:hostname)&lt;/code&gt; didn&apos;t work for me:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun repl ()
             &amp;quot;Start the REPL.&amp;quot;
             (let ((conn (lime:make-connection &amp;quot;localhost&amp;quot;
                                               20100)))
               (lime:connect conn)

               (format t &amp;quot;Swank server running on ~A ~A~%&amp;quot;
                       (lime:connection-implementation-name conn)
                       (lime:connection-implementation-version conn))
               
               (loop
                 ;; Read all events
                 (sleep 0.05)
                 (let ((events (lime:pull-all-events conn)))
                   (loop for event in events do
                     (typecase event
                       (lime:write-string-event
                        (write-string (lime:event-string event)))
                       (lime:debugger-event
                        (write-string &amp;quot;Entered debugger!&amp;quot;))
                       (t
                        t))))
                 ;; Take input
                 (if (lime:connection-reader-waiting-p conn)
                     ;; Read a line to send as standard input
                     (progn
                       (format t &amp;quot;~%Read: &amp;quot;)
                       (let ((input (read-line)))
                         (lime:send-input conn input)))
                     ;; Read regular code
                     (progn
                       (format t &amp;quot;~A&amp;gt; &amp;quot; (lime:connection-package conn))
                       (let ((input (read)))
                         (lime:evaluate conn
                                        (with-standard-io-syntax
                                          (prin1-to-string input)))))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can connect to our ClozureCL process and have a fun!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; We are connecting from SBCL to CCL
POFTHEDAY&amp;gt; (lisp-implementation-type)
&amp;quot;SBCL&amp;quot;
POFTHEDAY&amp;gt; (lisp-implementation-version)
&amp;quot;2.0.2&amp;quot;

POFTHEDAY&amp;gt; (repl)
Swank server running on ccl Version 1.12 (v1.12) DarwinX8664

COMMON-LISP-USER&amp;gt; (lisp-implementation-type)
&amp;quot;Clozure Common Lisp&amp;quot;

COMMON-LISP-USER&amp;gt; (lisp-implementation-version)
&amp;quot;Version 1.12 (v1.12) DarwinX8664&amp;quot;

COMMON-LISP-USER&amp;gt; (+ 1 2)
3&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you are going to try &lt;code&gt;Lime&lt;/code&gt; on CCL, use the patched &lt;code&gt;swank-protocol&lt;/code&gt; system with &lt;a href=&quot;https://github.com/eudoxia0/swank-protocol/pull/2&quot;&gt;this fix&lt;/a&gt;. Without the fix Lime will not work because of the following error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;&amp;lt;INFO&amp;gt; [23:48:47] swank-protocol swank-protocol.lisp (read-message) -
  Read message SWANK-PROTOCOL::RESULT: (:READER-ERROR
                                        &amp;quot;(:emacs-rex (swank-repl:listener-eval #A((7) common-lisp:base-char . \&amp;quot;(+ 1 2)\&amp;quot;)) \&amp;quot;COMMON-LISP-USER\&amp;quot; :repl-thread 5)
&amp;quot;
                                        &amp;quot;Reader error on #&amp;lt;STRING-INPUT-STREAM  :CLOSED #x30200139FB9D&amp;gt;:
reader macro #A used without a rank integer&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I experienced the same error with &lt;a href=&quot;https://github.com/cxxxr/lem&quot;&gt;Lem&lt;/a&gt; editor. And it was fixed with a &lt;a href=&quot;https://github.com/cxxxr/lem/pull/471/files&quot;&gt;similar patch&lt;/a&gt;.&lt;/p&gt;
</description>
            <pubDate>Mon, 08 Jun 2020 00:27:06 +0300</pubDate>
        </item>
        <item>
            <title>defclass-std</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0091-defclass-std.html</link>
            <description>&lt;p&gt;This library provides a shortcut macro to define &lt;code&gt;CLOS&lt;/code&gt; classes. Today I needed to define a class which will store stock candles data. It will keep data in the columns.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;defclass-std&lt;/code&gt; we can define such class like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass-std:defclass/std candles ()
             ((timestamps
               lows highs
               opens closes
               volumes)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will be expand into the &lt;code&gt;defclass&lt;/code&gt; full of accessors, init forms, etc:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass candles nil
  ((timestamps :accessor timestamps
               :initarg :timestamps
               :initform nil)
   (lows :accessor lows
         :initarg :lows
         :initform nil)
   (highs :accessor highs
          :initarg :highs
          :initform nil)
   (opens :accessor opens
          :initarg :opens
          :initform nil)
   (closes :accessor closes
           :initarg :closes
           :initform nil)
   (volumes :accessor volumes
            :initarg :volumes
            :initform nil)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what I really want is a class with custom initforms and readers, prefixed by class name.&lt;/p&gt;
&lt;p&gt;Here is the class definition I had before discovered the &lt;code&gt;defclass-std&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass candles ()
  ((timestamps :reader candles-timestamps
               :initform (make-time-vector)
               :initarg :timestamps)
   (lows :reader candles-lows
         :initform (make-price-vector)
         :initarg :lows)
   (highs :reader candles-highs
          :initform (make-price-vector)
          :initarg :highs)
   (opens :reader candles-opens
          :initform (make-price-vector)
          :initarg :opens)
   (closes :reader candles-closes
           :initform (make-price-vector)
           :initarg :closes)
   (volumes :reader candles-volumes
            :initform (make-volume-vector)
            :initarg :volumes))
  (:documentation
   &amp;quot;This is stock candles candles.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how &lt;code&gt;defclass-std&lt;/code&gt; can make this definition shorter and &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass-std:defclass/std candles ()
  ((timestamps
    :ri :with-prefix
    :std (make-time-vector))
   (volumes
    :ri :with-prefix
    :std (make-volume-vector))
   ;; Columns, having common options
   ;; can be grouped together!
   (lows highs opens closes
    :ri :with-prefix
    :std (make-price-vector)))
  (:documentation
   &amp;quot;This is stock candles storage.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will write &lt;code&gt;:initarg&lt;/code&gt; and &lt;code&gt;:reader&lt;/code&gt; for each slot. Also, slot&apos;s &lt;code&gt;:initform&lt;/code&gt; will have the value, provided after the &lt;code&gt;:std&lt;/code&gt; keyword.&lt;/p&gt;
&lt;p&gt;The syntax can be made even shorter, but such format is not supported yet:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass-std:defclass/std candles ()
  ((timestamps
    :std (make-time-vector))
   (volumes
    :std (make-volume-vector))
   (lows highs opens closes
    :std (make-price-vector)))
  (:default-slot-opts :ri :with-prefix)
  (:documentation
   &amp;quot;This is stock candles storage.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This can make class definitions as concise as defstruct.&lt;/p&gt;
</description>
            <pubDate>Sat, 06 Jun 2020 20:58:34 +0300</pubDate>
        </item>
        <item>
            <title>defmain</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0090-defmain.html</link>
            <description>&lt;p&gt;Today I want to tell about my own library for command-line arguments parsing. &lt;code&gt;Defmain&lt;/code&gt; provides a macro for defining the main function.&lt;/p&gt;
&lt;p&gt;All you need is to declare required and optional arguments like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defmain:defmain main
               ((debug &amp;quot;Show traceback instead of short message.&amp;quot;
                       :flag t)
                (log   &amp;quot;Filename to write log to.&amp;quot;)
                (token &amp;quot;GitHub personal access token.&amp;quot;
                       :env-var &amp;quot;TOKEN&amp;quot;)
                &amp;amp;rest repositories)
             &amp;quot;Utility to analyze github forks.&amp;quot;
             
             (format t
                     &amp;quot;Repositories: ~{~S~^, ~}~%~
                      Debug: ~S~%~
                      Log: ~S~%~
                      Token: ~S~%&amp;quot;
                     repositories
                     debug
                     log
                     token))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code expands to a lot of low-level code which uses &lt;a href=&quot;https://twitter.com/didierverna&quot;&gt;@didierverna&lt;/a&gt;&apos;s &lt;code&gt;net.didierverna.clon&lt;/code&gt; for actual arguments parsing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(progn
 (defun main (&amp;amp;rest defmain/defmain::argv)
   (declare (ignorable))
   (let ((defmain/defmain::synopsis
          (net.didierverna.clon:defsynopsis (:postfix &amp;quot;REPOSITORY...&amp;quot;
                                             :make-default nil)
            (defmain/defmain::text :contents &amp;quot;Utility to analyze github forks.&amp;quot;)
            (defmain/defmain::flag :long-name &amp;quot;help&amp;quot; :env-var nil :description
             &amp;quot;Show help on this program.&amp;quot; :short-name &amp;quot;h&amp;quot;)
            (defmain/defmain::flag :long-name &amp;quot;debug&amp;quot; :env-var nil :description
             &amp;quot;Show traceback instead of short message.&amp;quot; :short-name &amp;quot;d&amp;quot;)
            (defmain/defmain::stropt :long-name &amp;quot;log&amp;quot; :env-var nil :description
             &amp;quot;Filename to write log to.&amp;quot; :short-name &amp;quot;l&amp;quot;)
            (defmain/defmain::stropt :long-name &amp;quot;token&amp;quot; :env-var &amp;quot;TOKEN&amp;quot;
             :description &amp;quot;GitHub personal access token.&amp;quot; :short-name &amp;quot;t&amp;quot;)))
         (defmain/defmain::argv
          (or defmain/defmain::argv (uiop/image:command-line-arguments))))
     (change-class defmain/defmain::synopsis &amp;#039;defmain/defmain::cool-synopsis
                   :command &amp;#039;main)
     (net.didierverna.clon:make-context :cmdline
                                        (cons &amp;quot;main&amp;quot; defmain/defmain::argv)
                                        :synopsis defmain/defmain::synopsis))
   (let ((defmain/defmain::%rest-arguments (net.didierverna.clon:remainder)))
     (declare (ignorable defmain/defmain::%rest-arguments))
     (flet ((defmain/defmain::%pop-argument (defmain/defmain::name)
              &amp;quot;This local function is used to pop positional arguments from the command line.&amp;quot;
              (unless defmain/defmain::%rest-arguments
                (check-type defmain/defmain::name symbol)
                (error &amp;#039;defmain/defmain::argument-is-required-error :name
                       defmain/defmain::name))
              (pop defmain/defmain::%rest-arguments)))
       (let ((net.didierverna.clon:help
              (net.didierverna.clon:getopt :long-name &amp;quot;help&amp;quot;))
             (debug (net.didierverna.clon:getopt :long-name &amp;quot;debug&amp;quot;))
             (log (net.didierverna.clon:getopt :long-name &amp;quot;log&amp;quot;))
             (token (net.didierverna.clon:getopt :long-name &amp;quot;token&amp;quot;)))
         (when net.didierverna.clon:help
           (net.didierverna.clon:help)
           (uiop/image:quit 1))
         (handler-bind ((sb-sys:interactive-interrupt
                         (lambda (defmain/defmain::c)
                           (declare (ignorable defmain/defmain::c))
                           (uiop/image:quit 0)))
                        (defmain/defmain::argument-is-required-error
                         (lambda (defmain/defmain::c)
                           (format t &amp;quot;~A~%&amp;quot; defmain/defmain::c)
                           (uiop/image:quit 1)))
                        (error
                         (lambda (condition)
                           (uiop/image:print-condition-backtrace condition
                                                                 :stream
                                                                 *error-output*)
                           (uiop/image:quit 1))))
           (let ((repositories defmain/defmain::%rest-arguments))
             (flet ()
               (setf (logical-pathname-translations &amp;quot;TEMPORARY-FILES&amp;quot;)
                       `((&amp;quot;*.*.*&amp;quot;
                          ,(uiop/package:symbol-call :cl-fad
                                                     &amp;#039;defmain/defmain::get-default-temporary-directory))))
               (uiop/stream:setup-temporary-directory)
               (format t &amp;quot;Repositories: ~{~S~^, ~}~%~
                          Debug: ~S~%~
                          Log: ~S~%~
                          Token: ~S~%&amp;quot;
                       repositories debug log token)
               nil)))))))
 (setf (get &amp;#039;main :arguments) &amp;#039;(debug log token)
       (documentation &amp;#039;main &amp;#039;function) &amp;quot;Utility to analyze github forks.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&apos;s try to call our main function to check how  it processes command-line arguments.&lt;/p&gt;
&lt;p&gt;Defmain calls &lt;code&gt;uiop:quit&lt;/code&gt; at the end of the function on after the printing help message. To suppress this behaviour, I&apos;ll redefine this function to just print to the screen:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun uiop:quit (&amp;amp;optional (code 0))
             (format t &amp;quot;Quit was called with code=~A~%&amp;quot;
                     code))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can pass it different combinations of arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (main)
Repositories: 
Debug: NIL
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: NIL
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;--log&amp;quot; &amp;quot;app.log&amp;quot;&amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: &amp;quot;app.log&amp;quot;
Token: NIL

;; Now we&amp;#039;ll check how it will
;; process environment variable:
POFTHEDAY&amp;gt; (setf (uiop:getenv &amp;quot;TOKEN&amp;quot;)
                 &amp;quot;$ome $ecret 7oken&amp;quot;)

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;--log&amp;quot; &amp;quot;app.log&amp;quot;&amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: &amp;quot;app.log&amp;quot;
Token: &amp;quot;$ome $ecret 7oken&amp;quot;
NIL
POFTHEDAY&amp;gt; (main &amp;quot;--help&amp;quot;)
Usage: main main [-hd] [OPTIONS] REPOSITORY...

Utility to analyze github forks.
  -h, --help                  Show help on this program.
  -d, --debug                 Show traceback instead of short message.
  -l, --log=STR               Filename to write log to.
  -t, --token=STR             GitHub personal access token.
                              Environment: TOKEN
Quit was called with code=1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Defmain&lt;/code&gt; is not in Quicklisp distribution, but you can install it from &lt;a href=&quot;https://ultralisp.org/&quot;&gt;Ultralisp.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are looking to something simpler, you might take a look at &lt;code&gt;unix-opts&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/03/0006-unix-opts.html&quot;&gt;reviewed in the #0006 #poftheday&lt;/a&gt; post.&lt;/p&gt;
</description>
            <pubDate>Fri, 05 Jun 2020 22:24:53 +0300</pubDate>
        </item>
        <item>
            <title>lambda-fiddle</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0089-lambda-fiddle.html</link>
            <description>&lt;p&gt;This library serves a single purpose - to help macro writers to parse lambda lists. In this sense, it is similar to &lt;code&gt;parse-declarations&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0067-parse-declarations.html&quot;&gt;reviewed on 13 May&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The library has a number of functions to extract or remove exact parts of the lambda list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lambda-fiddle:remove-aux-part
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(FOO BAR &amp;amp;KEY BAZ)

POFTHEDAY&amp;gt; (lambda-fiddle:aux-lambda-vars
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(SOMETHING ALTOGETHER)

POFTHEDAY&amp;gt; (lambda-fiddle:extract-all-lambda-vars
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(FOO BAR BAZ SOMETHING ALTOGETHER)

POFTHEDAY&amp;gt; (lambda-fiddle:split-lambda-list
            &amp;#039;(&amp;amp;whole wide world &amp;amp;key roles))
((WORLD) WIDE NIL NIL NIL NIL (ROLES) NIL)

POFTHEDAY&amp;gt; (lambda-fiddle:with-destructured-lambda-list
               (:required req :optional opt)
               &amp;#039;(foo bar &amp;amp;optional baz)
             (list :required req
                   :optional opt))
(:REQUIRED (FOO BAR) :OPTIONAL (BAZ))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It also provides a higher-level macro to extract particular pieces all at once:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lambda-fiddle:with-destructured-lambda-list
               (:required req :optional opt)
               &amp;#039;(foo bar &amp;amp;optional baz)
             (list :required req
                   :optional opt))
(:REQUIRED (FOO BAR) :OPTIONAL (BAZ))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@Shinmera&lt;/a&gt;&apos;s &quot;legit&quot; contains &lt;a href=&quot;https://github.com/Shinmera/legit/blob/f822ac7aa8ed5aec7f2c63b146f790b0410f8502/toolkit.lisp#L31-L45&quot;&gt;a practical example&lt;/a&gt; of the &lt;code&gt;with-destructured-lambda-list&lt;/code&gt; usage.&lt;/p&gt;
&lt;p&gt;This code replaces optional arguments with keywords and adds optional predicates which can be used to check if a keyword argument was provided:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defmacro define-git-wrapper (name &amp;amp;rest argdefs)
  (lambda-fiddle:with-destructured-lambda-list (:required req :optional opt :key key) argdefs
    (let* ((purereq (purify-args req))
           (purekey (purify-args key))
           (pureopt (purify-args opt))
           (augkeys (mapcar (lambda (a)
                              `(,a NIL ,(p-symb a)))
                            (append pureopt purekey))))
      `(defun ,name (,@purereq &amp;amp;key ,@augkeys)
         (declare (ignorable ,@(mapcar #&amp;#039;third augkeys)))
         (run-git
          ,(subseq (string-downcase name) 4)
          ,@(loop for arg in req 
                  when (front-arg-p arg)
                    collect (parse-rargdef arg))
          ,@(loop for arg in opt
                  when (front-arg-p arg)
                    collect (parse-oargdef arg))
          ,@(mapcar #&amp;#039;parse-kargdef key)
          ,@(loop for arg in req
                  unless (front-arg-p arg)
                    collect (parse-rargdef arg))
          ,@(loop for arg in opt
                  unless (front-arg-p arg)
                    collect
                    (parse-oargdef arg)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. If you want to parse lambda lists, use this little helper instead of searching &amp;optional, &amp;rest, &amp;misc, etc by hand.&lt;/p&gt;
</description>
            <pubDate>Thu, 04 Jun 2020 23:51:31 +0300</pubDate>
        </item>
        <item>
            <title>group-by</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0088-group-by.html</link>
            <description>&lt;p&gt;This small utility library implements a really handy facility. It allows you to group items by one or many keys.&lt;/p&gt;
&lt;p&gt;Here is how it works. In the next example we&apos;ll group names by their first letter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (group-by:group-by
            &amp;#039;(&amp;quot;Alice&amp;quot;
              &amp;quot;Bob&amp;quot;
              &amp;quot;Ashley&amp;quot;
              &amp;quot;Katie&amp;quot;
              &amp;quot;Brittany&amp;quot;
              &amp;quot;Jessica&amp;quot;
              &amp;quot;Daniel&amp;quot;
              &amp;quot;Josh&amp;quot;)
            :key (lambda (name)
                   (elt name 0))
            :value #&amp;#039;identity)

((#\A &amp;quot;Alice&amp;quot;
      &amp;quot;Ashley&amp;quot;)
 (#\B &amp;quot;Bob&amp;quot;
      &amp;quot;Brittany&amp;quot;)
 (#\K &amp;quot;Katie&amp;quot;)
 (#\J &amp;quot;Jessica&amp;quot;
      &amp;quot;Josh&amp;quot;)
 (#\D &amp;quot;Daniel&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we are going to group by the first letter and next by the second, we need to use &lt;code&gt;group-by-repeated&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((first-letter (name)
                    (elt name 0))
                  (second-letter (name)
                    (elt name 1)))
             (group-by:group-by-repeated
              &amp;#039;(&amp;quot;Alice&amp;quot;
                &amp;quot;Bob&amp;quot;
                &amp;quot;Ashley&amp;quot;
                &amp;quot;Katie&amp;quot;
                &amp;quot;Brittany&amp;quot;
                &amp;quot;Jessica&amp;quot;
                &amp;quot;Daniel&amp;quot;
                &amp;quot;Josh&amp;quot;)
            :keys (list #&amp;#039;first-letter
                       #&amp;#039;second-letter)))

((#\D (#\a &amp;quot;Daniel&amp;quot;))
 (#\J (#\o &amp;quot;Josh&amp;quot;)
      (#\e &amp;quot;Jessica&amp;quot;))
 (#\K (#\a &amp;quot;Katie&amp;quot;))
 (#\B (#\r &amp;quot;Brittany&amp;quot;)
      (#\o &amp;quot;Bob&amp;quot;))
 (#\A (#\s &amp;quot;Ashley&amp;quot;)
      (#\l &amp;quot;Alice&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library also provides a way to accumulate grouped items into a special object. This could be useful when you don&apos;t have all items right away, but receiving them one by one from some source.&lt;/p&gt;
&lt;p&gt;Here is how it can be used in the simplest case. First, we&apos;ll request names from the user and will be collecting them into a special grouped list data structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((first-letter (name)
                    (elt name 0))
                  (second-letter (name)
                    (elt name 1))
                  (request-name ()
                    (format t &amp;quot;Enter a name: &amp;quot;)
                    (read)))
             (loop with accumulator = (group-by:make-grouped-list
                                       nil
                                       :keys (list #&amp;#039;first-letter
                                                   #&amp;#039;second-letter))
                   for name = (request-name)
                     then (request-name)
                   while name
                   do (group-by:add-item-to-grouping
                       name
                       accumulator)
                   finally (return accumulator)))
Enter a name: &amp;quot;Markus&amp;quot;
Enter a name: &amp;quot;Bob&amp;quot;
Enter a name: &amp;quot;Betty&amp;quot;
Enter a name: &amp;quot;Mery&amp;quot;
Enter a name: &amp;quot;Oleg&amp;quot;
Enter a name: &amp;quot;Marianna&amp;quot;
Enter a name: nil
#&amp;lt;GROUP-BY:GROUPED-LIST {1006D3EC43}&amp;gt;

POFTHEDAY&amp;gt; (defparameter *grouping* *)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At any time we can access the data structure to work with already collected items. Let&apos;s write a recursive function to see what we&apos;ve collected so far:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun print-tree (grouping &amp;amp;optional (depth 0))
             (let ((prefix (make-string depth :initial-element #\Space))
                   (key (group-by:key-value grouping))
                   (items (group-by:items-in-group grouping))
                   (subgroups (group-by:child-groupings grouping)))
               (when key
                 (format t &amp;quot;~A~A~&amp;amp;&amp;quot; prefix key)
                 (incf depth))

               (if subgroups
                   (loop for child in subgroups
                         do (print-tree child depth))
                   (loop for item in items
                         do (format t &amp;quot;~A - ~A~%&amp;quot;
                                    prefix
                                    item)))))

POFTHEDAY&amp;gt; (print-tree *grouping*)
O
 l
  - Oleg
B
 e
  - Betty
 o
  - Bob
M
 e
  - Mery
 a
  - Marianna
  - Markus&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library is powerful enough to have it in your toolbox. Go and group something now!&lt;/p&gt;
</description>
            <pubDate>Wed, 03 Jun 2020 20:44:42 +0300</pubDate>
        </item>
        <item>
            <title>cl-cron</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0087-cl-cron.html</link>
            <description>&lt;p&gt;This is a small system which allows you to organize a scheduled function execution in a Cron-like manner.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-cron:make-cron-job
            (lambda ()
              (format t &amp;quot;[~A] Cron works!~%&amp;quot;
                      (local-time:now))))
#:|cron743|

POFTHEDAY&amp;gt; (cl-cron:start-cron)
#&amp;lt;SB-THREAD:THREAD &amp;quot;Anonymous thread&amp;quot; RUNNING {1004D8CB93}&amp;gt;

[2020-06-02T22:29:00.328017+03:00] Cron works!
[2020-06-02T22:30:00.321083+03:00] Cron works!

POFTHEDAY&amp;gt; (cl-cron:stop-cron)
NIL

POFTHEDAY&amp;gt; (defun list-cron-jobs ()
             (loop for key being the hash-key
                     of cl-cron::*cron-jobs-hash*
                   collect key))

POFTHEDAY&amp;gt; (list-cron-jobs)
(#:|cron743|)

POFTHEDAY&amp;gt; (cl-cron:delete-cron-job (first *))
T

POFTHEDAY&amp;gt; (list-cron-jobs)
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Having unnamed cron jobs is not convenient because it is to remove them, you need to get its name using &lt;code&gt;list-cron-jobs&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;But you can provide a &lt;code&gt;hash-key&lt;/code&gt; argument to the &lt;code&gt;make-cron-job&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-cron:make-cron-job
            (lambda ()
              (format t &amp;quot;[~A] Cron works!~%&amp;quot;
                      (local-time:now)))
            :hash-key :print-every-minute)
:PRINT-EVERY-MINUTE

POFTHEDAY&amp;gt; (list-cron-jobs)
(:PRINT-EVERY-MINUTE)

POFTHEDAY&amp;gt; (cl-cron:delete-cron-job
            :print-every-minute)
T

POFTHEDAY&amp;gt; (list-cron-jobs)
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To make a task which runs not every minute but at the specified time, you can pass keyword arguments to the &lt;code&gt;make-cron-job&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, this will add a callback to run at 10:00 of every Sunday:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-cron:make-cron-job
            (lambda ()
              (format t &amp;quot;Wake Up!~%&amp;quot;))

            ;; Days of week are numbered from 0,
            ;; where 0 is Monday.
            ;; Run every Sunday:
            :day-of-week 6
            :hour 10
            :minute 0
            :hash-key :sunday-alarm)
:SUNDAY-ALARM&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I use &lt;code&gt;cl-cron&lt;/code&gt; in the Ultralisp.org, &lt;a href=&quot;https://github.com/ultralisp/ultralisp/blob/517738b087ca5a3eb14de728d855ca70739913c8/src/cron.lisp#L157-L184&quot;&gt;to schedule different tasks&lt;/a&gt;. And another useful trick I do is redefining &lt;code&gt;cl-cron:log-cron-message&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;By default it writes lines to the &lt;code&gt;./cron.log&lt;/code&gt;, but using this definition you can redirect all messages to the &lt;code&gt;log4cl&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; Here we are patching this function because
;; original tries to write into a file cl-cron.log
(defun cl-cron:log-cron-message (message &amp;amp;optional (type &amp;quot;error&amp;quot;))
  (if (string-equal type &amp;quot;error&amp;quot;)
      (log:error message)
      (log:info message)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Probably, I&apos;ll make a pull-request with these fixes soon. But seems the author of this library is not very active neither at BitBucket nor at the GitHub.&lt;/p&gt;
</description>
            <pubDate>Tue, 02 Jun 2020 23:04:49 +0300</pubDate>
        </item>
        <item>
            <title>pythonic-string-reader</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0086-pythonic-string-reader.html</link>
            <description>&lt;p&gt;This is a small package which adds a new syntax for writing multiline string as you do in Python.&lt;/p&gt;
&lt;p&gt;I already reviewed the &quot;heredoc&quot; library providing a similar functionality:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0055-cl-heredoc.html&quot;&gt;http://40ants.com/lisp-project-of-the-day/2020/05/0055-cl-heredoc.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here is how &lt;code&gt;pythonic-string-reader&lt;/code&gt; can be used:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; Enable the syntax:
POFTHEDAY&amp;gt; (named-readtables:in-readtable
            pythonic-string-reader:pythonic-string-syntax)

;; Using it from the REPL:
POFTHEDAY&amp;gt; &amp;quot;&amp;quot;&amp;quot;
Hello &amp;quot;Lisp World!&amp;quot;
&amp;quot;&amp;quot;&amp;quot;
&amp;quot;
Hello \&amp;quot;Lisp World!\&amp;quot;
&amp;quot;

;; Using it for function&amp;#039;s docstring:
POFTHEDAY&amp;gt; (defun foo (x)
             &amp;quot;&amp;quot;&amp;quot; This is a function
                 which multiplies &amp;quot;x&amp;quot;
                 to itself.
             &amp;quot;&amp;quot;&amp;quot;
             (* x x))
FOO
POFTHEDAY&amp;gt; (documentation &amp;#039;FOO
                          &amp;#039;function)
&amp;quot; This is a function
                 which multiplies \&amp;quot;x\&amp;quot;
                 to itself.
             &amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Whereas &lt;code&gt;cl-heredoc&lt;/code&gt; package allowed you to choose a string which will denote the end of the string literal, &lt;code&gt;pythonic-string-reader&lt;/code&gt; supports only 3 or 4 double-quotes.&lt;/p&gt;
&lt;p&gt;4 double-quotes might be useful if you want to use 3 double quotes in the text:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun foo ()
             &amp;quot;&amp;quot;&amp;quot;&amp;quot;
             You also might enter text with 3 double quotes:

             &amp;quot;&amp;quot;&amp;quot;
             Just use 4 double quotes when starting such string
             literal.
             &amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;)

POFTHEDAY&amp;gt; (foo)
&amp;quot;
             You also might enter text with 3 double quotes:

             \&amp;quot;\&amp;quot;\&amp;quot;
             Just use 4 double quotes when starting such string
             literal.
             \&amp;quot;\&amp;quot;\&amp;quot;
&amp;quot;&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Mon, 01 Jun 2020 21:10:55 +0300</pubDate>
        </item>
        <item>
            <title>simplified-types</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0085-simplified-types.html</link>
            <description>&lt;p&gt;Yesterday I wrote a simple implementation of dataframe. A dataframe stores data columns as simple vectors of some type.&lt;/p&gt;
&lt;p&gt;For this implementation, I needed a type inference to set vector&apos;s type for each column. An inferred type should be generic enough to work for all items in the column.&lt;/p&gt;
&lt;p&gt;But what if we have positive and negative integers in our data? What type will return the standard &lt;code&gt;type-of&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Here is the answer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (type-of 21)
(INTEGER 0 4611686018427387903)

POFTHEDAY&amp;gt; (type-of -21)
FIXNUM&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, if I&apos;ll make my vector&apos;s type &lt;code&gt;(INTEGER 0 4611686018427387903)&lt;/code&gt; it will raise an error on the second element:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (make-array
            2
            :element-type &amp;#039;(INTEGER
                            0
                            4611686018427387903)
            :initial-contents &amp;#039;(21 -21))
; Debugger entered on
; #&amp;lt;TYPE-ERROR expected-type:
; (UNSIGNED-BYTE 62) datum: -21&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That&apos;s why I started to search the way to make inferred type more generic and found &lt;code&gt;simplified-types&lt;/code&gt; library.&lt;/p&gt;
&lt;p&gt;Here is how it works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (mapcar #&amp;#039;type-of
             &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;))

((INTEGER 0 4611686018427387903)
  FIXNUM
  SINGLE-FLOAT
  DOUBLE-FLOAT
  (SIMPLE-ARRAY CHARACTER (6)))
    
POFTHEDAY&amp;gt; (mapcar #&amp;#039;simplified-types:simplified-type-of
             &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;))

((INTEGER 21 21)
 (INTEGER -23 -23)
  SINGLE-FLOAT
  DOUBLE-FLOAT
  T)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, &lt;code&gt;INTEGER&lt;/code&gt; with bounds still is not what I need for my application. Happily, &lt;a href=&quot;https://github.com/marcoheisig&quot;&gt;Marco Heisig&lt;/a&gt; foresee this need and added a switcher which makes integer types more generic.&lt;/p&gt;
&lt;p&gt;With this option, the library produces exactly what I need:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((simplified-types::*precise-integer-types* nil))
             (mapcar #&amp;#039;simplified-types:simplified-type-of
               &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;)))

((INTEGER * *)
 (INTEGER * *)
  SINGLE-FLOAT
  DOUBLE-FLOAT
  T)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you&apos;d like to work with types in Common Lisp, then you probably might be interested in the library I&apos;ve reviewed recently - &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/04/0033-trivialib.type-unify.html&quot;&gt;trivialib.type-unify&lt;/a&gt;. It allows us to do pattern-matching on type specifiers.&lt;/p&gt;
</description>
            <pubDate>Sun, 31 May 2020 21:45:22 +0300</pubDate>
        </item>
        <item>
            <title>cl-ascii-table</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0084-cl-ascii-table.html</link>
            <description>&lt;p&gt;Today I want to cheat and to review a library you&apos;ve already seen in action in the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0082-data-table.html&quot;&gt;data-table&apos;s review&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Recently I encounter a task where I needed to print tabulated data. In Python there is really cool library &lt;a href=&quot;https://pypi.org/project/tabulate/&quot;&gt;tabulate&lt;/a&gt; and first thing I did - created &lt;a href=&quot;https://www.reddit.com/r/Common_Lisp/comments/gs115z/looking_for_a_library_to_show_data_frames_and/&quot;&gt;the post on Reddit&lt;/a&gt; asking if there is something similar for Common Lisp exists.&lt;/p&gt;
&lt;p&gt;Comments didn&apos;t give a  variety of choices, but I found a &lt;code&gt;cl-ascii-table&lt;/code&gt; &lt;a href=&quot;http://quickdocs.org/cl-ascii-table/&quot;&gt;on Quickdocs&lt;/a&gt;. Remember, if you need to solve some problem - search o Quickdocs first! ;-)&lt;/p&gt;
&lt;p&gt;So, &lt;code&gt;cl-ascii-table&lt;/code&gt; is a little helper to draw nice ASCII tables. It is very easy to use. Just create a table, then add rows, and command it to render the table:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (loop with rows = &amp;#039;((&amp;quot;Bob&amp;quot; 31 &amp;quot;bob@gmail.com&amp;quot; 89.4)
                               (&amp;quot;Alice&amp;quot; 28 &amp;quot;alice@hot.com&amp;quot; 65.1)
                               (&amp;quot;Garry&amp;quot; 25 &amp;quot;garry@zoumz.in&amp;quot; 76.3))
                 with table = (ascii-table:make-table
                               &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Age&amp;quot; &amp;quot;Email&amp;quot; &amp;quot;Weight&amp;quot;)
                               ;; this is optional
                               :header &amp;quot;Sport Group&amp;quot;)
                 for row in  rows
                 do (ascii-table:add-row table row)
                 finally (ascii-table:display table))
.---------------------------------------.
|              Sport Group              |
+-------+-----+----------------+--------+
| Name  | Age | Email          | Weight |
+-------+-----+----------------+--------+
| Bob   |  31 | bob@gmail.com  |   89.4 |
| Alice |  28 | alice@hot.com  |   65.1 |
| Garry |  25 | garry@zoumz.in |   76.3 |
+-------+-----+----------------+--------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is not so featureful as Python&apos;s tabulate, but does it job.&lt;/p&gt;
&lt;p&gt;By the way, pay attention on the difference between system name and package name. It might be important if you use &lt;a href=&quot;https://common-lisp.net/project/asdf/asdf/The-package_002dinferred_002dsystem-extension.html&quot;&gt;package-inferred-system&lt;/a&gt; ASDF extension for your own system.&lt;/p&gt;
&lt;p&gt;In this case, you can put this line into your ASD file. This will let ASDF to know which system should be loaded when you are importing symbols from &lt;code&gt;ascii-table&lt;/code&gt; package:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(register-system-packages &amp;quot;cl-ascii-table&amp;quot; &amp;#039;(#:ascii-table))&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Sat, 30 May 2020 22:00:38 +0300</pubDate>
        </item>
        <item>
            <title>assoc-utils</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0083-assoc-utils.html</link>
            <description>&lt;p&gt;This is a small utility library by &lt;a href=&quot;https://twitter.com/nitro_idiot&quot;&gt;Eitaro Fukamachi&lt;/a&gt;. It serves a single purpose - make working with alists more convenient.&lt;/p&gt;
&lt;p&gt;The library has good documentation with lots of examples. Here is the excerpt from it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *person*
             &amp;#039;((&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;)
               (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;)))

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;name&amp;quot;)
&amp;quot;Eitaro&amp;quot;

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;address&amp;quot;)
NIL

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;address&amp;quot;
                             ;; This is default
                             &amp;quot;Tokyo, Japan&amp;quot;)
&amp;quot;Tokyo, Japan&amp;quot;

;; The alist remains the same
POFTHEDAY&amp;gt; *person*
((&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;) (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;))

;; But aget is setf-able:
POFTHEDAY&amp;gt; (setf (assoc-utils:aget *person* &amp;quot;address&amp;quot;)
                 &amp;quot;Tokyo, Japan&amp;quot;)

POFTHEDAY&amp;gt; *person*
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;)
 (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;))

POFTHEDAY&amp;gt; (assoc-utils:delete-from-alistf *person*
                                           &amp;quot;email&amp;quot;)
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also conversion functions which automatically converts keys from strings to keywords and vice versa:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; *person*
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;) 
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))

POFTHEDAY&amp;gt; (assoc-utils:alist-plist *person*)
(:ADDRESS &amp;quot;Tokyo, Japan&amp;quot;
 :NAME &amp;quot;Eitaro&amp;quot;)

POFTHEDAY&amp;gt; (assoc-utils:plist-alist *)
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Read &lt;a href=&quot;http://quickdocs.org/assoc-utils/&quot;&gt;the documentation&lt;/a&gt; to learn more about other functions which allow to compare alists, check their type and to get keys and values.&lt;/p&gt;
</description>
            <pubDate>Fri, 29 May 2020 21:06:49 +0300</pubDate>
        </item>
        <item>
            <title>data-table</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0082-data-table.html</link>
            <description>&lt;p&gt;This library provides a few methods to work with data tables. Think about it as a limited version of &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html&quot;&gt;Pandas Dataframe&lt;/a&gt; for Common Lisp.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Data-table&lt;/code&gt; abilities are really modest. For example, it does not provide methods to investigate data in the table.&lt;/p&gt;
&lt;p&gt;To overcome this limitation, we&apos;ll use another library - &lt;code&gt;cl-ascii-table&lt;/code&gt; and define a &lt;code&gt;describe-object&lt;/code&gt; method for data tables:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (make-instance &amp;#039;data-table:data-table
                            :column-names &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Birthday&amp;quot; &amp;quot;Age&amp;quot;)
                            :rows &amp;#039;((&amp;quot;Bob&amp;quot; &amp;quot;1985-05-17&amp;quot; 35)
                                    (&amp;quot;Alice&amp;quot; &amp;quot;1989-02-23&amp;quot; 31)
                                    (&amp;quot;John&amp;quot; &amp;quot;2000-01-03&amp;quot; 20))))

;; This is what we&amp;#039;ll wee by default:
POFTHEDAY&amp;gt; (describe *dt*)
#&amp;lt;DATA-TABLE:DATA-TABLE {1003D50293}&amp;gt;
  [standard-object]

Slots with :INSTANCE allocation:
  COLUMN-NAMES                   = (&amp;quot;Name&amp;quot; &amp;quot;Birthday&amp;quot; &amp;quot;Age&amp;quot;)
  COLUMN-TYPES                   = (STRING STRING (INTEGER 0 4611686018427387903))
  ROWS                           = ((&amp;quot;Bob&amp;quot; &amp;quot;1985-05-17&amp;quot; 35) (&amp;quot;Alice&amp;quot; &amp;quot;1989-02-23&amp;quot; 31))

;; But with custom method we might make it more
;; more convenient:
POFTHEDAY&amp;gt; (defmethod describe-object ((obj data-table:data-table) stream)
             (loop with table = (ascii-table:make-table
                                 (data-table:column-names obj))
                   for row in (data-table:rows obj)
                   do (ascii-table:add-row table row)
                   finally (ascii-table:display table)))

POFTHEDAY&amp;gt; (describe *dt*)
+-------+------------+-----+
| Name  | Birthday   | Age |
+-------+------------+-----+
| Bob   | 1985-05-17 |  35 |
| Alice | 1989-02-23 |  31 |
| John  | 2000-01-03 |  20 |
+-------+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s see what capabilities for data slicing does it have.&lt;/p&gt;
&lt;p&gt;Here is how we can retrieve columns. Pay attention, column names are case insensitive. But if case mismatch, column names of the resulting table will be different. Maybe this is a bug:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (describe
            (data-table:select-columns *dt*
                                       &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Age&amp;quot;)))
+-------+-----+
| Name  | Age |
+-------+-----+
| Bob   |  35 |
| Alice |  31 |
| John  |  20 |
+-------+-----+
; No values
POFTHEDAY&amp;gt; (describe
            (data-table:select-columns *dt*
                                       &amp;#039;(&amp;quot;name&amp;quot; &amp;quot;age&amp;quot;)))
+-------+-----+
| name  | age |
+-------+-----+
| Bob   |  35 |
| Alice |  31 |
| John  |  20 |
+-------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a way to select a subtable using indices.&lt;/p&gt;
&lt;p&gt;This is how we can select contiguous columns with &quot;Name&quot; and &quot;Age&quot; labels:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; We have to do call this method first.
;; It will fill a list of datatypes.
;; Without filled list of datatypes, make-sub-table will fail :(

POFTHEDAY&amp;gt; (data-table:coerce-data-table-of-strings-to-types *dt*)

POFTHEDAY&amp;gt; (describe
            (data-table:make-sub-table *dt*
                                       :lci 1 :uci 3))
+------------+-----+
| Birthday   | Age |
+------------+-----+
| 1985-05-17 |  35 |
| 1989-02-23 |  31 |
| 2000-01-03 |  20 |
+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we want to select only the last two rows, then we have to do some math:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; In pandas.DataFrame this will be just: dt.tail(2)
;;
POFTHEDAY&amp;gt; (let ((rows-count (data-table:number-of-rows *dt*)))
             (describe
              (data-table:make-sub-table *dt*
                                         :lri (- rows-count 2)
                                         :uri rows-count)))
+-------+------------+-----+
| Name  | Birthday   | Age |
+-------+------------+-----+
| Alice | 1989-02-23 |  31 |
| John  | 2000-01-03 |  20 |
+-------+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, we can combine column selection by name with make-sub-table. But this will create an intermediate table.&lt;/p&gt;
&lt;p&gt;There is also a method &lt;code&gt;overlay-region&lt;/code&gt; to combine two tables. Let&apos;s use it to add email for Genry and Mary:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (data-table:plists-to-data-table
              &amp;#039;((:id 1 :name &amp;quot;Bob&amp;quot;)
                (:id 2 :name &amp;quot;Genry&amp;quot;)
                (:id 3 :name &amp;quot;Mary&amp;quot;))))

POFTHEDAY&amp;gt; (describe *dt*)
+----+-------+
| ID | NAME  |
+----+-------+
|  1 | Bob   |
|  2 | Genry |
|  3 | Mary  |
+----+-------+

POFTHEDAY&amp;gt; (data-table:overlay-region
            (data-table:plists-to-data-table
             &amp;#039;((:email &amp;quot;genry@gmail.com&amp;quot;)
               (:email &amp;quot;mary@hormail.com&amp;quot;)))
            *dt*)
NIL

POFTHEDAY&amp;gt; (describe *dt*)
+------------------+-------+
| ID               | NAME  |
+------------------+-------+
| genry@gmail.com  | Bob   |
| mary@hormail.com | Genry |
|                3 | Mary  |
+------------------+-------+

POFTHEDAY&amp;gt; ;; Oh, this method modified the original table :(((&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To fix the issue, we need to recreate an original table and to specify indexes for applied overlay:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (data-table:plists-to-data-table
              &amp;#039;((:id 1 :name &amp;quot;Bob&amp;quot;)
                (:id 2 :name &amp;quot;Genry&amp;quot;)
                (:id 3 :name &amp;quot;Mary&amp;quot;))))

POFTHEDAY&amp;gt; (data-table:overlay-region
            (data-table:plists-to-data-table
             &amp;#039;((:email &amp;quot;genry@gmail.com&amp;quot;)
               (:email &amp;quot;mary@hormail.com&amp;quot;)))
            *dt*
            :col-idx 2
            :row-idx 1)

;; But new column has no name now :(
POFTHEDAY&amp;gt; (describe *dt*)
+----+-------+------------------+
| ID | NAME  | NIL              |
+----+-------+------------------+
|  1 | Bob   | NIL              |
|  2 | Genry | genry@gmail.com  |
|  3 | Mary  | mary@hormail.com |
+----+-------+------------------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It would be nice to have support for indices and joins &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html#join&quot;&gt;like in Pandas&lt;/a&gt;. That is what I expect from the data manipulation library.&lt;/p&gt;
&lt;p&gt;We&apos;ve viewed almost all core functions of the &lt;code&gt;data-table&lt;/code&gt; library. There are also data coercion and comparison functions. But I think this library has lots of room for improvement.&lt;/p&gt;
&lt;p&gt;Maybe &lt;a href=&quot;https://twitter.com/guicho271828&quot;&gt;@guicho271828&lt;/a&gt; has plans to build a dataframe library as supplementary to his &lt;a href=&quot;https://github.com/numcl/numcl&quot;&gt;NumCL&lt;/a&gt;?&lt;/p&gt;
</description>
            <pubDate>Fri, 29 May 2020 00:31:49 +0300</pubDate>
        </item>
        <item>
            <title>cl-ppcre-unicode</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0081-cl-ppcre-unicode.html</link>
            <description>&lt;p&gt;This system adds Unicode support to the &lt;code&gt;cl-ppcre&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What does it mean? It means that after loading &lt;code&gt;cl-ppcre-unicode&lt;/code&gt; you&apos;ll be able to match against Unicode symbol properties.&lt;/p&gt;
&lt;p&gt;A property matcher has a special syntax in cl-ppcre&apos;s regexps: &lt;code&gt;\p{PropertyName}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; This is how we can find out a position
;; of the first Cyrillic letter:

POFTHEDAY&amp;gt; (ppcre:scan &amp;quot;\\p{Cyrillic}&amp;quot;
                       &amp;quot;123&amp;#x42E;56&amp;quot;)
3

;; Here we are extracting a
;; sequence of Emoji from the text:
POFTHEDAY&amp;gt; (ppcre:regex-replace
            &amp;quot;.*?([\\p{Emoticons}|\\p{Supplemental Symbols and Pictographs}]+).*&amp;quot;
            &amp;quot;Hello, Lisper! &amp;#x1F917;&amp;#x1F603; How are you?&amp;quot;
            &amp;quot;\\1&amp;quot;)
&amp;quot;&amp;#x1F917;&amp;#x1F603;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We are using two different Unicode classes as properties because these two characters belong to different classes.&lt;/p&gt;
&lt;p&gt;You can use &lt;code&gt;cl-unicode&lt;/code&gt; to discover the character&apos;s unicode class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-unicode:code-block #\&amp;#x1F603;)
&amp;quot;Emoticons&amp;quot;

POFTHEDAY&amp;gt; (cl-unicode:code-block #\&amp;#x1F917;)
&amp;quot;Supplemental Symbols and Pictographs&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The way, how &lt;code&gt;cl-ppcre-unicode&lt;/code&gt; works is very interesting. It turns out that &lt;code&gt;cl-ppcre&lt;/code&gt; has a special hook which allows you to define a property resolver.&lt;/p&gt;
&lt;p&gt;For example, if you want to have a special property for vowels, you might do something like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun my-property-resolver (property-name)
             (if (string-equal property-name
                               &amp;quot;vowel&amp;quot;)
                 (rutils:fn vovel-p (character)
                   (member character &amp;#039;(#\A #\E #\I #\O #\U)
                           :test #&amp;#039;char-equal))
                 (cl-ppcre-unicode:unicode-property-resolver
                  property-name)))

POFTHEDAY&amp;gt; (setf cl-ppcre:*property-resolver*
                 #&amp;#039;my-property-resolver)

;; And now we can use the &amp;quot;Vowel&amp;quot; property in any
;; regular expressions!
POFTHEDAY&amp;gt; (ppcre:regex-replace-all
            &amp;quot;\\p{Vowel}&amp;quot;
            &amp;quot;Hello, Lisper! How are you?&amp;quot;
            &amp;quot;&amp;quot;)
&amp;quot;Hll, Lspr! Hw r y?&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Isn&apos;t this cool!? 🤪&lt;/p&gt;
</description>
            <pubDate>Wed, 27 May 2020 20:38:40 +0300</pubDate>
        </item>
    </channel>
</rss>