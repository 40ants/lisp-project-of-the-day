<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>simplified-types</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0085-simplified-types.html</link>
            <description>&lt;p&gt;Yesterday I wrote a simple implementation of dataframe. A dataframe stores data columns as simple vectors of some type.&lt;/p&gt;
&lt;p&gt;For this implementation, I needed a type inference to set vector&apos;s type for each column. An inferred type should be generic enough to work for all items in the column.&lt;/p&gt;
&lt;p&gt;But what if we have positive and negative integers in our data? What type will return the standard &lt;code&gt;type-of&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Here is the answer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (type-of 21)
(INTEGER 0 4611686018427387903)

POFTHEDAY&amp;gt; (type-of -21)
FIXNUM&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, if I&apos;ll make my vector&apos;s type &lt;code&gt;(INTEGER 0 4611686018427387903)&lt;/code&gt; it will raise an error on the second element:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (make-array
            2
            :element-type &amp;#039;(INTEGER
                            0
                            4611686018427387903)
            :initial-contents &amp;#039;(21 -21))
; Debugger entered on
; #&amp;lt;TYPE-ERROR expected-type:
; (UNSIGNED-BYTE 62) datum: -21&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That&apos;s why I started to search the way to make inferred type more generic and found &lt;code&gt;simplified-types&lt;/code&gt; library.&lt;/p&gt;
&lt;p&gt;Here is how it works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (mapcar #&amp;#039;type-of
             &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;))

((INTEGER 0 4611686018427387903)
  FIXNUM
  SINGLE-FLOAT
  DOUBLE-FLOAT
  (SIMPLE-ARRAY CHARACTER (6)))
    
POFTHEDAY&amp;gt; (mapcar #&amp;#039;simplified-types:simplified-type-of
             &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;))

((INTEGER 21 21)
 (INTEGER -23 -23)
  SINGLE-FLOAT
  DOUBLE-FLOAT
  T)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, &lt;code&gt;INTEGER&lt;/code&gt; with bounds still is not what I need for my application. Happily, &lt;a href=&quot;https://github.com/marcoheisig&quot;&gt;Marco Heisig&lt;/a&gt; foresee this need and added a switcher which makes integer types more generic.&lt;/p&gt;
&lt;p&gt;With this option, the library produces exactly what I need:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((simplified-types::*precise-integer-types* nil))
             (mapcar #&amp;#039;simplified-types:simplified-type-of
               &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;)))

((INTEGER * *)
 (INTEGER * *)
  SINGLE-FLOAT
  DOUBLE-FLOAT
  T)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you&apos;d like to work with types in Common Lisp, then you probably might be interested in the library I&apos;ve reviewed recently - &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/04/0033-trivialib.type-unify.html&quot;&gt;trivialib.type-unify&lt;/a&gt;. It allows us to do pattern-matching on type specifiers.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-ascii-table</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0084-cl-ascii-table.html</link>
            <description>&lt;p&gt;Today I want to cheat and to review a library you&apos;ve already seen in action in the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0082-data-table.html&quot;&gt;data-table&apos;s review&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Recently I encounter a task where I needed to print tabulated data. In Python there is really cool library &lt;a href=&quot;https://pypi.org/project/tabulate/&quot;&gt;tabulate&lt;/a&gt; and first thing I did - created &lt;a href=&quot;https://www.reddit.com/r/Common_Lisp/comments/gs115z/looking_for_a_library_to_show_data_frames_and/&quot;&gt;the post on Reddit&lt;/a&gt; asking if there is something similar for Common Lisp exists.&lt;/p&gt;
&lt;p&gt;Comments didn&apos;t give a  variety of choices, but I found a &lt;code&gt;cl-ascii-table&lt;/code&gt; &lt;a href=&quot;http://quickdocs.org/cl-ascii-table/&quot;&gt;on Quickdocs&lt;/a&gt;. Remember, if you need to solve some problem - search o Quickdocs first! ;-)&lt;/p&gt;
&lt;p&gt;So, &lt;code&gt;cl-ascii-table&lt;/code&gt; is a little helper to draw nice ASCII tables. It is very easy to use. Just create a table, then add rows, and command it to render the table:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (loop with rows = &amp;#039;((&amp;quot;Bob&amp;quot; 31 &amp;quot;bob@gmail.com&amp;quot; 89.4)
                               (&amp;quot;Alice&amp;quot; 28 &amp;quot;alice@hot.com&amp;quot; 65.1)
                               (&amp;quot;Garry&amp;quot; 25 &amp;quot;garry@zoumz.in&amp;quot; 76.3))
                 with table = (ascii-table:make-table
                               &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Age&amp;quot; &amp;quot;Email&amp;quot; &amp;quot;Weight&amp;quot;)
                               ;; this is optional
                               :header &amp;quot;Sport Group&amp;quot;)
                 for row in  rows
                 do (ascii-table:add-row table row)
                 finally (ascii-table:display table))
.---------------------------------------.
|              Sport Group              |
+-------+-----+----------------+--------+
| Name  | Age | Email          | Weight |
+-------+-----+----------------+--------+
| Bob   |  31 | bob@gmail.com  |   89.4 |
| Alice |  28 | alice@hot.com  |   65.1 |
| Garry |  25 | garry@zoumz.in |   76.3 |
+-------+-----+----------------+--------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is not so featureful as Python&apos;s tabulate, but does it job.&lt;/p&gt;
&lt;p&gt;By the way, pay attention on the difference between system name and package name. It might be important if you use &lt;a href=&quot;https://common-lisp.net/project/asdf/asdf/The-package_002dinferred_002dsystem-extension.html&quot;&gt;package-inferred-system&lt;/a&gt; ASDF extension for your own system.&lt;/p&gt;
&lt;p&gt;In this case, you can put this line into your ASD file. This will let ASDF to know which system should be loaded when you are importing symbols from &lt;code&gt;ascii-table&lt;/code&gt; package:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(register-system-packages &amp;quot;cl-ascii-table&amp;quot; &amp;#039;(#:ascii-table))&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
            <title>assoc-utils</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0083-assoc-utils.html</link>
            <description>&lt;p&gt;This is a small utility library by &lt;a href=&quot;https://twitter.com/nitro_idiot&quot;&gt;Eitaro Fukamachi&lt;/a&gt;. It serves a single purpose - make working with alists more convenient.&lt;/p&gt;
&lt;p&gt;The library has good documentation with lots of examples. Here is the excerpt from it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *person*
             &amp;#039;((&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;)
               (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;)))

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;name&amp;quot;)
&amp;quot;Eitaro&amp;quot;

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;address&amp;quot;)
NIL

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;address&amp;quot;
                             ;; This is default
                             &amp;quot;Tokyo, Japan&amp;quot;)
&amp;quot;Tokyo, Japan&amp;quot;

;; The alist remains the same
POFTHEDAY&amp;gt; *person*
((&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;) (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;))

;; But aget is setf-able:
POFTHEDAY&amp;gt; (setf (assoc-utils:aget *person* &amp;quot;address&amp;quot;)
                 &amp;quot;Tokyo, Japan&amp;quot;)

POFTHEDAY&amp;gt; *person*
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;)
 (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;))

POFTHEDAY&amp;gt; (assoc-utils:delete-from-alistf *person*
                                           &amp;quot;email&amp;quot;)
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also conversion functions which automatically converts keys from strings to keywords and vice versa:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; *person*
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;) 
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))

POFTHEDAY&amp;gt; (assoc-utils:alist-plist *person*)
(:ADDRESS &amp;quot;Tokyo, Japan&amp;quot;
 :NAME &amp;quot;Eitaro&amp;quot;)

POFTHEDAY&amp;gt; (assoc-utils:plist-alist *)
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Read &lt;a href=&quot;http://quickdocs.org/assoc-utils/&quot;&gt;the documentation&lt;/a&gt; to learn more about other functions which allow to compare alists, check their type and to get keys and values.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>data-table</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0082-data-table.html</link>
            <description>&lt;p&gt;This library provides a few methods to work with data tables. Think about it as a limited version of &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html&quot;&gt;Pandas Dataframe&lt;/a&gt; for Common Lisp.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Data-table&lt;/code&gt; abilities are really modest. For example, it does not provide methods to investigate data in the table.&lt;/p&gt;
&lt;p&gt;To overcome this limitation, we&apos;ll use another library - &lt;code&gt;cl-ascii-table&lt;/code&gt; and define a &lt;code&gt;describe-object&lt;/code&gt; method for data tables:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (make-instance &amp;#039;data-table:data-table
                            :column-names &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Birthday&amp;quot; &amp;quot;Age&amp;quot;)
                            :rows &amp;#039;((&amp;quot;Bob&amp;quot; &amp;quot;1985-05-17&amp;quot; 35)
                                    (&amp;quot;Alice&amp;quot; &amp;quot;1989-02-23&amp;quot; 31)
                                    (&amp;quot;John&amp;quot; &amp;quot;2000-01-03&amp;quot; 20))))

;; This is what we&amp;#039;ll wee by default:
POFTHEDAY&amp;gt; (describe *dt*)
#&amp;lt;DATA-TABLE:DATA-TABLE {1003D50293}&amp;gt;
  [standard-object]

Slots with :INSTANCE allocation:
  COLUMN-NAMES                   = (&amp;quot;Name&amp;quot; &amp;quot;Birthday&amp;quot; &amp;quot;Age&amp;quot;)
  COLUMN-TYPES                   = (STRING STRING (INTEGER 0 4611686018427387903))
  ROWS                           = ((&amp;quot;Bob&amp;quot; &amp;quot;1985-05-17&amp;quot; 35) (&amp;quot;Alice&amp;quot; &amp;quot;1989-02-23&amp;quot; 31))

;; But with custom method we might make it more
;; more convenient:
POFTHEDAY&amp;gt; (defmethod describe-object ((obj data-table:data-table) stream)
             (loop with table = (ascii-table:make-table
                                 (data-table:column-names obj))
                   for row in (data-table:rows obj)
                   do (ascii-table:add-row table row)
                   finally (ascii-table:display table)))

POFTHEDAY&amp;gt; (describe *dt*)
+-------+------------+-----+
| Name  | Birthday   | Age |
+-------+------------+-----+
| Bob   | 1985-05-17 |  35 |
| Alice | 1989-02-23 |  31 |
| John  | 2000-01-03 |  20 |
+-------+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s see what capabilities for data slicing does it have.&lt;/p&gt;
&lt;p&gt;Here is how we can retrieve columns. Pay attention, column names are case insensitive. But if case mismatch, column names of the resulting table will be different. Maybe this is a bug:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (describe
            (data-table:select-columns *dt*
                                       &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Age&amp;quot;)))
+-------+-----+
| Name  | Age |
+-------+-----+
| Bob   |  35 |
| Alice |  31 |
| John  |  20 |
+-------+-----+
; No values
POFTHEDAY&amp;gt; (describe
            (data-table:select-columns *dt*
                                       &amp;#039;(&amp;quot;name&amp;quot; &amp;quot;age&amp;quot;)))
+-------+-----+
| name  | age |
+-------+-----+
| Bob   |  35 |
| Alice |  31 |
| John  |  20 |
+-------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a way to select a subtable using indices.&lt;/p&gt;
&lt;p&gt;This is how we can select contiguous columns with &quot;Name&quot; and &quot;Age&quot; labels:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; We have to do call this method first.
;; It will fill a list of datatypes.
;; Without filled list of datatypes, make-sub-table will fail :(

POFTHEDAY&amp;gt; (data-table:coerce-data-table-of-strings-to-types *dt*)

POFTHEDAY&amp;gt; (describe
            (data-table:make-sub-table *dt*
                                       :lci 1 :uci 3))
+------------+-----+
| Birthday   | Age |
+------------+-----+
| 1985-05-17 |  35 |
| 1989-02-23 |  31 |
| 2000-01-03 |  20 |
+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we want to select only the last two rows, then we have to do some math:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; In pandas.DataFrame this will be just: dt.tail(2)
;;
POFTHEDAY&amp;gt; (let ((rows-count (data-table:number-of-rows *dt*)))
             (describe
              (data-table:make-sub-table *dt*
                                         :lri (- rows-count 2)
                                         :uri rows-count)))
+-------+------------+-----+
| Name  | Birthday   | Age |
+-------+------------+-----+
| Alice | 1989-02-23 |  31 |
| John  | 2000-01-03 |  20 |
+-------+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, we can combine column selection by name with make-sub-table. But this will create an intermediate table.&lt;/p&gt;
&lt;p&gt;There is also a method &lt;code&gt;overlay-region&lt;/code&gt; to combine two tables. Let&apos;s use it to add email for Genry and Mary:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (data-table:plists-to-data-table
              &amp;#039;((:id 1 :name &amp;quot;Bob&amp;quot;)
                (:id 2 :name &amp;quot;Genry&amp;quot;)
                (:id 3 :name &amp;quot;Mary&amp;quot;))))

POFTHEDAY&amp;gt; (describe *dt*)
+----+-------+
| ID | NAME  |
+----+-------+
|  1 | Bob   |
|  2 | Genry |
|  3 | Mary  |
+----+-------+

POFTHEDAY&amp;gt; (data-table:overlay-region
            (data-table:plists-to-data-table
             &amp;#039;((:email &amp;quot;genry@gmail.com&amp;quot;)
               (:email &amp;quot;mary@hormail.com&amp;quot;)))
            *dt*)
NIL

POFTHEDAY&amp;gt; (describe *dt*)
+------------------+-------+
| ID               | NAME  |
+------------------+-------+
| genry@gmail.com  | Bob   |
| mary@hormail.com | Genry |
|                3 | Mary  |
+------------------+-------+

POFTHEDAY&amp;gt; ;; Oh, this method modified the original table :(((&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To fix the issue, we need to recreate an original table and to specify indexes for applied overlay:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (data-table:plists-to-data-table
              &amp;#039;((:id 1 :name &amp;quot;Bob&amp;quot;)
                (:id 2 :name &amp;quot;Genry&amp;quot;)
                (:id 3 :name &amp;quot;Mary&amp;quot;))))

POFTHEDAY&amp;gt; (data-table:overlay-region
            (data-table:plists-to-data-table
             &amp;#039;((:email &amp;quot;genry@gmail.com&amp;quot;)
               (:email &amp;quot;mary@hormail.com&amp;quot;)))
            *dt*
            :col-idx 2
            :row-idx 1)

;; But new column has no name now :(
POFTHEDAY&amp;gt; (describe *dt*)
+----+-------+------------------+
| ID | NAME  | NIL              |
+----+-------+------------------+
|  1 | Bob   | NIL              |
|  2 | Genry | genry@gmail.com  |
|  3 | Mary  | mary@hormail.com |
+----+-------+------------------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It would be nice to have support for indices and joins &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html#join&quot;&gt;like in Pandas&lt;/a&gt;. That is what I expect from the data manipulation library.&lt;/p&gt;
&lt;p&gt;We&apos;ve viewed almost all core functions of the &lt;code&gt;data-table&lt;/code&gt; library. There are also data coercion and comparison functions. But I think this library has lots of room for improvement.&lt;/p&gt;
&lt;p&gt;Maybe &lt;a href=&quot;https://twitter.com/guicho271828&quot;&gt;@guicho271828&lt;/a&gt; has plans to build a dataframe library as supplementary to his &lt;a href=&quot;https://github.com/numcl/numcl&quot;&gt;NumCL&lt;/a&gt;?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-ppcre-unicode</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0081-cl-ppcre-unicode.html</link>
            <description>&lt;p&gt;This system adds Unicode support to the &lt;code&gt;cl-ppcre&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What does it mean? It means that after loading &lt;code&gt;cl-ppcre-unicode&lt;/code&gt; you&apos;ll be able to match against Unicode symbol properties.&lt;/p&gt;
&lt;p&gt;A property matcher has a special syntax in cl-ppcre&apos;s regexps: &lt;code&gt;\p{PropertyName}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; This is how we can find out a position
;; of the first Cyrillic letter:

POFTHEDAY&amp;gt; (ppcre:scan &amp;quot;\\p{Cyrillic}&amp;quot;
                       &amp;quot;123&amp;#x42E;56&amp;quot;)
3

;; Here we are extracting a
;; sequence of Emoji from the text:
POFTHEDAY&amp;gt; (ppcre:regex-replace
            &amp;quot;.*?([\\p{Emoticons}|\\p{Supplemental Symbols and Pictographs}]+).*&amp;quot;
            &amp;quot;Hello, Lisper! &amp;#x1F917;&amp;#x1F603; How are you?&amp;quot;
            &amp;quot;\\1&amp;quot;)
&amp;quot;&amp;#x1F917;&amp;#x1F603;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We are using two different Unicode classes as properties because these two characters belong to different classes.&lt;/p&gt;
&lt;p&gt;You can use &lt;code&gt;cl-unicode&lt;/code&gt; to discover the character&apos;s unicode class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-unicode:code-block #\&amp;#x1F603;)
&amp;quot;Emoticons&amp;quot;

POFTHEDAY&amp;gt; (cl-unicode:code-block #\&amp;#x1F917;)
&amp;quot;Supplemental Symbols and Pictographs&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The way, how &lt;code&gt;cl-ppcre-unicode&lt;/code&gt; works is very interesting. It turns out that &lt;code&gt;cl-ppcre&lt;/code&gt; has a special hook which allows you to define a property resolver.&lt;/p&gt;
&lt;p&gt;For example, if you want to have a special property for vowels, you might do something like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun my-property-resolver (property-name)
             (if (string-equal property-name
                               &amp;quot;vowel&amp;quot;)
                 (rutils:fn vovel-p (character)
                   (member character &amp;#039;(#\A #\E #\I #\O #\U)
                           :test #&amp;#039;char-equal))
                 (cl-ppcre-unicode:unicode-property-resolver
                  property-name)))

POFTHEDAY&amp;gt; (setf cl-ppcre:*property-resolver*
                 #&amp;#039;my-property-resolver)

;; And now we can use the &amp;quot;Vowel&amp;quot; property in any
;; regular expressions!
POFTHEDAY&amp;gt; (ppcre:regex-replace-all
            &amp;quot;\\p{Vowel}&amp;quot;
            &amp;quot;Hello, Lisper! How are you?&amp;quot;
            &amp;quot;&amp;quot;)
&amp;quot;Hll, Lspr! Hw r y?&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Isn&apos;t this cool!? ðŸ¤ª&lt;/p&gt;
</description>
        </item>
        <item>
            <title>jose</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0080-jose.html</link>
            <description>&lt;p&gt;JOSE is an implementation of &lt;a href=&quot;https://datatracker.ietf.org/wg/jose/documents/&quot;&gt;Javascript Object Signing and Encryption&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This &lt;a href=&quot;https://twitter.com/nitro_idiot&quot;&gt;@nitro_idiot&apos;s&lt;/a&gt; library implements a &lt;a href=&quot;https://tools.ietf.org/html/rfc7515&quot;&gt;JSON Web Signature&lt;/a&gt; and allows to encode, decode and inspect JWT tokens.&lt;/p&gt;
&lt;p&gt;JOSE can be useful to implement signed token exchange between microservices.&lt;/p&gt;
&lt;p&gt;I found a &lt;a href=&quot;https://medium.facilelogin.com/jwt-jws-and-jwe-for-not-so-dummies-b63310d201a3&quot;&gt;great article on what JWT, JWS and JWE are&lt;/a&gt;. Read it you want more about them. To demonstrate, how does token inspection work, I took a JWT token from the article and parsed it with Common Lisp JOSE:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (jose/jwt:inspect-token
            &amp;quot;eyJhbGciOiJSUzI1NiIsImtpZCI6Ijc4YjRjZjIzNjU2ZGMzOTUzNjRmMWI2YzAyOTA3NjkxZjJjZGZmZTEifQ.eyJpc3MiOiJhY2NvdW50cy5nb29nbGUuY29tIiwic3ViIjoiMTEwNTAyMjUxMTU4OTIwMTQ3NzMyIiwiYXpwIjoiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiZW1haWwiOiJwcmFiYXRoQHdzbzIuY29tIiwiYXRfaGFzaCI6InpmODZ2TnVsc0xCOGdGYXFSd2R6WWciLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXVkIjoiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiaGQiOiJ3c28yLmNvbSIsImlhdCI6MTQwMTkwODI3MSwiZXhwIjoxNDAxOTEyMTcxfQ.TVKv-pdyvk2gW8sGsCbsnkqsrS0T-H00xnY6ETkIfgIxfotvFn5IwKm3xyBMpy0FFe0Rb5Ht8AEJV6PdWyxz8rMgX2HROWqSo_RfEfUpBb4iOsq4W28KftW5H0IA44VmNZ6zU4YTqPSt4TPhyFC9fP2D_Hg7JQozpQRUfbWTJI&amp;quot;)

((&amp;quot;exp&amp;quot; . 1401912171) (&amp;quot;iat&amp;quot; . 1401908271) (&amp;quot;hd&amp;quot; . &amp;quot;wso2.com&amp;quot;)
 (&amp;quot;aud&amp;quot;
  . &amp;quot;825249835659-te8qgl701kgonnomnp4sqv7erhu1211s.apps.googleusercontent.com&amp;quot;)
 (&amp;quot;email_verified&amp;quot; . T) (&amp;quot;at_hash&amp;quot; . &amp;quot;zf86vNulsLB8gFaqRwdzYg&amp;quot;)
 (&amp;quot;email&amp;quot; . &amp;quot;prabath@wso2.com&amp;quot;)
 (&amp;quot;azp&amp;quot;
  . &amp;quot;825249835659-te8qgl701kgonnomnp4sqv7erhu1211s.apps.googleusercontent.com&amp;quot;)
 (&amp;quot;sub&amp;quot; . &amp;quot;110502251158920147732&amp;quot;) (&amp;quot;iss&amp;quot; . &amp;quot;accounts.google.com&amp;quot;))

((&amp;quot;alg&amp;quot; . &amp;quot;RS256&amp;quot;) (&amp;quot;kid&amp;quot; . &amp;quot;78b4cf23656dc395364f1b6c02907691f2cdffe1&amp;quot;))

#(77 82 175 250 151 114 190 77 160 91 203 6 176 38 236 158 74 172 173 45 19 248
  125 52 198 118 58 17 57 8 126 2 49 126 139 111 22 126 72 192 169 183 199 32
  76 167 45 5 21 237 17 111 145 237 240 1 9 87 163 221 91 44 115 242 179 32 95
  97 209 57 106 146 163 244 95 17 245 41 5 190 34 58 202 184 91 111 10 126 213
  185 31 66 0 227 133 102 53 158 179 83 134 19 168 244 173 225 51 225 200 80
  189 124 253 131 252 120 59 37 10 51 165 4 84 125 181 147 36)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Inspect returns payload, headers and the signature.&lt;/p&gt;
&lt;p&gt;There are also two methods &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt;. Here is how we can use them to issue and verify JWT token:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter
               *secret* (ironclad:ascii-string-to-byte-array
                         &amp;quot;I Love Common Lisp!&amp;quot;))

POFTHEDAY&amp;gt; (defparameter
               *token*
             (jose:encode :hs256 *secret*
                          &amp;#039;((&amp;quot;user&amp;quot;  . &amp;quot;Bob&amp;quot;)
                            (&amp;quot;email&amp;quot; . &amp;quot;bob@gmail.com&amp;quot;))))

;; Now this token can be sent to the authenticated
;; user so that user can pass it back during API calls:
POFTHEDAY&amp;gt; *token*
&amp;quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiQm9iIiwiZW1haWwiOiJib2JAZ21haWwuY29tIn0.NLgg5RxlKDNqw1cqFU0_HysIu-zO7JBYUQN2IZF6c6w&amp;quot;

;; And when we&amp;#039;ll receive such API call,
;; we can know who this user is.
POFTHEDAY&amp;gt; (jose:decode :hs256 *secret*
                        *token*)
((&amp;quot;user&amp;quot; . &amp;quot;Bob&amp;quot;) (&amp;quot;email&amp;quot; . &amp;quot;bob@gmail.com&amp;quot;))
((&amp;quot;alg&amp;quot; . &amp;quot;HS256&amp;quot;) (&amp;quot;typ&amp;quot; . &amp;quot;JWT&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A cool feature of JWT token is that it is signed and you can trust the payload&apos;s content. Let&apos;s pretend, that Bob is the &quot;evil hacker&quot; who wants to get access to another account.&lt;/p&gt;
&lt;p&gt;To do this, Bob will modify payload and use header and sign from the original token:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun replace-payload (token new-payload)
             (rutils:with (((original-header rutils:_ original-sign)
                            (str:split &amp;quot;.&amp;quot; token))
                           (json-payload
                            (jonathan:to-json new-payload :from :alist))
                           (new-encoded-payload
                            (jose/base64:base64url-encode json-payload)))
               (str:join &amp;quot;.&amp;quot;
                         (list original-header
                               new-encoded-payload
                               original-sign))))

POFTHEDAY&amp;gt; (defparameter *new-token*
             (replace-payload *token*
                              &amp;#039;((&amp;quot;user&amp;quot;  . &amp;quot;Alice&amp;quot;)
                                (&amp;quot;email&amp;quot; . &amp;quot;alice@wonderland.in&amp;quot;))))

;; Now we&amp;#039;ll try to decode token on the server-side
;; and receive error from JOSE:
POFTHEDAY&amp;gt; (jose:decode :hs256 *secret*
                        *new-token*)
; Debugger entered on #&amp;lt;JOSE/ERRORS:JWS-VERIFICATION-ERROR {1005C37033}&amp;gt;
[1] POFTHEDAY&amp;gt; 
; Evaluation aborted on #&amp;lt;JOSE/ERRORS:JWS-VERIFICATION-ERROR {1005C37033}&amp;gt;

;; But we still can inspect bad token because
;; it&amp;#039;s content is not encrypted:
POFTHEDAY&amp;gt; (jose:inspect-token *new-token*)

((&amp;quot;email&amp;quot; . &amp;quot;alice@wonderland.in&amp;quot;) (&amp;quot;user&amp;quot; . &amp;quot;Alice&amp;quot;))

((&amp;quot;alg&amp;quot; . &amp;quot;HS256&amp;quot;) (&amp;quot;typ&amp;quot; . &amp;quot;JWT&amp;quot;))

#(52 184 32 229 28 101 40 51 106 195 87 42 21 77 63 31 43 8 187 236 206 236 144
  88 81 3 118 33 145 122 115 172)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BTW, as you can see, tokens are not encoded, they are signed. Because of that, you should pass them only over encrypted channels.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-collider</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0079-cl-collider.html</link>
            <description>&lt;p&gt;This library is an interface to a very interesting algorithmic audio synthesizer - &lt;a href=&quot;https://supercollider.github.io/&quot;&gt;SuperCollider&lt;/a&gt;. SuperCollider itself has a builtin programming language, but &lt;code&gt;cl-collider&lt;/code&gt; makes it possible to write music in lisp interactively.&lt;/p&gt;
&lt;p&gt;Here is how a simple program in sclang looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; C&apos;&gt;// 60Hz Gabber Rave 1995
Server.default.boot;

(
SynthDef(\gabberkick, {
    var snd, freq, high, lfo;
    freq = \freq.kr(440) * (Env.perc(0.001, 0.08, curve: -1).ar * 48 * \bend.kr(1)).midiratio;
    snd = Saw.ar(freq);
    snd = (snd * 100).tanh + ((snd.sign - snd) * -8.dbamp);
    high = HPF.ar(snd, 300);
    lfo = SinOsc.ar(8, [0, 0.5pi]).range(0, 0.01);
    high = high.dup(2) + (DelayC.ar(high, 0.01, lfo) * -2.dbamp);
    snd = LPF.ar(snd, 100).dup(2) + high;
    snd = RLPF.ar(snd, 7000, 2);
    snd = BPeakEQ.ar(snd, \ffreq.kr(3000) * XLine.kr(1, 0.8, 0.3), 0.5, 15);
    snd = snd * Env.asr(0.001, 1, 0.05).ar(2, \gate.kr(1));
    Out.ar(\out.kr(0), snd * \amp.kr(0.1));
}).add;

SynthDef(\hoover, {
    var snd, freq, bw, delay, decay;
    freq = \freq.kr(440);
    freq = freq * Env([-5, 6, 0], [0.1, 1.7], [\lin, -4]).kr.midiratio;
    bw = 1.035;
    snd = { DelayN.ar(Saw.ar(freq * ExpRand(bw, 1 / bw)) + Saw.ar(freq * 0.5 * ExpRand(bw, 1 / bw)), 0.01, Rand(0, 0.01)) }.dup(20);
    snd = (Splay.ar(snd) * 3).atan;
    snd = snd * Env.asr(0.01, 1.0, 1.0).kr(0, \gate.kr(1));
    snd = FreeVerb2.ar(snd[0], snd[1], 0.3, 0.9);
    snd = snd * Env.asr(0, 1.0, 4, 6).kr(2, \gate.kr(1));
    Out.ar(\out.kr(0), snd * \amp.kr(0.1));
}).add;
)

(
var durations;
durations = [1, 1, 1, 1, 3/4, 1/4, 1/2, 3/4, 1/4, 1/2];
Ppar([
    Pbind(*[
        instrument: \gabberkick,
        amp: -23.dbamp,
        freq: 60,
        legato: 0.8,
        ffreq: Pseq((0..(durations.size * 4 - 1)).normalize, inf).linexp(0, 1, 100, 4000),
        dur: Pseq(durations, inf),
        bend: Pfuncn({ |x| if(x &amp;lt; (1/2), 0.4, 1) }, inf) &amp;lt;&amp;gt; Pkey(\dur),
    ]),
    Pbind(*[
        instrument: \hoover,
        amp: -20.dbamp,
        midinote: 74,
        dur: durations.sum * 2,
        sustain: 7,
    ])
]).play(TempoClock(210 / 60));
)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I wasn&apos;t able to translate it into the Lisp form, because &lt;code&gt;cl-collider&lt;/code&gt; does not have documentation and diving into it will require too much time. However, there is a working code example from its README, which you can try in the REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:in-readtable :sc)
POFTHEDAY&amp;gt; (setf sc:*s* (sc:make-external-server
                         &amp;quot;localhost&amp;quot; :port 48800))
POFTHEDAY&amp;gt; (use-package :sc)

POFTHEDAY&amp;gt; (defsynth saw-synth ((note 60) (dur 4.0))
             (let* ((env (env-gen.kr (env [0 .2 0]
                                          [(* dur .2) (* dur .8)])
                                     :act :free))
                    (freq (midicps note))
                    (sig (lpf.ar (saw.ar freq env)
                                 (* freq 2))))
               (out.ar 0 [sig sig])))

POFTHEDAY&amp;gt; (defun make-melody (time n &amp;amp;optional (offset 0))
             (when (&amp;gt; n 0)
               (at time (synth &amp;#039;saw-synth
                               :note (+ offset (alexandria:random-elt
                                                &amp;#039;(62 65 69 72)))))
               (let ((next-time (+ time (alexandria:random-elt
                                         &amp;#039;(0 1 2 1.5)))))
                 (callback next-time #&amp;#039;make-melody
                           next-time (- n 1) offset))))

POFTHEDAY&amp;gt; (make-melody (quant 4) 16)
POFTHEDAY&amp;gt; (make-melody (+ 4 (quant 4)) 16 12)

;; This will stop the music
POFTHEDAY&amp;gt; (sc:stop)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is a demo, showing how does live coding works with &lt;code&gt;cl-collider&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=pZyuHjztARY&quot;&gt;https://www.youtube.com/watch?v=pZyuHjztARY&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To try &lt;code&gt;cl-collider&lt;/code&gt;, you&apos;ll need to install a SuperCollider. On OSX it is as simple as doing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; bash&apos;&gt;brew cask install supercollider&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
            <title>trivial-ssh</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0078-trivial-ssh.html</link>
            <description>&lt;p&gt;This system is a simple wrapper around cl-libssh2 which is binding to the libssh2. Trivial SSH provides a few macros to safely establish a connection, open and close streams.&lt;/p&gt;
&lt;p&gt;In the next example we&apos;ll connect to the host and run two commands to get its hostname and OS description:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; Make this before Quickloading the system:
;; brew upgrade libssh2

POFTHEDAY&amp;gt; (flet ((read-lines (s)
                    (loop for line = (read-line s nil nil)
                          while line
                          collect line)))

             (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot; (ssh:agent &amp;quot;root&amp;quot;))
               (values
                (ssh:with-command (conn iostream &amp;quot;hostname -f&amp;quot;)
                                  (read-lines iostream))
                (ssh:with-command (conn iostream &amp;quot;lsb_release --id --release --codename&amp;quot;)
                                  (read-lines iostream)))))
(&amp;quot;my-lovely-host.inter.net&amp;quot;)
(&amp;quot;Distributor ID:	Ubuntu&amp;quot;
 &amp;quot;Release:	18.04&amp;quot;
 &amp;quot;Codename:	bionic&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, there is are commands to upload and download files using SCP protocol. Here is how we can copy the bootstrap file to the host and execute it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot; (ssh:agent &amp;quot;root&amp;quot;))
               (ssh:upload-file conn &amp;quot;install.sh&amp;quot; &amp;quot;/tmp/install.sh&amp;quot;)
               (ssh:with-command (conn stream &amp;quot;chmod +x /tmp/install.sh&amp;quot;))
                 (ssh:with-command (conn stream &amp;quot;/tmp/install.sh&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The cool part of &lt;code&gt;with-command&lt;/code&gt; macro is that you have a communication stream and can read output during the command execution. Here we are installing Emacs on the remote host and can observe the process:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0078/install-emacs.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here is the code from this sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((-&amp;gt; (from to)
                    (loop for line = (read-line from nil nil)
                       while line
                       do (write-string line to)
                          (terpri))))
             (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot;
                                        (ssh:agent &amp;quot;root&amp;quot;))
               (ssh:with-command
                   (conn stream &amp;quot;apt-get update &amp;amp;&amp;amp;
                                apt-get install -y emacs-nox&amp;quot;)
                   (-&amp;gt; stream *standard-output*))))&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Update&lt;/h2&gt;&lt;p&gt;Found that &lt;code&gt;cl-libssh2&lt;/code&gt; does not support agent forwarding. Because of that, I&apos;m not able to call &lt;code&gt;git pull&lt;/code&gt; on the remote machine.&lt;/p&gt;
&lt;p&gt;I tried to patch &lt;code&gt;cl-libssh2&lt;/code&gt; to support the latest &lt;code&gt;libssh2&lt;/code&gt; where agent forwarding was supported in August 2019, but this patch does not work yet.&lt;/p&gt;
&lt;p&gt;If somebody is interested to help me with that, he might try this pull-request:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alxchk/cl-libssh2/pull/7&quot;&gt;https://github.com/alxchk/cl-libssh2/pull/7&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
            <title>named-readtables</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0077-named-readtables.html</link>
            <description>&lt;p&gt;This system is highly recommended if you are writing a code which modifies a &lt;code&gt;*readtable*&lt;/code&gt; because it allows to define and switch between readtables as you do with Lisp packages.&lt;/p&gt;
&lt;p&gt;If you are not familiar with what &lt;code&gt;*readtable*&lt;/code&gt; is, then read this article:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lisper.in/reader-macros&quot;&gt;https://lisper.in/reader-macros&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;but pay attention, that the article manipulates with &lt;code&gt;*readtable*&lt;/code&gt; instead of using &lt;code&gt;named-readtables&lt;/code&gt;. This is bad. Use &lt;code&gt;named-readtables&lt;/code&gt; instead.&lt;/p&gt;
&lt;p&gt;First, let&apos;s see how to use &lt;code&gt;named-readtables&lt;/code&gt; to switch between read-tables. As an example, we&apos;ll see how to use &lt;code&gt;cl-interpol&lt;/code&gt; and &lt;code&gt;rutils&lt;/code&gt; readtables.&lt;/p&gt;
&lt;p&gt;This is how you can lookup which tables are available:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ql:quickload &amp;#039;(:cl-interpol :rutils))

POFTHEDAY&amp;gt; (named-readtables:list-all-named-readtables)
(#&amp;lt;NAMED-READTABLE :COMMON-LISP {1000024B73}&amp;gt;
 #&amp;lt;NAMED-READTABLE :CURRENT {1000025663}&amp;gt;
 #&amp;lt;NAMED-READTABLE RUTILS.READTABLE:RUTILS-READTABLE {1004A960E3}&amp;gt;
 #&amp;lt;NAMED-READTABLE RUTILS.READTABLE:STANDARD-READTABLE {1004A96133}&amp;gt;
 #&amp;lt;NAMED-READTABLE :INTERPOL-SYNTAX {1001D19853}&amp;gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s see how does switching work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; First I&amp;#039;ll switch to the interpol&amp;#039;s syntax:
POFTHEDAY&amp;gt; (named-readtables:in-readtable :interpol-syntax)

POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #?&amp;quot;Hello ${username}!&amp;quot;)
&amp;quot;Hello Bob!&amp;quot;

;; Rutils readtable is not active, and we can&amp;#039;t
;; use it&amp;#039;s syntax for hashes:
POFTHEDAY&amp;gt; #h(:foo &amp;quot;bar&amp;quot;)
; Debugger entered on #&amp;lt;SB-INT:SIMPLE-READER-ERROR
; &amp;quot;no dispatch function defined for ~S&amp;quot; {10068D4C63}&amp;gt;

;; We have to activate  it first
POFTHEDAY&amp;gt; (named-readtables:in-readtable
            rutils:rutils-readtable)

POFTHEDAY&amp;gt; #h(:foo &amp;quot;bar&amp;quot;)
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 1 {10068B9013}&amp;gt;

;; But now we are unable to use iterpol&amp;#039;s syntax:
POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #?&amp;quot;Hello ${username}!&amp;quot;)
; Debugger entered on #&amp;lt;SB-INT:SIMPLE-READER-ERROR
; &amp;quot;no dispatch function defined for ~S&amp;quot; {1006AE93F3}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what if we want to use both readtables from &lt;code&gt;cl-interpol&lt;/code&gt; and from &lt;code&gt;rutils&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;It is possible if we merge them together and create a new readtable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:defreadtable
               :poftheday
             (:merge
              rutils:rutils-readtable
              :interpol-syntax))

POFTHEDAY&amp;gt; (named-readtables:in-readtable
            :poftheday)

POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #h(:greeting #?&amp;quot;Hello ${username}!&amp;quot;))
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 1 {1003054C23}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-ht *)
#{
  :GREETING &amp;quot;Hello Bob!&amp;quot;
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we&apos;ll define a literal syntax for lambda from &lt;code&gt;rutils&lt;/code&gt; as a separate named read-table:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; &apos;&gt;POFTHEDAY&amp;gt; (defmacro trivial-positional-lambda (body)
             `(lambda (&amp;amp;optional % %%)
                (declare (ignorable %) (ignorable %%))
                ,body))

POFTHEDAY&amp;gt; (defun |^-reader| (stream char)
             (declare (ignore char))
             (let ((sexp (read stream t nil t)))
               `(trivial-positional-lambda
                 ,(if (and (listp sexp) (listp (car sexp)))
                      (cons &amp;#039;progn sexp)
                      sexp))))

POFTHEDAY&amp;gt; (named-readtables:defreadtable
               :lambda
             (:merge :standard)
             (:macro-char #\^ #&amp;#039;|^-reader|))

;; Now we can switch to the new readtable
;; and use new syntax for lambdas:
POFTHEDAY&amp;gt; (named-readtables:in-readtable :lambda)

POFTHEDAY&amp;gt; ^(+ % %%)
#&amp;lt;FUNCTION (LAMBDA (&amp;amp;OPTIONAL % %%)) {2252593B}&amp;gt;

POFTHEDAY&amp;gt; (funcall *
                    2
                    3)
5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Named readtables has yet another useful feature - it integrates with SLIME. When you have a &lt;code&gt;(in-readtable)&lt;/code&gt; call after you package definition, SLIME will know what &lt;code&gt;readtable&lt;/code&gt; to use when you hit &lt;code&gt;Ctrl-C Ctrl-C&lt;/code&gt; on defuns.&lt;/p&gt;
&lt;p&gt;That is what &lt;code&gt;in-readtable&lt;/code&gt; expands to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:in-readtable :interpol-syntax)

;; It expands to:
(eval-when (:compile-toplevel
            :load-toplevel
            :execute)
  (setf *readtable*
        (named-readtables:ensure-readtable
         &amp;#039;:interpol-syntax))
  (when (find-package :swank)
    (named-readtables::%frob-swank-readtable-alist
     *package*
     *readtable*)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This &lt;code&gt;%frob-swank-readtable-alist&lt;/code&gt; modifies &lt;code&gt;swank:*readtable-alist*&lt;/code&gt; to make it know what readtable should be used for the package. But a comment to this code says it is a &lt;code&gt;KLUDGE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Interesting, how this will or should work in the LispWorks?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-change-case</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0076-cl-change-case.html</link>
            <description>&lt;p&gt;This cool library is able to transform strings from one time of delimiters to others.&lt;/p&gt;
&lt;p&gt;Previously I&apos;ve used &lt;a href=&quot;http://quickdocs.org/kebab/&quot;&gt;kebab&lt;/a&gt;, but &lt;code&gt;cl-change-case&lt;/code&gt; is much more featureful:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-change-case:path-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo/bar/bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:path-case &amp;quot;foo-bar_bazz&amp;quot;)
&amp;quot;foo/bar/bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:path-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo/bar/bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:sentence-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;Foo bar bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:snake-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo_bar_bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:camel-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;fooBarBazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:no-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo bar bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:header-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;Foo-Bar-Bazz&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When this can be useful? In cases when you interop with other systems, but want to use &lt;code&gt;:this-style-of-symbols&lt;/code&gt; in Lisp. For example, you might generate identifiers for JavaScript or Python.&lt;/p&gt;
&lt;p&gt;Another case is when you want to output labels for UI. Here I have a function which will render an HTML table describing a &lt;code&gt;CLOS&lt;/code&gt; object:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ((created-at :initarg :created-at)
              (name :initarg :name)
              (num-posts :initarg :num-posts)))

POFTHEDAY&amp;gt; (defun render (object)
             (let* ((class-name (type-of object))
                    (class (find-class class-name))
                    (slots (closer-mop:class-slots class)))
               (cl-who:with-html-output-to-string (*standard-output* nil :indent t)
                 (:table
                  (loop for slot in slots
                        for slot-name = (closer-mop:slot-definition-name slot)
                        for label = (cl-change-case:sentence-case (symbol-name slot-name))
                        for value = (rutils:fmt &amp;quot;~A&amp;quot;
                                                (slot-value object slot-name))
                        do (cl-who:htm
                            (:tr
                             (:th (cl-who:esc label))
                             (:td (cl-who:esc value)))))))))

POFTHEDAY&amp;gt; (render (make-instance &amp;#039;user
                                  :name &amp;quot;Bob&amp;quot;
                                  :created-at &amp;quot;2020-05-22&amp;quot;
                                  :num-posts 42))
&amp;quot;
&amp;lt;table&amp;gt;
&amp;lt;tr&amp;gt;
  &amp;lt;th&amp;gt;Created at&amp;lt;/th&amp;gt;
  &amp;lt;td&amp;gt;2020-05-22&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
  &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
  &amp;lt;td&amp;gt;Bob&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
  &amp;lt;th&amp;gt;Num posts&amp;lt;/th&amp;gt;
  &amp;lt;td&amp;gt;42&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
            <title>cl-who</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0075-cl-who.html</link>
            <description>&lt;p&gt;Today we continue to investigate &lt;code&gt;poftheday&lt;/code&gt;&apos;s &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0063-asdf-viz.html&quot;&gt;dependencies&lt;/a&gt; and will look at the well known &lt;code&gt;cl-who&lt;/code&gt; library. &lt;code&gt;CL-Who&lt;/code&gt; is a library Edmund Weitz and provides a DSL for HTML generation.&lt;/p&gt;
&lt;p&gt;For those who are not familiar with &lt;code&gt;cl-who&lt;/code&gt;, here is a quick example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-who:with-html-output-to-string (s)
             (:body
              (:p &amp;quot;Hello world!&amp;quot;)))
&amp;quot;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you want to insert a variable, you have to use a local macro &lt;code&gt;esc&lt;/code&gt;. There is also another macro - &lt;code&gt;str&lt;/code&gt;, and it very easy to misuse it. That is one of the reasons why I don&apos;t like &lt;code&gt;cl-who&lt;/code&gt; and prefer &lt;code&gt;spinneret&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let&apos;s pretend we want to output a username in the comment list on our page. The correct way to do so will be:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ((name :initarg :name
                    :reader get-name)))

POFTHEDAY&amp;gt; (let ((user (make-instance
                        &amp;#039;user
                        :name &amp;quot;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;&amp;quot;))
                 (comment-text &amp;quot;Hello from Bob!&amp;quot;))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:div :class &amp;quot;comment&amp;quot;
                     (:div :class &amp;quot;username&amp;quot;
                           (cl-who:esc (get-name user)))
                     (:div :class &amp;quot;text&amp;quot;
                           (cl-who:esc comment-text)))))
&amp;quot;
&amp;lt;div class=&amp;#039;comment&amp;#039;&amp;gt;
  &amp;lt;div class=&amp;#039;username&amp;#039;&amp;gt;Bob &amp;amp;lt;script&amp;amp;gt;alert(&amp;amp;#039;You are hacked&amp;amp;#039;)&amp;amp;lt;/script&amp;amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;#039;text&amp;#039;&amp;gt;Hello from Bob!
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As I said, this was a correct way, but it is very easy to misuse &lt;code&gt;cl-who&lt;/code&gt; and make your beautiful site open for &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS attacks&lt;/a&gt;. You only have to use &lt;code&gt;str&lt;/code&gt; instead of &lt;code&gt;esc&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((user (make-instance
                        &amp;#039;user
                        :name &amp;quot;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;&amp;quot;))
                 (comment-text &amp;quot;Hello from Bob!&amp;quot;))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:div :class &amp;quot;comment&amp;quot;
                     (:div :class &amp;quot;username&amp;quot;
                           (cl-who:str (get-name user)))
                     (:div :class &amp;quot;text&amp;quot;
                           (cl-who:str comment-text)))))
&amp;quot;
&amp;lt;div class=&amp;#039;comment&amp;#039;&amp;gt;
  &amp;lt;div class=&amp;#039;username&amp;#039;&amp;gt;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;#039;text&amp;#039;&amp;gt;Hello from Bob!
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here &lt;code&gt;script&lt;/code&gt; tag that was not escaped. This way, any code an evil user will enter as his name will be executed in other users browsers.&lt;/p&gt;
&lt;p&gt;Another inconvenience of &lt;code&gt;cl-who&lt;/code&gt; is that you have to use &lt;code&gt;htm&lt;/code&gt; macro if want to mix &lt;code&gt;HTML&lt;/code&gt; pieces with lisp forms. For example, if you want to output a list of items, this will not work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; &apos;&gt;POFTHEDAY&amp;gt; (let ((list (list 1 2 3 4 5)))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:ul
                (loop for item in list
                      do (:li (cl-who:esc
                               (format nil &amp;quot;Item number ~A&amp;quot;
                                       item)))))))
; in: LET ((LIST (LIST 1 2 3 4 5)))
;     (:LI (CL-WHO:ESC (FORMAT NIL &amp;quot;Item number ~A&amp;quot; POFTHEDAY::ITEM)))
; 
; caught STYLE-WARNING:
;   undefined function: :LI
; 
; compilation unit finished
;   Undefined function:
;     :LI
;   caught 1 STYLE-WARNING condition&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You have to wrap &lt;code&gt;:li&lt;/code&gt; form with a &lt;code&gt;htm&lt;/code&gt; macro, like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((list (list 1 2 3 4 5)))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:ul
                (loop for item in list
                      do (cl-who:htm
                          (:li 
                           (cl-who:esc
                            (format nil &amp;quot;Item number ~A&amp;quot;
                                    item))))))))
&amp;quot;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Item number 1
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 2
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 3
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 4
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 5
&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The Common Lisp Project of the Day&apos;s blog uses &lt;code&gt;cl-who&lt;/code&gt; only because this is a dependency of the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/03/0018-cl-bootstrap.html&quot;&gt;cl-bootstrap&lt;/a&gt;. Personally, I prefer &lt;code&gt;spinneret&lt;/code&gt; and probably will rewrite #poftheday site to use it.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>lquery</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0074-lquery.html</link>
            <description>&lt;p&gt;Yesterday I&apos;ve &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0073-clss.html&quot;&gt;reviewed a library&lt;/a&gt; to apply CSS3 selectors to the HTML nodes, produced by &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;Plump&lt;/a&gt;. And this allowed making our Twitter crawler more concise.&lt;/p&gt;
&lt;p&gt;lQuery will take it to the next stage because it makes possible to describe a whole HTML processing pipeline in a very declarative way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:$ (initialize (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))
             &amp;quot;.tweet-text&amp;quot;
             (render-text)
             (map (alexandria:curry
                   #&amp;#039;str:shorten 40))
             (lt 5))
#(&amp;quot;Hi, I&amp;#039;m a #gamedev. My latest project...&amp;quot;
  &amp;quot;Aw thank you, here&amp;#039;s the whole story ...&amp;quot;
  &amp;quot;&amp;#x96E8;&amp;#x6797;pic.twitter.com/BFwcd0AWSE&amp;quot;
  &amp;quot;&amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q&amp;quot;
  &amp;quot;The logic of Splatoon.pic.twitter.com...&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Each &quot;call&quot; here is a special function which is applied either to a set of &lt;code&gt;HTML&lt;/code&gt; nodes or to a single node in a set.&lt;/p&gt;
&lt;p&gt;All &lt;code&gt;lquery&lt;/code&gt; functions are defined in the &lt;code&gt;lquery-funcs&lt;/code&gt; package and documented &lt;a href=&quot;https://shinmera.github.io/lquery/#PACKAGE%20LQUERY-FUNCS&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can add your own functions for data processing, using &lt;a href=&quot;https://shinmera.github.io/lquery/#MACRO-FUNCTION%20LQUERY%3ADEFINE-LQUERY-FUNCTION&quot;&gt;define-lquery-function&lt;/a&gt; and &lt;a href=&quot;https://shinmera.github.io/lquery/#MACRO-FUNCTION%20LQUERY%3ADEFINE-LQUERY-LIST-FUNCTION&quot;&gt;define-lquery-list-function&lt;/a&gt;. This can be useful if some operation is frequent. For example, let&apos;s write a function to make strings shorter!&lt;/p&gt;
&lt;p&gt;First, we need to define lQuery function. It will process one node at a time:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:define-lquery-function shorten (text max-length)
             (check-type text string)
             (check-type max-length (integer 0 65535))
             (str:shorten max-length text))

LQUERY-FUNCS::SHORTEN&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use it to make our web crawler even more beautiful!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:$ (initialize (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))
             &amp;quot;.tweet-text&amp;quot;
             (render-text)
             (shorten 40)
             (lt 5))
#(&amp;quot;Hi, I&amp;#039;m a #gamedev. My latest project...&amp;quot;
  &amp;quot;Aw thank you, here&amp;#039;s the whole story ...&amp;quot;
  &amp;quot;&amp;#x96E8;&amp;#x6797;pic.twitter.com/BFwcd0AWSE&amp;quot;
  &amp;quot;&amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q&amp;quot;
  &amp;quot;The logic of Splatoon.pic.twitter.com...&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are other &lt;code&gt;define-*&lt;/code&gt; macros in &lt;code&gt;lquery&lt;/code&gt; as well. Read its documentation to learn more about how to extend it. It would be nice if &lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@shinmera&lt;/a&gt; add more examples on how to extend &lt;code&gt;lquery&lt;/code&gt;!&lt;/p&gt;
</description>
        </item>
        <item>
            <title>clss</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0073-clss.html</link>
            <description>&lt;p&gt;Today we continue to review web crawling tools from &lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@shinmera&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This review will be short because I&apos;ll reuse code from the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;previous post&lt;/a&gt; and improve it by replacing four lines with only one.&lt;/p&gt;
&lt;p&gt;A system CLSS allows you to use CSS3 selectors when working with HTML nodes produced by &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;Plump&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here is how we can improve our simple Twitter crawler:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *raw-html*
             (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))

POFTHEDAY&amp;gt; (defvar *html* (plump:parse *raw-html*))

           ;; Now I&amp;#039;ll replaced these lines
           ;; with one clss:select call:
           ;;
           ;; (remove-if-not (lambda (div)
           ;;                  (str:containsp &amp;quot;tweet-text&amp;quot;
           ;;                                 (plump:attribute div &amp;quot;class&amp;quot;)))
           ;;                (plump:get-elements-by-tag-name *html* &amp;quot;p&amp;quot;))
POFTHEDAY&amp;gt; (defparameter *posts*
             (clss:select &amp;quot;.tweet-text&amp;quot; *html*))

POFTHEDAY&amp;gt; (type-of *posts*)
(VECTOR T 40)

POFTHEDAY&amp;gt; (loop repeat 5
                 for post across *posts*
                 for full-text = (plump:render-text post)
                 for short-text = (str:shorten 40 full-text)
                 do (format t &amp;quot;- ~A~2%&amp;quot; short-text))
- Hi, I&amp;#039;m a #gamedev. My latest project...

- &amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q

- The logic of Splatoon.pic.twitter.com...

- The AI is extremely rough still, but ...

- pic.twitter.com/Cpvqytce5G&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As a bonus, I want to show you that &lt;code&gt;CLSS&lt;/code&gt; supports even pseudoclasses:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (plump:parse &amp;quot;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;quot;)
#&amp;lt;PLUMP-DOM:ROOT {10031A93A3}&amp;gt;

POFTHEDAY&amp;gt; (clss:select &amp;quot;li:first-child&amp;quot;
                        *)
#(#&amp;lt;PLUMP-DOM:ELEMENT li {100322C883}&amp;gt;)

POFTHEDAY&amp;gt; (plump:serialize * nil)
&amp;quot;&amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sadly, the documentation says only that it supports almost all CSS3 selectors, but don&apos;t enumerate them. However, we can learn this from sources:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (rutils:hash-table-keys
            clss::*pseudo-selectors*)
(&amp;quot;ROOT&amp;quot; &amp;quot;NTH-CHILD&amp;quot; &amp;quot;NTH-LAST-CHILD&amp;quot; &amp;quot;NTH-OF-TYPE&amp;quot; &amp;quot;NTH-LAST-OF-TYPE&amp;quot;
 &amp;quot;FIRST-CHILD&amp;quot; &amp;quot;LAST-CHILD&amp;quot; &amp;quot;FIRST-OF-TYPE&amp;quot; &amp;quot;LAST-OF-TYPE&amp;quot; &amp;quot;ONLY-CHILD&amp;quot;
 &amp;quot;ONLY-OF-TYPE&amp;quot; &amp;quot;EMPTY&amp;quot; &amp;quot;LINK&amp;quot; &amp;quot;VISITED&amp;quot; &amp;quot;ACTIVE&amp;quot; &amp;quot;HOVER&amp;quot; &amp;quot;FOCUS&amp;quot; &amp;quot;TARGET&amp;quot;
 &amp;quot;LANG&amp;quot; &amp;quot;ENABLED&amp;quot; &amp;quot;DISABLED&amp;quot; &amp;quot;CHECKED&amp;quot; &amp;quot;FIRST-LINE&amp;quot; &amp;quot;FIRST-LETTER&amp;quot; &amp;quot;BEFORE&amp;quot;
 &amp;quot;AFTER&amp;quot; &amp;quot;WARNING&amp;quot; &amp;quot;NOT&amp;quot; &amp;quot;FIRST-ONLY&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is a &lt;code&gt;clss:define-pseudo-selector&lt;/code&gt; macro which allows defining a custom pseudo-selector.&lt;/p&gt;
&lt;p&gt;Yesterday we&apos;ll learn about a more sophisticated tool for web scraping - lQuery.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>plump</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html</link>
            <description>&lt;p&gt;Yesterday &lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@Shinmera&lt;/a&gt; mentioned Plump in the &lt;a href=&quot;https://twitter.com/XH004&quot;&gt;@XH004&lt;/a&gt;&apos;s &lt;a href=&quot;https://twitter.com/XH004/status/1261861964818440192&quot;&gt;thread&lt;/a&gt; about performance optimization of it&apos;s new HTML parser. And I decided to review it.&lt;/p&gt;
&lt;p&gt;Plump is able to parse, modify and serialize an HTML back.&lt;/p&gt;
&lt;p&gt;Let&apos;s write a crawler to grab @shinmera&apos;s posts from Twitter!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *raw-html*
              (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))

POFTHEDAY&amp;gt; (defvar *html* (plump:parse *raw-html*))

;; We need all divs with class &amp;quot;tweet-text&amp;quot;
POFTHEDAY&amp;gt; (defvar *posts*
             (remove-if-not (lambda (div)
                              (str:containsp &amp;quot;tweet-text&amp;quot;
                                             (plump:attribute div &amp;quot;class&amp;quot;)))
                            (plump:get-elements-by-tag-name *html* &amp;quot;p&amp;quot;)))

POFTHEDAY&amp;gt; (loop for post in (rutils:take 5 *posts*)
                 for full-text = (plump:render-text post)
                 for short-text = (str:shorten 40 full-text)
                 do (format t &amp;quot;- ~A~2%&amp;quot; short-text))
- 1478 Lighting sketch #onesies https:/...

- Trust Level: Swiss A fridge with cool...

- The arch.pic.twitter.com/gMamJfZ1r4

- &amp;#x3089;&amp;#x304F;&amp;#x304C;&amp;#x304D;&amp;#x3070;&amp;#x304B;&amp;#x308A;&amp;#x30A2;&amp;#x30C3;&amp;#x30D7;&amp;#x3057;&amp;#x3066;&amp;#x3044;&amp;#x305F;&amp;#x3084;&amp;#x3064;&amp;#x3001;&amp;#x4ECA;&amp;#x5EA6;&amp;#x306F;&amp;#x52D5;&amp;#x304D;&amp;#x307E;&amp;#x3059;&amp;#x3002;&amp;#x9031;&amp;#x672B;&amp;#x306B;&amp;#x30D7;&amp;#x30ED;&amp;#x30AF;&amp;#x30EA;&amp;#x30A8;&amp;#x30A4;&amp;#x30C8;&amp;#x3067;&amp;#x63CF;...

- Shit&amp;#039;s broken. Will be back in a few ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library has more utils for HTML parsing. Read the documentation to learn more.&lt;/p&gt;
&lt;p&gt;If you are going to write crawlers  in Common lisp, I recommend you to use Plump together with another @shimera&apos;s library - &lt;a href=&quot;https://shinmera.github.io/CLSS/&quot;&gt;clss&lt;/a&gt; but we&apos;ll play with it tomorrow :)&lt;/p&gt;
</description>
        </item>
        <item>
            <title>parenscript</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0071-parenscript.html</link>
            <description>&lt;p&gt;Parenscript is the CL&apos;s answer to the &lt;a href=&quot;https://clojurescript.org/&quot;&gt;ClojureScript&lt;/a&gt;. It makes possible to write client-side code in Lisp and compile it to the Javascript for running in the Browser.&lt;/p&gt;
&lt;p&gt;I used Parenscript in one application, based on Electron and Weblocks.&lt;/p&gt;
&lt;p&gt;Here is a &lt;a href=&quot;https://github.com/40ants/hacrm/blob/464e931fb7eac7f2b8b0d3f5465ba9c255ec1d2b/src/widgets/contacts-list.lisp#L148-L184&quot;&gt;piece of real code&lt;/a&gt; which uses Parenscript to define a client-side code. This code allows switching between different contacts using shortcuts. It uses &lt;code&gt;jQuery&lt;/code&gt; to access &lt;code&gt;DOM&lt;/code&gt; elements:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(weblocks-parenscript:make-dependency
 (let ((numbers-are-visible nil))
   
   ;; With this code we give user ability to press Alt+1, Alt+2,...
   ;; to select one of first 10 contacts in the list.
   (setf (@ document onkeydown)
         (lambda (e)
           (let ((code (@ e &amp;quot;keyCode&amp;quot;))
                 (numbers (j-query &amp;quot;.contact-list__contact-number&amp;quot;)))
             ((@ console log) &amp;quot;Key down with code:&amp;quot; code)
             
             (cond
               ((= code 18)
                ((@ numbers show))
                (setf numbers-are-visible t))
               ((and (&amp;gt;= 57 code 48))
                ;; If user presed 0, then we&amp;#039;l consider it a 10.
                (when (= code 48)
                  (setf code (+ code 10)))
                
                (let ((contact-number (- code 48)))
                  ((@ console log)
                   &amp;quot;Selecting contact&amp;quot; contact-number)
                  ;; jQuery(&amp;quot;#contact-0 a&amp;quot;).click()
                  ((@ (j-query (+ &amp;quot;#contact-&amp;quot; contact-number &amp;quot; a&amp;quot;))
                      click))))))))
   
   (setf (@ document onkeyup)
         (lambda (e)
           (let ((code (@ e &amp;quot;keyCode&amp;quot;))
                 (numbers (j-query &amp;quot;.contact-list__contact-number&amp;quot;)))
             ((@ console log) &amp;quot;Key up with code:&amp;quot; code)
             
             (cond
               ((= code 18)
                ((@ numbers hide))
                (setf numbers-are-visible nil)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are two ways of using Parenscript:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;You can manually compile a &lt;code&gt;s-exp&lt;/code&gt; into Javascript.&lt;/li&gt;&lt;li&gt;You can use it as an ASDF extension to compile some components   automatically. But this will require the use of additional system   &lt;a href=&quot;https://github.com/gonzojive/paren-files&quot;&gt;paren-files&lt;/a&gt;. We&apos;ll review it later.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Let&apos;s investigate the first way by defining a simple JS function which sums two numbers and shows the result in Web Inspector&apos;s console:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (import &amp;#039;(parenscript:ps
                     parenscript:@))

POFTHEDAY&amp;gt; (ps
             (+ 1 2))
&amp;quot;1 + 2;&amp;quot;

POFTHEDAY&amp;gt; (ps
             (defun foo (a b)
               (+ a b)))
&amp;quot;function foo(a, b) {
    return a + b;
};&amp;quot;

POFTHEDAY&amp;gt; (ps
             (defun foo (a b)
               ((@ console log)
                 (+ a b))))
&amp;quot;function foo(a, b) {
    __PS_MV_REG = [];
    return console.log(a + b);
};&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you might notice, instead of dot notation, Parenscript uses a &lt;code&gt;@&lt;/code&gt; macro.&lt;/p&gt;
&lt;p&gt;Parenscript supports a subset of &lt;code&gt;loop&lt;/code&gt; macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps
             (loop :with collection =  &amp;#039;(1 2 3)
                   :for i :in collection
                   :do ((@ console log)
                       i)))
&amp;quot;(function () {
    var collection = [1, 2, 3];
    var _js8 = collection.length;
    for (var _js7 = 0; _js7 &amp;lt; _js8; _js7 += 1) {
        var i = collection[_js7];
        console.log(i);
    };
})();&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And also it allows you to write custom macroses which will expand into the Javascript Code!&lt;/p&gt;
&lt;p&gt;There are few ways to define macroses for Parenscript here is one of them. We&apos;ll define a macro in Common Lisp code and then will call this macro from Parenscript:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps:defpsmacro awhen (test &amp;amp;body body)
             `(let ((it ,test))
                (when it
                  ,@body)))

POFTHEDAY&amp;gt; (ps
             (let ((some-var 100500))
               (awhen (= some-var 42)
                 ((@ console log)
                  &amp;quot;Some var is&amp;quot; it))))
&amp;quot;(function () {
    var someVar = 100500;
    var it = someVar === 42;
    __PS_MV_REG = [];
    return it ? console.log(&amp;#039;Some var is&amp;#039;, it) : null;
})();&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Rewriting macro for Parenscript is not a fan. Why you should do this if macro already exists for Common Lisp?&lt;/p&gt;
&lt;p&gt;You shouldn&apos;t!&lt;/p&gt;
&lt;p&gt;Import existing Lisp macro into the Parenscript!&lt;/p&gt;
&lt;p&gt;In the next example, I&apos;ll show you how to reuse anaphoric &lt;code&gt;if&lt;/code&gt; from &lt;code&gt;rutils&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; First, let&amp;#039;s eval our form in Common Lisp
POFTHEDAY&amp;gt; (rutils:aif (= 1 2)
              (list :status :ok
                    :result rutils:it)
              (list :status :fail
                    :result rutils:it))
(:STATUS :FAIL :RESULT NIL)

;; By default it will not work:
POFTHEDAY&amp;gt; (ps
             (rutils:aif (= 1 2)
                (list :status :ok
                      :result it)
                (list :status :fail
                      :result it)))
&amp;quot;aif(1 === 2,
     [&amp;#039;status&amp;#039;, &amp;#039;ok&amp;#039;, &amp;#039;result&amp;#039;, it],
     [&amp;#039;status&amp;#039;, &amp;#039;fail&amp;#039;, &amp;#039;result&amp;#039;, it]);&amp;quot;

;; But we can import the macro:

POFTHEDAY&amp;gt; (ps:import-macros-from-lisp
            &amp;#039;rutils:aif)

POFTHEDAY&amp;gt; (ps
             (rutils:aif (= 1 2)
                (list :status :ok
                      :result it)
                (list :status :fail
                      :result it)))
&amp;quot;(function () {
    var it = 1 === 2;
    return it ? [&amp;#039;status&amp;#039;, &amp;#039;ok&amp;#039;, &amp;#039;result&amp;#039;, it]
              : [&amp;#039;status&amp;#039;, &amp;#039;fail&amp;#039;, &amp;#039;result&amp;#039;, it];
})();&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also built-in support for HTML rendering. Parenscript supports &lt;a href=&quot;https://github.com/franzinc/aserve/blob/master/doc/htmlgen.md&quot;&gt;Allegro HTMLGen DSL&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps
             (defun render-link (user)
               (ps:ps-html
                ((:a :href (+ &amp;quot;https://foo.bar/&amp;quot;
                               (get-nickname user)))
                 (get-name user)))))
&amp;quot;function renderLink(user) {
    __PS_MV_REG = [];
    return [&amp;#039;&amp;lt;a href=\\\&amp;quot;&amp;#039;,
            &amp;#039;https://foo.bar/&amp;#039; + getNickname(user),
            &amp;#039;\\\&amp;quot;&amp;gt;&amp;#039;,
             getName(user),
            &amp;#039;&amp;lt;/a&amp;gt;&amp;#039;].join(&amp;#039;&amp;#039;);
};&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And &lt;a href=&quot;https://edicl.github.io/cl-who/&quot;&gt;CL-WHO&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps
             (defun render-link (user)
               (ps:who-ps-html
                (:a :href (+ &amp;quot;https://foo.bar/&amp;quot;
                              (get-nickname user))
                 (get-name user)))))
&amp;quot;function renderLink(user) {
    __PS_MV_REG = [];
    return [&amp;#039;&amp;lt;a href=\\\&amp;quot;&amp;#039;,
            &amp;#039;https://foo.bar/&amp;#039; + getNickname(user),
            &amp;#039;\\\&amp;quot;&amp;gt;&amp;#039;,
             getName(user),
            &amp;#039;&amp;lt;/a&amp;gt;&amp;#039;].join(&amp;#039;&amp;#039;);
};&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With Parenscript you can create client-side applications or code for running on Node.js. All of this, using Common Lisp power. Isn&apos;t it cool?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>split-sequence</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0070-split-sequence.html</link>
            <description>&lt;p&gt;This is the utility library with a single purpose â€“ to split, dissect, cut, cleave and partition sequences.&lt;/p&gt;
&lt;p&gt;In the simplest form it is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (split-sequence:split-sequence
            #\Space
            &amp;quot;Bob loves Alice!&amp;quot;)
(&amp;quot;Bob&amp;quot; &amp;quot;loves&amp;quot; &amp;quot;Alice!&amp;quot;)
16&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is also is able to split only N times, split from the and to remove empty subsequences:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0))
(#(1 2 3 4) #(5 6 7) #(8 9) #())

POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0)
            :remove-empty-subseqs t)
(#(1 2 3 4) #(5 6 7) #(8 9))

POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0)
            :remove-empty-subseqs t
            :from-end t
            :count 1)
(#(8 9))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also &lt;code&gt;split-sequence-if&lt;/code&gt; and &lt;code&gt;split-sequence-if-not&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defstruct word text)
POFTHEDAY&amp;gt; (defstruct white-space)

POFTHEDAY&amp;gt; (defmethod print-object ((obj word) stream)
             (format stream &amp;quot;&amp;lt;WORD ~A&amp;gt;&amp;quot; (word-text obj)))

POFTHEDAY&amp;gt; (defmethod print-object ((obj white-space) stream)
             (format stream &amp;quot;&amp;lt;SPACE&amp;gt;&amp;quot;))

POFTHEDAY&amp;gt; (defparameter *tokens*
             (list (make-word :text &amp;quot;Bob&amp;quot;)
                   (make-white-space)
                   (make-word :text &amp;quot;loves&amp;quot;)
                   (make-white-space)
                   (make-word :text &amp;quot;Alice&amp;quot;)))
(&amp;lt;WORD Bob&amp;gt; &amp;lt;SPACE&amp;gt; &amp;lt;WORD loves&amp;gt; &amp;lt;SPACE&amp;gt; &amp;lt;WORD Alice&amp;gt;)

POFTHEDAY&amp;gt; (split-sequence:split-sequence-if
            (lambda (item)
              (typep item &amp;#039;white-space))
              *tokens*)
((&amp;lt;WORD Bob&amp;gt;) (&amp;lt;WORD loves&amp;gt;) (&amp;lt;WORD Alice&amp;gt;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By the way, a library &lt;code&gt;cl-utilities&lt;/code&gt;, reviewed &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0068-cl-utilities.html&quot;&gt;two days ago&lt;/a&gt;, and &lt;code&gt;rutils&lt;/code&gt;, reviewed at &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0065-rutils.html&quot;&gt;the start of the week&lt;/a&gt;, are also include these splitting functions, but code is different. Probably this is because &lt;code&gt;split-sequence&lt;/code&gt; evolved since it was copied into  &lt;code&gt;cl-utilities&lt;/code&gt; and &lt;code&gt;rutils&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This simple &lt;a href=&quot;https://ultralisp.org/search/?query=symbol%3Asplit-sequence-if&quot;&gt;search query&lt;/a&gt; on Ultralisp.org shows that this functionality is also available in some other Common Lisp libraries.&lt;/p&gt;
&lt;h2&gt;Update 1&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/fwoaroof/status/1261736998412271616&quot;&gt;@fwoaroof&lt;/a&gt; gave me a &lt;a href=&quot;https://github.com/fiddlerwoaroof/fwoar.lisputils/blob/master/string-utils/split.lisp&quot;&gt;link to the split function&lt;/a&gt;, optimized to work with very long (&gt; 1G) strings.&lt;/p&gt;
&lt;h2&gt;Update 2&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/stevelosh&quot;&gt;@stevelosh&lt;/a&gt; &lt;a href=&quot;https://twitter.com/stevelosh/status/1261749896656424967&quot;&gt;sent me a code&lt;/a&gt; which uses &lt;code&gt;split-sequence&lt;/code&gt; to make an iterator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun spliterator (delimiter sequence &amp;amp;key (test #&amp;#039;eql) (key #&amp;#039;identity))
  (let ((start 0)
        (length (length sequence)))
    (lambda ()
      (if (= start length)
          (values nil nil)
          (multiple-value-bind (next end)
              (split-sequence:split-sequence delimiter sequence
                                             :count 1 :start start
                                             :key key :test test)
            (setf start end)
            (values (first next) t))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Thank you, Steve!&lt;/p&gt;
</description>
        </item>
        <item>
            <title>osicat</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0069-osicat.html</link>
            <description>&lt;p&gt;This is a library, created by &lt;a href=&quot;https://twitter.com/nsiivola&quot;&gt;@nsiivola&lt;/a&gt;. It is well suited if you need to call &lt;a href=&quot;https://en.wikipedia.org/wiki/POSIX&quot;&gt;POSIX&lt;/a&gt; API. &lt;code&gt;Osicat&lt;/code&gt; has outdated documentation but it is has docstring and the code is well structured.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;osicat&lt;/code&gt;, you can work with files and make other system calls.&lt;/p&gt;
&lt;p&gt;Here is an example of how you can get information about files:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (osicat:file-kind &amp;quot;/tmp&amp;quot;)
:SYMBOLIC-LINK

POFTHEDAY&amp;gt; (osicat:read-link &amp;quot;/tmp&amp;quot;)
#P&amp;quot;private/tmp&amp;quot;

POFTHEDAY&amp;gt; (osicat:file-permissions &amp;quot;/tmp&amp;quot;)
(:USER-READ :USER-WRITE :USER-EXEC :GROUP-READ
 :GROUP-WRITE :GROUP-EXEC :OTHER-READ
 :OTHER-WRITE :OTHER-EXEC :STICKY)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I&apos;ve never used &lt;code&gt;osicat&lt;/code&gt; before. When preparing this review, I noticed it has functions to make such system calls like &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and I wondered if it will be faster to implement such a handy operation like reading lines from a file using these calls instead of streams.&lt;/p&gt;
&lt;p&gt;So, let&apos;s compare the performance of the native Common Lisp streams and raw POSIX calls when we want to read all lines of the large log file.&lt;/p&gt;
&lt;p&gt;I have a 26M log file &lt;code&gt;/var/log/install.log&lt;/code&gt; on my disk.&lt;/p&gt;
&lt;p&gt;As a baseline, we&apos;ll take the performance of the &lt;code&gt;uiop:read-file-lines&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (time
            (length
             (uiop:read-file-lines *filename*)))
Evaluation took:
  0.610 seconds of real time
  0.610132 seconds of total run time (0.549502 user, 0.060630 system)
  [ Run times consist of 0.119 seconds GC time, and 0.492 seconds non-GC time. ]
  100.00% CPU
  1,346,441,256 processor cycles
  300,767,776 bytes consed
  
76560 ;; This is the number of lines&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how we can open a file and read a piece into the buffer, using POSIX system calls:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *filename* &amp;quot;/var/log/install.log&amp;quot;)

POFTHEDAY&amp;gt; (defparameter *fd* (osicat-posix:open *filename*
                                                 osicat-posix::o-rdonly))

POFTHEDAY&amp;gt; (cffi:with-foreign-pointer-as-string ((buf buf-size) 1024)
             (osicat-posix:read *fd* buf buf-size))
&amp;quot;Feb 25 09:58:02 localhost opendirectoryd[231]: opendirectoryd (build 692.000) launched - installer mode
Feb 25 09:58:02 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Initialize trigger support
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] created endpoint for mach service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Registered RPC over XPC &amp;#039;reset_cache&amp;#039; for service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Registered RPC over XPC &amp;#039;reset_online&amp;#039; for service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Re&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But we want to read a string, separated by newlines. In this scenario, code will be more complex:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun read-lines (filename &amp;amp;key (separator #\Newline))
  (declare (optimize (speed 3) (debug 0) (safety 0))
  
  (let ((fd (osicat-posix:open filename
                               osicat-posix::o-rdonly))
        (current-string &amp;quot;&amp;quot;)
        (separator (char-code separator)))
    (uiop:while-collecting (collect-string)
      (unwind-protect
           (cffi:with-foreign-pointer (buf 1024 buf-size)
             (flet ((collect-lines (num-bytes)
                      (loop with begin of-type fixnum = 0
                            for offset of-type fixnum from 0 below num-bytes
                            for char = (cffi:mem-ref buf :unsigned-char offset)
                            
                            when (= char separator)
                              do (let ((part (cffi:foreign-string-to-lisp
                                              buf
                                              :offset begin
                                              :count (- offset begin))))
                                   (setf begin (1+ offset))
                                   
                                   (cond ((zerop (length current-string))
                                          (collect-string part))
                                         (t
                                          (collect-string
                                           (concatenate &amp;#039;string part))
                                          (setf current-string &amp;quot;&amp;quot;))))
                            finally (unless (= offset num-bytes)
                                      (setf current-string
                                            (concatenate &amp;#039;string
                                                         current-string
                                                         (cffi:foreign-string-to-lisp
                                                          buf
                                                          :offset begin
                                                          :count (- offset begin))))))))
               (loop for num-bytes of-type fixnum = (osicat-posix:read fd buf buf-size)
                     while (not (zerop num-bytes))
                     do (collect-lines num-bytes)
                     finally (when (not (zerop (length current-string)))
                               (collect-string current-string))))))
        (osicat-posix:close fd))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I tried to put proper type declarations, and performance is 2.3 times faster than &lt;code&gt;uiop:read-file-lines&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (time (length (read-lines *filename*)))
Evaluation took:
  0.233 seconds of real time
  0.232355 seconds of total run time (0.203830 user, 0.028525 system)
  [ Run times consist of 0.036 seconds GC time, and 0.197 seconds non-GC time. ]
  99.57% CPU
  514,348,582 processor cycles
  87,868,848 bytes consed
  
76560&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the sad part of this story. If we compare performance with such interpreted language as Python, then Python will be 4.5 times faster than my optimized function :(&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; python&apos;&gt;In [1]: def read_lines(filename):
   ...:     l = []
   ...:     with open(filename) as f:
   ...:         for line in f:
   ...:             l.append(line)
   ...:     return l

In [2]: def count_lines(filename):
   ...:     return len(read_lines(filename))

In [3]: %timeit count_lines(&amp;quot;/var/log/install.log&amp;quot;)
55.5 ms &amp;#xB1; 3.94 ms per loop (mean &amp;#xB1; std. dev. of 7 runs, 10 loops each)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CFFI uses &lt;a href=&quot;https://github.com/cl-babel/babel&quot;&gt;Babel&lt;/a&gt; to convert bytes to string but makes few unnecessary calls.&lt;/p&gt;
&lt;p&gt;I tried to extract UTF-8 decoder from the &lt;a href=&quot;https://github.com/cl-babel/babel&quot;&gt;Babel&lt;/a&gt; into a single function, but it&apos;s internals too complex, to finish this task in one evening.&lt;/p&gt;
&lt;p&gt;If somebody knows fast Common Lisp implementation of the UTF-8 decoder, let me know and I&apos;ll update my article with new code. Probably &lt;code&gt;trivial-utf-8:utf-8-bytes-to-string&lt;/code&gt; will do the job if I&apos;ll modify it to read bytes from the alien pointer?&lt;/p&gt;
&lt;h2&gt;Update 1&lt;/h2&gt;&lt;p&gt;I&apos;ve runned the code under a SBCL&apos;s statistical profiler and build this flamegraph:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0069/read-lines-flamegraph.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;It shows that:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;50% of time wasted in my function read-line&lt;/li&gt;&lt;li&gt;10% is utf-8  decoding&lt;/li&gt;&lt;li&gt;40% â€“ in a &quot;read&quot; syscall.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;This is strange, because when I remove all code which converts utf-8 and just reads whole file piece by piece it takes 25-30ms only.&lt;/p&gt;
&lt;p&gt;This can be improved if I&apos;ll use 10kb buffer instead of 1kb. In this case reading will take 7ms.&lt;/p&gt;
&lt;p&gt;Also, I found that the most consing occur in the &lt;code&gt;cffi:foreign-string-to-lisp&lt;/code&gt; call.&lt;/p&gt;
&lt;h2&gt;Update 2&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/luismbo&quot;&gt;@luismbo&lt;/a&gt; &lt;a href=&quot;https://twitter.com/luismbo/status/1261738185203298306&quot;&gt;found&lt;/a&gt; that CPython uses a &lt;a href=&quot;https://github.com/python/cpython/blob/a1d12bb1197d9335fcb62aad7fb0df56098197ac/Objects/unicodeobject.c#L4549&quot;&gt;shortcut trick&lt;/a&gt; to not decode string if it consists of ASCII characters. That is why it can be more performant than my Common Lisp &lt;code&gt;read-lines&lt;/code&gt; function.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-utilities</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0068-cl-utilities.html</link>
            <description>&lt;p&gt;This is a yet another utilities library. It is used by only a single &lt;code&gt;poftheday&lt;/code&gt;&apos;s dependency - &lt;code&gt;xml-emitter&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0064-xml-emitter.html&quot;&gt;reviewed&lt;/a&gt; on 10 May.&lt;/p&gt;
&lt;p&gt;Amount of tools in this toolbox is not very large and mostly covered by more popular libs.&lt;/p&gt;
&lt;p&gt;For example, it has a macro for item collection. For example, this macro can be useful to collect hash key value pairs into an alist. But this facility is also available from UIOP:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (cl-utilities:collecting
               (maphash
                (lambda (key value)
                  (cl-utilities:collect
                      (cons key value)))
                the-hash)))
((:FOO . &amp;quot;bar&amp;quot;) (:BLAH . &amp;quot;minor&amp;quot;))

;; Here is the similar code using UIOP
POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (uiop:while-collecting (collect)
               (maphash
                (lambda (key value)
                  (collect (cons key value)))
                the-hash)))
((:FOO . &amp;quot;bar&amp;quot;) (:BLAH . &amp;quot;minor&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But UIOP is more powerful allows you to collect many types of items simultaneously. For example, we might want to collect keys and values into the separate lists:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (uiop:while-collecting (collect-key collect-value)
               (maphash
                (lambda (key value)
                  (collect-key key)
                  (collect-value value))
                the-hash)))
(:FOO :BLAH)
(&amp;quot;bar&amp;quot; &amp;quot;minor&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An interesting feature is a function &lt;code&gt;read-delimited&lt;/code&gt;. It can be useful to read chars from the stream into a limited buffer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (with-input-from-string (stream &amp;quot;The string
with multiple
lines.&amp;quot;)
             (let ((buffer (str:repeat 10 &amp;quot; &amp;quot;)))
               (loop for num-chars = (cl-utilities:read-delimited
                                      buffer
                                      stream)
                     while (not (zerop num-chars))
                     do (format t &amp;quot;~A chars were read~%&amp;quot;
                                num-chars)
                        (format t &amp;quot;Buffer: ~A~2%&amp;quot;
                                (str:substring 0 num-chars
                                               buffer)))))
10 chars were read
Buffer: The string

10 chars were read
Buffer: with multi

2 chars were read
Buffer: le

6 chars were read
Buffer: lines.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Probably this facility is also covered by more popular utility library?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>parse-declarations</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0067-parse-declarations.html</link>
            <description>&lt;p&gt;This library provides advanced facilities to work with declaration forms and can be useful for writing macroses.&lt;/p&gt;
&lt;p&gt;I wasn&apos;t able to imagine a good enough example, but luckily, this library has &lt;a href=&quot;https://common-lisp.net/project/parse-declarations/manual/html_node/Examples.html#Examples&quot;&gt;great documentation&lt;/a&gt; and I stole this example from it.&lt;/p&gt;
&lt;p&gt;It is an analogue of the standard &lt;code&gt;let*&lt;/code&gt; form which expands into multiple &lt;code&gt;let&lt;/code&gt; forms. Maybe you know, &lt;code&gt;let*&lt;/code&gt; can have declarations inside. But to process them correctly, you need to place a declaration related to each variable into its own &lt;code&gt;let&lt;/code&gt; form.&lt;/p&gt;
&lt;p&gt;Here is how this can be done with &lt;code&gt;parse-declarations&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; System and package names are different:
POFTHEDAY&amp;gt; (ql:quickload :parse-declarations-1.0)

POFTHEDAY&amp;gt; (import &amp;#039;(tcr.parse-declarations-1.0::parse-body
                     tcr.parse-declarations-1.0:filter-declaration-env
                     tcr.parse-declarations-1.0:build-declarations
                     tcr.parse-declarations-1.0:check-declaration-env
                     tcr.parse-declarations-1.0:parse-declarations))

POFTHEDAY&amp;gt; (defmacro custom-let* (bindings &amp;amp;body body &amp;amp;environment macro-env)
    (flet ((normalize-binding (binding)
             (cond ((symbolp binding)    `(,binding nil))
                   ((null (cdr binding)) `(,(car binding) nil))
                   (t binding))))
      (multiple-value-bind (real-body decls) (parse-body body :documentation nil)
        (let ((decl-env (parse-declarations decls macro-env)))
          (check-declaration-env decl-env :unknown-allowed nil :warn-only t)
          (labels ((generate-nested-lets (bindings &amp;amp;optional used-binding-names)
                     (if (null bindings)
                         `(locally
                              ,@(build-declarations &amp;#039;declare
                                  (filter-declaration-env decl-env :include :free)
                                  (filter-declaration-env decl-env :include :bound
                                                          :not-affecting used-binding-names))
                            ,@real-body)
                         (destructuring-bind ((var value) . more-bindings) bindings
                           `(let ((,var ,value))
                              ,@(build-declarations &amp;#039;declare
                                  (filter-declaration-env decl-env :affecting `(,var)))
                              ,(generate-nested-lets more-bindings (cons var used-binding-names)))))))
            (generate-nested-lets (mapcar #&amp;#039;normalize-binding bindings)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pay attention that &lt;code&gt;parse-body&lt;/code&gt; function is intentionally is not exported to not conflict with &lt;code&gt;alexandria:parse-body&lt;/code&gt;. Author considered that many lispers do import all alexandria&apos;s symbols into their packages.&lt;/p&gt;
&lt;p&gt;By the way, Alexandria implements only a simple version of the &lt;code&gt;parse-body&lt;/code&gt; function and does not support all advanced features of &lt;code&gt;parse-declarations&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But let&apos;s see how our macro will expand!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (custom-let* ((a 1)
                         (b (* a 0.01)))
             (declare (type fixnum a)
                      (type single-float b))
             (list a b))

;; It expands to -&amp;gt;
(let ((a 1))
  (declare (type fixnum a))
  (let ((b (* a 0.01)))
    (declare (type single-float b))
    (locally (list a b))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, our single declaration form was torn apart and each part placed into the correct place inside nested &lt;code&gt;lets&lt;/code&gt;. Great!&lt;/p&gt;
&lt;h2&gt;How does it work&lt;/h2&gt;&lt;p&gt;There are three phases:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;parse-declarations&lt;/code&gt; parses whole body passed to the &lt;code&gt;custom-let*&lt;/code&gt; and   extracts forms related to type declarations. It stores them in a   special &lt;code&gt;env&lt;/code&gt; object.&lt;/li&gt;&lt;li&gt;&lt;code&gt;filter-declaration-env&lt;/code&gt; allows us to select only declarations related   to the needed variable.&lt;/li&gt;&lt;li&gt;&lt;code&gt;build-declarations&lt;/code&gt; transforms one or many &lt;code&gt;env&lt;/code&gt; objects into the lists   of symbols so that they can be used for the macro-expansion.&lt;/li&gt;&lt;/ul&gt;
</description>
        </item>
        <item>
            <title>str</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0066-str.html</link>
            <description>&lt;p&gt;This is a single purpose utility library. Before switching to the &lt;code&gt;str&lt;/code&gt;, I used &lt;code&gt;cl-strings&lt;/code&gt;, but &lt;code&gt;str&lt;/code&gt; library is more consistent.&lt;/p&gt;
&lt;p&gt;I like that unlike standard functions, &lt;code&gt;str&lt;/code&gt; is able to work with chars and strings as delimiter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (str:split #\Space
                      &amp;quot;Foo bar bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)

POFTHEDAY&amp;gt; (str:split &amp;quot; &amp;quot;
                      &amp;quot;Foo bar bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)

;; Also it is able to skip empty strings:
POFTHEDAY&amp;gt; (str:split &amp;quot; &amp;quot;
                      &amp;quot;Foo   bar   bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;bazz&amp;quot;)

POFTHEDAY&amp;gt; (str:split-omit-nulls &amp;quot; &amp;quot;
                      &amp;quot;Foo   bar   bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Parameter ordering can seem a little strange at first glance, but they&apos;ve made this way to make it easier to &lt;code&gt;curry&lt;/code&gt; functions.&lt;/p&gt;
&lt;p&gt;For example, if we have a multiline text and want to put ellipsis at the end of string longer than X, we might do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *text* &amp;quot;
This line is much longer than we need.
This one is also too long.

I can&amp;#039;t belive!
&amp;quot;&amp;quot;&amp;quot;)

POFTHEDAY&amp;gt; (str:unlines
            (mapcar (alexandria:curry #&amp;#039;str:shorten 20)
                    (str:lines *text*)))
&amp;quot;
This line is much...
This one is also ...

I can&amp;#039;t belive!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BTW &lt;code&gt;str&lt;/code&gt; has very &lt;a href=&quot;https://vindarel.github.io/cl-str/&quot;&gt;cool documentation&lt;/a&gt;. I&apos;d like to have such docs for other CL libraries.&lt;/p&gt;
</description>
        </item>
    </channel>
</rss>