<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>split-sequence</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0070-split-sequence.html</link>
            <description>&lt;p&gt;This is the utility library with a single purpose – to split, dissect, cut, cleave and partition sequences.&lt;/p&gt;
&lt;p&gt;In the simplest form it is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (split-sequence:split-sequence
            #\Space
            &amp;quot;Bob loves Alice!&amp;quot;)
(&amp;quot;Bob&amp;quot; &amp;quot;loves&amp;quot; &amp;quot;Alice!&amp;quot;)
16&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is also is able to split only N times, split from the and to remove empty subsequences:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0))
(#(1 2 3 4) #(5 6 7) #(8 9) #())

POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0)
            :remove-empty-subseqs t)
(#(1 2 3 4) #(5 6 7) #(8 9))

POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0)
            :remove-empty-subseqs t
            :from-end t
            :count 1)
(#(8 9))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also &lt;code&gt;split-sequence-if&lt;/code&gt; and &lt;code&gt;split-sequence-if-not&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defstruct word text)
POFTHEDAY&amp;gt; (defstruct white-space)

POFTHEDAY&amp;gt; (defmethod print-object ((obj word) stream)
             (format stream &amp;quot;&amp;lt;WORD ~A&amp;gt;&amp;quot; (word-text obj)))

POFTHEDAY&amp;gt; (defmethod print-object ((obj white-space) stream)
             (format stream &amp;quot;&amp;lt;SPACE&amp;gt;&amp;quot;))

POFTHEDAY&amp;gt; (defparameter *tokens*
             (list (make-word :text &amp;quot;Bob&amp;quot;)
                   (make-white-space)
                   (make-word :text &amp;quot;loves&amp;quot;)
                   (make-white-space)
                   (make-word :text &amp;quot;Alice&amp;quot;)))
(&amp;lt;WORD Bob&amp;gt; &amp;lt;SPACE&amp;gt; &amp;lt;WORD loves&amp;gt; &amp;lt;SPACE&amp;gt; &amp;lt;WORD Alice&amp;gt;)

POFTHEDAY&amp;gt; (split-sequence:split-sequence-if
            (lambda (item)
              (typep item &amp;#039;white-space))
              *tokens*)
((&amp;lt;WORD Bob&amp;gt;) (&amp;lt;WORD loves&amp;gt;) (&amp;lt;WORD Alice&amp;gt;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By the way, a library &lt;code&gt;cl-utilities&lt;/code&gt;, reviewed &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0068-cl-utilities.html&quot;&gt;two days ago&lt;/a&gt;, and &lt;code&gt;rutils&lt;/code&gt;, reviewed at &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0065-rutils.html&quot;&gt;the start of the week&lt;/a&gt;, are also include these splitting functions, but code is different. Probably this is because &lt;code&gt;split-sequence&lt;/code&gt; evolved since it was copied into  &lt;code&gt;cl-utilities&lt;/code&gt; and &lt;code&gt;rutils&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This simple &lt;a href=&quot;https://ultralisp.org/search/?query=symbol%3Asplit-sequence-if&quot;&gt;search query&lt;/a&gt; on Ultralisp.org shows that this functionality is also available in some other Common Lisp libraries.&lt;/p&gt;
&lt;h2&gt;Update 1&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/fwoaroof/status/1261736998412271616&quot;&gt;@fwoaroof&lt;/a&gt; gave me a &lt;a href=&quot;https://github.com/fiddlerwoaroof/fwoar.lisputils/blob/master/string-utils/split.lisp&quot;&gt;link to the split function&lt;/a&gt;, optimized to work with very long (&gt; 1G) strings.&lt;/p&gt;
&lt;h2&gt;Update 2&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/stevelosh&quot;&gt;@stevelosh&lt;/a&gt; &lt;a href=&quot;https://twitter.com/stevelosh/status/1261749896656424967&quot;&gt;sent me a code&lt;/a&gt; which uses &lt;code&gt;split-sequence&lt;/code&gt; to make an iterator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun spliterator (delimiter sequence &amp;amp;key (test #&amp;#039;eql) (key #&amp;#039;identity))
  (let ((start 0)
        (length (length sequence)))
    (lambda ()
      (if (= start length)
          (values nil nil)
          (multiple-value-bind (next end)
              (split-sequence:split-sequence delimiter sequence
                                             :count 1 :start start
                                             :key key :test test)
            (setf start end)
            (values (first next) t))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Thank you, Steve!&lt;/p&gt;
</description>
        </item>
        <item>
            <title>osicat</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0069-osicat.html</link>
            <description>&lt;p&gt;This is a library, created by &lt;a href=&quot;https://twitter.com/nsiivola&quot;&gt;@nsiivola&lt;/a&gt;. It is well suited if you need to call &lt;a href=&quot;https://en.wikipedia.org/wiki/POSIX&quot;&gt;POSIX&lt;/a&gt; API. &lt;code&gt;Osicat&lt;/code&gt; has outdated documentation but it is has docstring and the code is well structured.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;osicat&lt;/code&gt;, you can work with files and make other system calls.&lt;/p&gt;
&lt;p&gt;Here is an example of how you can get information about files:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (osicat:file-kind &amp;quot;/tmp&amp;quot;)
:SYMBOLIC-LINK

POFTHEDAY&amp;gt; (osicat:read-link &amp;quot;/tmp&amp;quot;)
#P&amp;quot;private/tmp&amp;quot;

POFTHEDAY&amp;gt; (osicat:file-permissions &amp;quot;/tmp&amp;quot;)
(:USER-READ :USER-WRITE :USER-EXEC :GROUP-READ
 :GROUP-WRITE :GROUP-EXEC :OTHER-READ
 :OTHER-WRITE :OTHER-EXEC :STICKY)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I&apos;ve never used &lt;code&gt;osicat&lt;/code&gt; before. When preparing this review, I noticed it has functions to make such system calls like &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and I wondered if it will be faster to implement such a handy operation like reading lines from a file using these calls instead of streams.&lt;/p&gt;
&lt;p&gt;So, let&apos;s compare the performance of the native Common Lisp streams and raw POSIX calls when we want to read all lines of the large log file.&lt;/p&gt;
&lt;p&gt;I have a 26M log file &lt;code&gt;/var/log/install.log&lt;/code&gt; on my disk.&lt;/p&gt;
&lt;p&gt;As a baseline, we&apos;ll take the performance of the &lt;code&gt;uiop:read-file-lines&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (time
            (length
             (uiop:read-file-lines *filename*)))
Evaluation took:
  0.610 seconds of real time
  0.610132 seconds of total run time (0.549502 user, 0.060630 system)
  [ Run times consist of 0.119 seconds GC time, and 0.492 seconds non-GC time. ]
  100.00% CPU
  1,346,441,256 processor cycles
  300,767,776 bytes consed
  
76560 ;; This is the number of lines&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how we can open a file and read a piece into the buffer, using POSIX system calls:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *filename* &amp;quot;/var/log/install.log&amp;quot;)

POFTHEDAY&amp;gt; (defparameter *fd* (osicat-posix:open *filename*
                                                 osicat-posix::o-rdonly))

POFTHEDAY&amp;gt; (cffi:with-foreign-pointer-as-string ((buf buf-size) 1024)
             (osicat-posix:read *fd* buf buf-size))
&amp;quot;Feb 25 09:58:02 localhost opendirectoryd[231]: opendirectoryd (build 692.000) launched - installer mode
Feb 25 09:58:02 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Initialize trigger support
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] created endpoint for mach service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Registered RPC over XPC &amp;#039;reset_cache&amp;#039; for service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Registered RPC over XPC &amp;#039;reset_online&amp;#039; for service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Re&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But we want to read a string, separated by newlines. In this scenario, code will be more complex:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun read-lines (filename &amp;amp;key (separator #\Newline))
  (declare (optimize (speed 3) (debug 0) (safety 0))
  
  (let ((fd (osicat-posix:open filename
                               osicat-posix::o-rdonly))
        (current-string &amp;quot;&amp;quot;)
        (separator (char-code separator)))
    (uiop:while-collecting (collect-string)
      (unwind-protect
           (cffi:with-foreign-pointer (buf 1024 buf-size)
             (flet ((collect-lines (num-bytes)
                      (loop with begin of-type fixnum = 0
                            for offset of-type fixnum from 0 below num-bytes
                            for char = (cffi:mem-ref buf :unsigned-char offset)
                            
                            when (= char separator)
                              do (let ((part (cffi:foreign-string-to-lisp
                                              buf
                                              :offset begin
                                              :count (- offset begin))))
                                   (setf begin (1+ offset))
                                   
                                   (cond ((zerop (length current-string))
                                          (collect-string part))
                                         (t
                                          (collect-string
                                           (concatenate &amp;#039;string part))
                                          (setf current-string &amp;quot;&amp;quot;))))
                            finally (unless (= offset num-bytes)
                                      (setf current-string
                                            (concatenate &amp;#039;string
                                                         current-string
                                                         (cffi:foreign-string-to-lisp
                                                          buf
                                                          :offset begin
                                                          :count (- offset begin))))))))
               (loop for num-bytes of-type fixnum = (osicat-posix:read fd buf buf-size)
                     while (not (zerop num-bytes))
                     do (collect-lines num-bytes)
                     finally (when (not (zerop (length current-string)))
                               (collect-string current-string))))))
        (osicat-posix:close fd))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I tried to put proper type declarations, and performance is 2.3 times faster than &lt;code&gt;uiop:read-file-lines&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (time (length (read-lines *filename*)))
Evaluation took:
  0.233 seconds of real time
  0.232355 seconds of total run time (0.203830 user, 0.028525 system)
  [ Run times consist of 0.036 seconds GC time, and 0.197 seconds non-GC time. ]
  99.57% CPU
  514,348,582 processor cycles
  87,868,848 bytes consed
  
76560&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the sad part of this story. If we compare performance with such interpreted language as Python, then Python will be 4.5 times faster than my optimized function :(&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; python&apos;&gt;In [1]: def read_lines(filename):
   ...:     l = []
   ...:     with open(filename) as f:
   ...:         for line in f:
   ...:             l.append(line)
   ...:     return l

In [2]: def count_lines(filename):
   ...:     return len(read_lines(filename))

In [3]: %timeit count_lines(&amp;quot;/var/log/install.log&amp;quot;)
55.5 ms &amp;#xB1; 3.94 ms per loop (mean &amp;#xB1; std. dev. of 7 runs, 10 loops each)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CFFI uses &lt;a href=&quot;https://github.com/cl-babel/babel&quot;&gt;Babel&lt;/a&gt; to convert bytes to string but makes few unnecessary calls.&lt;/p&gt;
&lt;p&gt;I tried to extract UTF-8 decoder from the &lt;a href=&quot;https://github.com/cl-babel/babel&quot;&gt;Babel&lt;/a&gt; into a single function, but it&apos;s internals too complex, to finish this task in one evening.&lt;/p&gt;
&lt;p&gt;If somebody knows fast Common Lisp implementation of the UTF-8 decoder, let me know and I&apos;ll update my article with new code. Probably &lt;code&gt;trivial-utf-8:utf-8-bytes-to-string&lt;/code&gt; will do the job if I&apos;ll modify it to read bytes from the alien pointer?&lt;/p&gt;
&lt;h2&gt;Update 1&lt;/h2&gt;&lt;p&gt;I&apos;ve runned the code under a SBCL&apos;s statistical profiler and build this flamegraph:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0069/read-lines-flamegraph.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;It shows that:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;50% of time wasted in my function read-line&lt;/li&gt;&lt;li&gt;10% is utf-8  decoding&lt;/li&gt;&lt;li&gt;40% – in a &quot;read&quot; syscall.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;This is strange, because when I remove all code which converts utf-8 and just reads whole file piece by piece it takes 25-30ms only.&lt;/p&gt;
&lt;p&gt;This can be improved if I&apos;ll use 10kb buffer instead of 1kb. In this case reading will take 7ms.&lt;/p&gt;
&lt;p&gt;Also, I found that the most consing occur in the &lt;code&gt;cffi:foreign-string-to-lisp&lt;/code&gt; call.&lt;/p&gt;
&lt;h2&gt;Update 2&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/luismbo&quot;&gt;@luismbo&lt;/a&gt; &lt;a href=&quot;https://twitter.com/luismbo/status/1261738185203298306&quot;&gt;found&lt;/a&gt; that CPython uses a &lt;a href=&quot;https://github.com/python/cpython/blob/a1d12bb1197d9335fcb62aad7fb0df56098197ac/Objects/unicodeobject.c#L4549&quot;&gt;shortcut trick&lt;/a&gt; to not decode string if it consists of ASCII characters. That is why it can be more performant than my Common Lisp &lt;code&gt;read-lines&lt;/code&gt; function.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-utilities</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0068-cl-utilities.html</link>
            <description>&lt;p&gt;This is a yet another utilities library. It is used by only a single &lt;code&gt;poftheday&lt;/code&gt;&apos;s dependency - &lt;code&gt;xml-emitter&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0064-xml-emitter.html&quot;&gt;reviewed&lt;/a&gt; on 10 May.&lt;/p&gt;
&lt;p&gt;Amount of tools in this toolbox is not very large and mostly covered by more popular libs.&lt;/p&gt;
&lt;p&gt;For example, it has a macro for item collection. For example, this macro can be useful to collect hash key value pairs into an alist. But this facility is also available from UIOP:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (cl-utilities:collecting
               (maphash
                (lambda (key value)
                  (cl-utilities:collect
                      (cons key value)))
                the-hash)))
((:FOO . &amp;quot;bar&amp;quot;) (:BLAH . &amp;quot;minor&amp;quot;))

;; Here is the similar code using UIOP
POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (uiop:while-collecting (collect)
               (maphash
                (lambda (key value)
                  (collect (cons key value)))
                the-hash)))
((:FOO . &amp;quot;bar&amp;quot;) (:BLAH . &amp;quot;minor&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But UIOP is more powerful allows you to collect many types of items simultaneously. For example, we might want to collect keys and values into the separate lists:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (uiop:while-collecting (collect-key collect-value)
               (maphash
                (lambda (key value)
                  (collect-key key)
                  (collect-value value))
                the-hash)))
(:FOO :BLAH)
(&amp;quot;bar&amp;quot; &amp;quot;minor&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An interesting feature is a function &lt;code&gt;read-delimited&lt;/code&gt;. It can be useful to read chars from the stream into a limited buffer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (with-input-from-string (stream &amp;quot;The string
with multiple
lines.&amp;quot;)
             (let ((buffer (str:repeat 10 &amp;quot; &amp;quot;)))
               (loop for num-chars = (cl-utilities:read-delimited
                                      buffer
                                      stream)
                     while (not (zerop num-chars))
                     do (format t &amp;quot;~A chars were read~%&amp;quot;
                                num-chars)
                        (format t &amp;quot;Buffer: ~A~2%&amp;quot;
                                (str:substring 0 num-chars
                                               buffer)))))
10 chars were read
Buffer: The string

10 chars were read
Buffer: with multi

2 chars were read
Buffer: le

6 chars were read
Buffer: lines.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Probably this facility is also covered by more popular utility library?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>parse-declarations</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0067-parse-declarations.html</link>
            <description>&lt;p&gt;This library provides advanced facilities to work with declaration forms and can be useful for writing macroses.&lt;/p&gt;
&lt;p&gt;I wasn&apos;t able to imagine a good enough example, but luckily, this library has &lt;a href=&quot;https://common-lisp.net/project/parse-declarations/manual/html_node/Examples.html#Examples&quot;&gt;great documentation&lt;/a&gt; and I stole this example from it.&lt;/p&gt;
&lt;p&gt;It is an analogue of the standard &lt;code&gt;let*&lt;/code&gt; form which expands into multiple &lt;code&gt;let&lt;/code&gt; forms. Maybe you know, &lt;code&gt;let*&lt;/code&gt; can have declarations inside. But to process them correctly, you need to place a declaration related to each variable into its own &lt;code&gt;let&lt;/code&gt; form.&lt;/p&gt;
&lt;p&gt;Here is how this can be done with &lt;code&gt;parse-declarations&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; System and package names are different:
POFTHEDAY&amp;gt; (ql:quickload :parse-declarations-1.0)

POFTHEDAY&amp;gt; (import &amp;#039;(tcr.parse-declarations-1.0::parse-body
                     tcr.parse-declarations-1.0:filter-declaration-env
                     tcr.parse-declarations-1.0:build-declarations
                     tcr.parse-declarations-1.0:check-declaration-env
                     tcr.parse-declarations-1.0:parse-declarations))

POFTHEDAY&amp;gt; (defmacro custom-let* (bindings &amp;amp;body body &amp;amp;environment macro-env)
    (flet ((normalize-binding (binding)
             (cond ((symbolp binding)    `(,binding nil))
                   ((null (cdr binding)) `(,(car binding) nil))
                   (t binding))))
      (multiple-value-bind (real-body decls) (parse-body body :documentation nil)
        (let ((decl-env (parse-declarations decls macro-env)))
          (check-declaration-env decl-env :unknown-allowed nil :warn-only t)
          (labels ((generate-nested-lets (bindings &amp;amp;optional used-binding-names)
                     (if (null bindings)
                         `(locally
                              ,@(build-declarations &amp;#039;declare
                                  (filter-declaration-env decl-env :include :free)
                                  (filter-declaration-env decl-env :include :bound
                                                          :not-affecting used-binding-names))
                            ,@real-body)
                         (destructuring-bind ((var value) . more-bindings) bindings
                           `(let ((,var ,value))
                              ,@(build-declarations &amp;#039;declare
                                  (filter-declaration-env decl-env :affecting `(,var)))
                              ,(generate-nested-lets more-bindings (cons var used-binding-names)))))))
            (generate-nested-lets (mapcar #&amp;#039;normalize-binding bindings)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pay attention that &lt;code&gt;parse-body&lt;/code&gt; function is intentionally is not exported to not conflict with &lt;code&gt;alexandria:parse-body&lt;/code&gt;. Author considered that many lispers do import all alexandria&apos;s symbols into their packages.&lt;/p&gt;
&lt;p&gt;By the way, Alexandria implements only a simple version of the &lt;code&gt;parse-body&lt;/code&gt; function and does not support all advanced features of &lt;code&gt;parse-declarations&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But let&apos;s see how our macro will expand!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (custom-let* ((a 1)
                         (b (* a 0.01)))
             (declare (type fixnum a)
                      (type single-float b))
             (list a b))

;; It expands to -&amp;gt;
(let ((a 1))
  (declare (type fixnum a))
  (let ((b (* a 0.01)))
    (declare (type single-float b))
    (locally (list a b))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, our single declaration form was torn apart and each part placed into the correct place inside nested &lt;code&gt;lets&lt;/code&gt;. Great!&lt;/p&gt;
&lt;h2&gt;How does it work&lt;/h2&gt;&lt;p&gt;There are three phases:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;parse-declarations&lt;/code&gt; parses whole body passed to the &lt;code&gt;custom-let*&lt;/code&gt; and   extracts forms related to type declarations. It stores them in a   special &lt;code&gt;env&lt;/code&gt; object.&lt;/li&gt;&lt;li&gt;&lt;code&gt;filter-declaration-env&lt;/code&gt; allows us to select only declarations related   to the needed variable.&lt;/li&gt;&lt;li&gt;&lt;code&gt;build-declarations&lt;/code&gt; transforms one or many &lt;code&gt;env&lt;/code&gt; objects into the lists   of symbols so that they can be used for the macro-expansion.&lt;/li&gt;&lt;/ul&gt;
</description>
        </item>
        <item>
            <title>str</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0066-str.html</link>
            <description>&lt;p&gt;This is a single purpose utility library. Before switching to the &lt;code&gt;str&lt;/code&gt;, I used &lt;code&gt;cl-strings&lt;/code&gt;, but &lt;code&gt;str&lt;/code&gt; library is more consistent.&lt;/p&gt;
&lt;p&gt;I like that unlike standard functions, &lt;code&gt;str&lt;/code&gt; is able to work with chars and strings as delimiter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (str:split #\Space
                      &amp;quot;Foo bar bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)

POFTHEDAY&amp;gt; (str:split &amp;quot; &amp;quot;
                      &amp;quot;Foo bar bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)

;; Also it is able to skip empty strings:
POFTHEDAY&amp;gt; (str:split &amp;quot; &amp;quot;
                      &amp;quot;Foo   bar   bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;bazz&amp;quot;)

POFTHEDAY&amp;gt; (str:split-omit-nulls &amp;quot; &amp;quot;
                      &amp;quot;Foo   bar   bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Parameter ordering can seem a little strange at first glance, but they&apos;ve made this way to make it easier to &lt;code&gt;curry&lt;/code&gt; functions.&lt;/p&gt;
&lt;p&gt;For example, if we have a multiline text and want to put ellipsis at the end of string longer than X, we might do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *text* &amp;quot;
This line is much longer than we need.
This one is also too long.

I can&amp;#039;t belive!
&amp;quot;&amp;quot;&amp;quot;)

POFTHEDAY&amp;gt; (str:unlines
            (mapcar (alexandria:curry #&amp;#039;str:shorten 20)
                    (str:lines *text*)))
&amp;quot;
This line is much...
This one is also ...

I can&amp;#039;t belive!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BTW &lt;code&gt;str&lt;/code&gt; has very &lt;a href=&quot;https://vindarel.github.io/cl-str/&quot;&gt;cool documentation&lt;/a&gt;. I&apos;d like to have such docs for other CL libraries.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>rutils</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0065-rutils.html</link>
            <description>&lt;p&gt;Rutils translated as Radical Utilities. It is a collection of many useful utilities. Some of the utilities can be found in other libraries, for example, arrow macro or short notation for lambdas.&lt;/p&gt;
&lt;p&gt;There is an interesting &lt;a href=&quot;https://github.com/vseloved/rutils/blob/master/docs/ann-rutils.md&quot;&gt;document&lt;/a&gt; which describes why &lt;code&gt;rutils&lt;/code&gt; is so radical. In short - it provides a reader macro for hash tables and short aliases for many common lisp operators and generic accessors. &lt;/p&gt;
&lt;p&gt;Previously I didn&apos;t dig into the &lt;code&gt;rutils&lt;/code&gt; documentation and used only a few functions to work with lists. But now I found a &lt;a href=&quot;https://github.com/vseloved/rutils/blob/master/docs/tutorial.md&quot;&gt;great tutorial&lt;/a&gt; covering most &lt;code&gt;rutils&lt;/code&gt; features. I recommend you to spend few evenings reading it and trying different code samples.&lt;/p&gt;
&lt;p&gt;Here is a small example which demonstrates how hash table syntax and generic accessors work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:in-readtable rutils:rutils-readtable)

POFTHEDAY&amp;gt; (import &amp;#039;rutils:?)

POFTHEDAY&amp;gt; (let ((obj #h(:foo &amp;#039;(1 2 3))))
             (? obj :foo 1))
2

;; It also works with curly braces:
POFTHEDAY&amp;gt; (let ((obj #{:foo &amp;#039;(1 2 3)}))
             (? obj :foo 1))
2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here a question mark is an abbreviation for &lt;code&gt;rutils:generic-elt&lt;/code&gt; generic and you can define a custom method to access different kinds of containers.&lt;/p&gt;
&lt;p&gt;I definitely will try to use more of &lt;code&gt;rutils&lt;/code&gt; in my code now.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>xml-emitter</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0064-xml-emitter.html</link>
            <description>&lt;p&gt;This library can be used to generate XML. You can use it for outputting any XML, but I use its builtin helpers to generate RSS feed.&lt;/p&gt;
&lt;p&gt;Here is how to generate RSS feed in Common Lisp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (with-output-to-string (s)
             (xml-emitter:with-rss2 (s :encoding &amp;quot;utf-8&amp;quot;)
               (xml-emitter:rss-channel-header &amp;quot;Common Lisp Project of the Day&amp;quot; 
                                               &amp;quot;https://poftheday.org&amp;quot;)
               (xml-emitter:rss-item &amp;quot;First post&amp;quot;
                                     :description &amp;quot;Hello World&amp;quot;
                                     :category &amp;quot;lisp&amp;quot;)))

&amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;utf-8\&amp;quot;?&amp;gt;
&amp;lt;rss version=\&amp;quot;2.0\&amp;quot;&amp;gt;
    &amp;lt;channel&amp;gt;
        &amp;lt;title&amp;gt;Common Lisp Project of the Day&amp;lt;/title&amp;gt;
        &amp;lt;link&amp;gt;https://poftheday.org&amp;lt;/link&amp;gt;
        &amp;lt;generator&amp;gt;xml-emitter&amp;lt;/generator&amp;gt;
        &amp;lt;language&amp;gt;en-us&amp;lt;/language&amp;gt;
        &amp;lt;item&amp;gt;
            &amp;lt;title&amp;gt;First post&amp;lt;/title&amp;gt;
            &amp;lt;description&amp;gt;Hello World&amp;lt;/description&amp;gt;
            &amp;lt;category&amp;gt;lisp&amp;lt;/category&amp;gt;
        &amp;lt;/item&amp;gt;
    &amp;lt;/channel&amp;gt;
&amp;lt;/rss&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of cause, you easily can generate any XML as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (with-output-to-string (s)
             (xml-emitter:with-xml-output (s)
               (xml-emitter:with-tag (&amp;quot;address-book&amp;quot;)
                 (xml-emitter:with-tag (&amp;quot;contact&amp;quot;)
                   (xml-emitter:emit-simple-tags
                    :name &amp;quot;Bob&amp;quot;
                    :email &amp;quot;bob@perkins.com&amp;quot;
                    :note &amp;quot;My friend.&amp;quot;))
                 (xml-emitter:with-tag (&amp;quot;contact&amp;quot;)
                   (xml-emitter:emit-simple-tags
                    :name &amp;quot;Mary&amp;quot;
                    :twitter &amp;quot;https://twitter.com/mary&amp;quot;)))))

&amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;ISO-8859-1\&amp;quot;?&amp;gt;
&amp;lt;address-book&amp;gt;
    &amp;lt;contact&amp;gt;
        &amp;lt;name&amp;gt;Bob&amp;lt;/name&amp;gt;
        &amp;lt;email&amp;gt;bob@perkins.com&amp;lt;/email&amp;gt;
        &amp;lt;note&amp;gt;My friend.&amp;lt;/note&amp;gt;
    &amp;lt;/contact&amp;gt;
    &amp;lt;contact&amp;gt;
        &amp;lt;name&amp;gt;Mary&amp;lt;/name&amp;gt;
        &amp;lt;twitter&amp;gt;https://twitter.com/mary&amp;lt;/twitter&amp;gt;
    &amp;lt;/contact&amp;gt;
&amp;lt;/address-book&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Please, note that support for &lt;a href=&quot;https://www.w3schools.com/xml/xml_namespaces.asp&quot;&gt;XML namespaces&lt;/a&gt; is very limited. You can only specify a namespace for some tags. Namespace prefixes are not supported.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>asdf-viz</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0063-asdf-viz.html</link>
            <description>&lt;p&gt;Today I decided it will be more interesting to investigate Lisp systems which I already have as dependencies of my projects. That is why I&apos;ve remembered about &lt;code&gt;asdf-viz&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ASDF-VIZ&lt;/code&gt; is able to render a graph of ASDF systems. It can be installed as Unix scripts using &lt;a href=&quot;https://github.com/roswell/roswell&quot;&gt;Roswell&lt;/a&gt; or used from the REPL.&lt;/p&gt;
&lt;p&gt;Also, you&apos;ll need a &lt;a href=&quot;https://www.graphviz.org/&quot;&gt;Graphviz&lt;/a&gt; program installed.&lt;/p&gt;
&lt;p&gt;Now we&apos;ll render a graph of all dependencies of the &lt;code&gt;poftheday&lt;/code&gt; system:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (setf cl-dot:*dot-path* &amp;quot;/usr/local/bin/dot&amp;quot;)

POFTHEDAY&amp;gt; (asdf-viz:visualize-asdf-hierarchy
            &amp;quot;docs/media/0063/systems.png&amp;quot;
            (list (asdf:find-system :poftheday)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the result:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0063/systems.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Interestingly, &lt;code&gt;asdf-viz&lt;/code&gt; not only can draw a system&apos;s dependencies but also class hierarchies and call graphs.&lt;/p&gt;
&lt;p&gt;Here is a small example, how to render a class hierarchy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (asdf-viz.class-hierarchy:visualize-class-hierarchy
            &amp;quot;docs/media/0063/classes.png&amp;quot;
            (list &amp;#039;cl-org-mode::node))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And this is the resulting graph:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0063/classes.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;I think it might be useful to integrate &lt;code&gt;asdf-viz&lt;/code&gt; into IDE.&lt;/p&gt;
&lt;p&gt;Probably Emacs might show graphs in a separate buffer? Or LispWorks IDE is able to do this?&lt;/p&gt;
&lt;p&gt;P.S. – next system will be chosen from the dependencies of the &lt;code&gt;poftheday&lt;/code&gt; system.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>magic-ed</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0062-magic-ed.html</link>
            <description>&lt;p&gt;This strange library replaces standard &lt;code&gt;cl:ed&lt;/code&gt; function with a new one, which executes editor specified in the &lt;code&gt;EDITOR&lt;/code&gt; environment variable.&lt;/p&gt;
&lt;p&gt;It does not work from SLY, so I had to run a raw REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;* sb-ext:*ed-functions*
 NIL
 * (cl:ed &amp;quot;qlfile&amp;quot;)

 debugger invoked on a SB-INT:EXTENSION-FAILURE in thread
 #&amp;lt;THREAD &amp;quot;main thread&amp;quot; RUNNING {1000518083}&amp;gt;:
   Don&amp;#039;t know how to ED qlfile
 See also:
   The SBCL Manual, Variable *ED-FUNCTIONS*

 Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.

 restarts (invokable by number or by possibly-abbreviated name):
   0: [ABORT] Exit debugger, returning to top level.

 (ED &amp;quot;qlfile&amp;quot;)
 0] ^D
 * (ql:quickload :magic-ed)
 To load &amp;quot;magic-ed&amp;quot;:
   Load 1 ASDF system:
     magic-ed
 ; Loading &amp;quot;magic-ed&amp;quot;

 (:MAGIC-ED)
 * sb-ext:*ed-functions*
 (MAGIC-ED:ED-EDITOR)
 * (cl:ed &amp;quot;qlfile&amp;quot;)
 T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, this library provides a function &lt;code&gt;magic-ed&lt;/code&gt; which is able to return file&apos;s content and evaluate the lisp code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;* (magic-ed:magic-ed &amp;quot;/tmp/foo&amp;quot; :output :string)
 ...
 HERE Vim WAS STARTED AND I EDITED THE FILE
 ...
 &amp;quot;(format t \&amp;quot;Blah~%\&amp;quot;)
 &amp;quot;
 *&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Can somebody tell me when this could be useful if you can just use Emacs and SLIME?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-charms</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0061-cl-charms.html</link>
            <description>&lt;p&gt;Two days ago I &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0059-cl-ncurses.html&quot;&gt;reviewed the cl-ncurses&lt;/a&gt;. &lt;code&gt;CL-Charms&lt;/code&gt; is also a binding to &lt;code&gt;ncurses&lt;/code&gt;, but uses more universal and portable &lt;a href=&quot;https://common-lisp.net/project/cffi/manual/html_node/&quot;&gt;CFFI&lt;/a&gt; instead of &lt;a href=&quot;http://quickdocs.org/uffi/&quot;&gt;UFFI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;By the way, LEM (Common Lisp Emacs) uses &lt;code&gt;cl-charms&lt;/code&gt; for it&apos;s console backend.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CL-Charms&lt;/code&gt; provides a high-level API besides a low level. I&apos;ve ported my previous &lt;code&gt;echo&lt;/code&gt; program to it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun main (&amp;amp;rest argv)
  (declare (ignorable argv))
  (with-curses ()
    (enable-raw-input)
    (enable-extra-keys *standard-window*)
    (disable-echoing)

    (write-string-at-cursor *standard-window*
                            &amp;quot;Type any character to see it in bold:
&amp;quot;)

    (let ((ch (get-char *standard-window*)))

      (cond
        ((eql ch (code-char 265))
         (write-string-at-cursor *standard-window*
                                 &amp;quot;F1 Key pressed&amp;quot;))
        (t
         (write-string-at-cursor *standard-window*
                                 &amp;quot;The pressed key is &amp;quot;)

         (cl-charms/low-level:attron cl-charms/low-level:a_bold)
         (write-string-at-cursor *standard-window*
                                 (format nil &amp;quot;~A~%&amp;quot; ch))
         (cl-charms/low-level:attroff cl-charms/low-level:a_bold)))
      

      (get-char *standard-window*))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Interesting that &lt;code&gt;cl-charms/low-level&lt;/code&gt; package can be used as a drop-in replacement for &lt;code&gt;cl-ncurses&lt;/code&gt; and my second example worked without any changes except a change &lt;a href=&quot;https://github.com/40ants/lisp-project-of-the-day/blob/master/test/0061/window.ros#L11-L12&quot;&gt;in the use clause&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;A few words about portability&lt;/h2&gt;&lt;h3&gt;CL-NCURSES&lt;/h3&gt;&lt;p&gt;I must admit, that working with such kind of bindings can be problematic. For example, I haven&apos;t any problems using neither &lt;code&gt;cl-ncurses&lt;/code&gt; nor &lt;code&gt;cl-charms&lt;/code&gt; on OSX, but there was a problem with starting an example program on Ubuntu Bionic.&lt;/p&gt;
&lt;p&gt;On Ubuntu &lt;code&gt;cl-ncurses&lt;/code&gt; is unable to find &lt;code&gt;libncurses.so&lt;/code&gt; and you have to load it manually like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; These paths are harcoded in the cl-ncurses:
(defvar *ncurses-search-paths*
  #-win32&amp;#039;(&amp;quot;/usr/local/lib64/&amp;quot; &amp;quot;/usr/local/lib/&amp;quot; &amp;quot;/lib64/&amp;quot; &amp;quot;/lib/&amp;quot; &amp;quot;/usr/lib64/&amp;quot; &amp;quot;/usr/lib/&amp;quot;)
  #+win32&amp;#039;(&amp;quot;/users/jacob/src/pdc31dll/&amp;quot;))

;; On Ubuntu Bionic you have to add this
;; before cl-ncurses initscr call:
(uffi:load-foreign-library &amp;quot;/lib/x86_64-linux-gnu/libncurses.so.5.9&amp;quot;
                           :module &amp;quot;cl-ncurses&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;CL-CHARMS&lt;/h3&gt;&lt;p&gt;&lt;code&gt;CL-Charms&lt;/code&gt; has another problem. It requires the &lt;code&gt;libncurses5-dev&lt;/code&gt; package to be installed on Ubuntu. Without that, it has problem when compiling the CFFI Grovel&apos;s files:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;; cc -o /root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel-tmpBF3HHBTQ.o -c -g -Wall -Wundef -Wsign-compare -Wpointer-arith -O3 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -Wunused-parameter -fno-omit-frame-pointer -momit-leaf-frame-pointer -fno-pie -fPIC -I/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.21.0/ /root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel.c
/root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel.c:6:10: fatal error: ncurses.h: No such file or directory
 #include &amp;lt;ncurses.h&amp;gt;
          ^~~~~~~~~~~
compilation terminated.
Unhandled CFFI-GROVEL:GROVEL-ERROR in thread #&amp;lt;error printing a SB-THREAD:THREAD: #&amp;lt;PRINT-NOT-READABLE {10042938A3}&amp;gt;&amp;gt;: Subprocess #&amp;lt;UIOP/LAUNCH-PROGRAM::PROCESS-INFO {100428DCF3}&amp;gt;
 with command (&amp;quot;cc&amp;quot; &amp;quot;-o&amp;quot; &amp;quot;/root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel-tmpBF3HHBTQ.o&amp;quot; &amp;quot;-c&amp;quot; &amp;quot;-g&amp;quot; &amp;quot;-Wall&amp;quot; &amp;quot;-Wundef&amp;quot; &amp;quot;-Wsign-compare&amp;quot; &amp;quot;-Wpointer-arith&amp;quot; &amp;quot;-O3&amp;quot; &amp;quot;-D_LARGEFILE_SOURCE&amp;quot; &amp;quot;-D_LARGEFILE64_SOURCE&amp;quot; &amp;quot;-D_FILE_OFFSET_BITS=64&amp;quot; &amp;quot;-Wunused-parameter&amp;quot; &amp;quot;-fno-omit-frame-pointer&amp;quot; &amp;quot;-momit-leaf-frame-pointer&amp;quot; &amp;quot;-fno-pie&amp;quot; &amp;quot;-fPIC&amp;quot; &amp;quot;-I/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.21.0/&amp;quot; &amp;quot;/root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel.c&amp;quot;)
 exited with error code 1

Backtrace for: #&amp;lt;SB-THREAD:THREAD &amp;quot;main thread&amp;quot; RUNNING {10004F04C3}&amp;gt;
0: (SB-DEBUG::DEBUGGER-DISABLED-HOOK #&amp;lt;CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; {1004291F73}&amp;gt; #&amp;lt;unused argument&amp;gt; :QUIT T)
1: (SB-DEBUG::RUN-HOOK *INVOKE-DEBUGGER-HOOK* #&amp;lt;CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; {1004291F73}&amp;gt;)
2: (INVOKE-DEBUGGER #&amp;lt;CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; {1004291F73}&amp;gt;)
3: (ERROR CFFI-GROVEL:GROVEL-ERROR :FORMAT-CONTROL &amp;quot;~a&amp;quot; :FORMAT-ARGUMENTS (#&amp;lt;UIOP/RUN-PROGRAM:SUBPROCESS-ERROR {10042917F3}&amp;gt;))
4: (CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; #&amp;lt;UIOP/RUN-PROGRAM:SUBPROCESS-ERROR {10042917F3}&amp;gt;)
5: ((FLET &amp;quot;THUNK&amp;quot; :IN CFFI-GROVEL:PROCESS-GROVEL-FILE))&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Possible Solution?&lt;/h3&gt;&lt;p&gt;Probably, &lt;a href=&quot;https://twitter.com/borodust&quot;&gt;@borodust&lt;/a&gt;&apos;s &lt;a href=&quot;https://github.com/borodust/claw&quot;&gt;claw&lt;/a&gt; and &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/04/0041-bodge-blobs-support.html&quot;&gt;bodge-blobs-support&lt;/a&gt; can solve these issues?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>clawk</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0060-clawk.html</link>
            <description>&lt;p&gt;This library provides a DSL for text processing in a way as AWK does. For those who aren&apos;t familiar with it, AWK is a language for text processing.&lt;/p&gt;
&lt;p&gt;AWK reads lines, splits them into the fields and applies some pattern-matching to them.&lt;/p&gt;
&lt;p&gt;CLAWK allows forOB solving similar tasks in Lisp.&lt;/p&gt;
&lt;p&gt;It does not have documentation but there are some examples, based on examples from this AWK book from 1988:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0060/awk-book.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;All examples use file &lt;code&gt;emp.data&lt;/code&gt; as an input:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; text&apos;&gt;Beth    4.00    0
Dan     3.75    0
Kathy   4.00    10
Mark    5.00    20
Mary    5.50    22
Suzie   4.25    18&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An example I want to show you is equivalent to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; bash&apos;&gt;$ awk &amp;#039;$3 &amp;gt; 0 {print $1, $2 * $3}&amp;#039; emp.data
Kathy 40
Mark 100
Mary 121
Suzie 76.5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It counts the salary for each employee.&lt;/p&gt;
&lt;p&gt;Here is Common Lisp version which uses CLAWK:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (for-file-lines (&amp;quot;docs/media/0060/emp.data&amp;quot;)
              (with-fields ((name payrate hours))
                 (when ($&amp;gt; hours 0)
                    ($print name ($* payrate hours)))))

Kathy 40.0 
Mark 100.0 
Mary 121.0 
Suzie 76.5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code is more semantic because we used named fields. However, you can use $1, $2, $3 if you with as well.&lt;/p&gt;
&lt;p&gt;Above example is expanded into such code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(with-open-file (#:g1 &amp;quot;docs/media/0060/emp.data&amp;quot;
                      :direction :input
                      :element-type &amp;#039;character
                      :if-does-not-exist :error)
  (let ((#:g1 #:g1))
    (when (eq #:g1 &amp;#039;t)
      (setq #:g1 *standard-input*))
    (unless (null #:g1)
      (let ((*curfile* nil)
            (*curline* &amp;quot;&amp;quot;)
            (*fnr* -1))
        (macrolet ((clawk::next ()
                     &amp;#039;(throw #:g2)))
          (prog (#:g4)
           #:g2
            (setq #:g4 (read-line #:g1 nil :eof))
            (unless (eq #:g4 :eof)
              (setq *curline* #:g4
                    $0 #:g4)
              (incf *nr*)
              (incf *fnr*)
              (catch &amp;#039;#:g2
                (let* ((#:g3 (split nil (clawk::fs)))
                       (*nf* (length #:g3)))
                  (declare (special *nf*))
                  (destructuring-bind
                      (name payrate hours)
                      #:g3
                    (when ($&amp;gt; hours 0)
                      ($print name ($* payrate hours))))))
              (go #:g2))))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code reads and parses the file, tracks some variables like row number, fields count and more. And calls your code to further processing.&lt;/p&gt;
&lt;p&gt;You can find more examples in this file:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sharplispers/clawk/blob/master/clawktest.lisp&quot;&gt;https://github.com/sharplispers/clawk/blob/master/clawktest.lisp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For me, CLAWK seems a nice tool to process files line by line from Common Lisp.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-ncurses</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0059-cl-ncurses.html</link>
            <description>&lt;p&gt;This library is binding to NCurses. It allows for creating windowing interfaces for the console. With NCurses you can print to any place of the screen, change colors and probably do some other awesome things.&lt;/p&gt;
&lt;p&gt;I took a few examples from the original NCurses documentation:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/index.html&quot;&gt;https://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It was pretty straightforward to port them to Common Lisp.&lt;/p&gt;
&lt;p&gt;The first example just wait for any key and print this key in bold:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun main (&amp;amp;rest argv)
  (declare (ignorable argv))
  (initscr)
  (raw)
  (keypad *stdscr* 1)
  (noecho)
  (printw &amp;quot;Type any character to see it in bold:
&amp;quot;)
  (let ((ch (getch)))
    (cond
      ((= ch 265)
       (printw &amp;quot;F1 Key pressed&amp;quot;))
      (t
       (printw &amp;quot;The pressed key is &amp;quot;)
       (attron a_bold)
       (printw (format nil &amp;quot;~A~%&amp;quot; (code-char ch)))
       (attroff a_bold)))
    (refresh)
    (getch)
    (endwin)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Second example a little bit complex. It uses fetches the size of the terminal and prints &quot;Hello Lisp Word!&quot; in the centre. After that, it draws a border using pseudographics:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0059/ncurses-hello.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here is the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun main (&amp;amp;rest argv)
  &amp;quot;This example is based on:
   https://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/windows.html&amp;quot;
  (declare (ignorable argv))
  (initscr)
  (start-color)
  (init-pair 1
             color_red
             color_black)

  (let ((text &amp;quot;Hello Lisp World!&amp;quot;))
    (multiple-value-bind (screen-height screen-width)
        (get-maxyx *stdscr*)
      (let* ((text-len (length text))
             (box-width (+ text-len 4))
             (box-height 5)
             (box-x (round (/ (- screen-width box-width)
                              2)))
             (box-y (round (/ (- screen-height box-height)
                              2)))
             (plus (char-code #\+))
             (h-line (char-code #\-))
             (v-line (char-code #\|)))

        (attron (color-pair 1))

        ;; It&amp;#039;s time to print a text in the center of the screen:
        (mvprintw (+ box-y 2) (+ box-x 2) text)
        
        ;; Now we&amp;#039;ll draw a border around the box.
        ;; Horizontal lines:
        (mvhline box-y box-x
                 h-line box-width)
        (mvhline (+ box-y (1- box-height)) box-x
                 h-line box-width)
        ;; Vertical lines:
        (mvvline box-y box-x
                 v-line box-height)
        (mvvline box-y (+ box-x (1- box-width))
                 v-line box-height)
        ;; And corners
        (mvaddch box-y box-x
                 plus)
        (mvaddch box-y (+ box-x (1- box-width))
                 plus)
        (mvaddch (+ box-y (1- box-height))
                 (+ box-x (1- box-width))
                 plus)
        (mvaddch (+ box-y (1- box-height)) box-x
                 plus)
        (move 0 0))))

  ;; Wait for key press
  (getch)
  (endwin))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Full examples are available here:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/40ants/lisp-project-of-the-day/tree/master/test/0059&quot;&gt;https://github.com/40ants/lisp-project-of-the-day/tree/master/test/0059&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;That is it. If you need an interactive interface in the console, use cl-ncurses!&lt;/p&gt;
</description>
        </item>
        <item>
            <title>atomics</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0058-atomics.html</link>
            <description>&lt;p&gt;This is a portability library for access to atomic operation primitives such as &lt;code&gt;compare-and-swap&lt;/code&gt;, &lt;code&gt;atomic-incf&lt;/code&gt; and &lt;code&gt;atomic-decf&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Atomic operations are particularly useful for implementing lockless algorithms.&lt;/p&gt;
&lt;p&gt;Here is an example of using compare and swap under SBCL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((foo (list 1 2 3 4)))
             (atomics:cas (car foo)
                          1
                          42)
             foo)

-&amp;gt; (LET ((FOO (LIST 1 2 3 4)))
     (LET ((#:OLD0 1))
       (EQ #:OLD0
           (LET ((#:CONS1 FOO))
             (LET ((#:OLD2 #:OLD0))
               (LET ((#:NEW3 42))
                 (SB-KERNEL:%COMPARE-AND-SWAP-CAR #:CONS1
                                                  #:OLD2
                                                  #:NEW3))))))
     FOO)

(42 2 3 4)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&quot;atomics&quot;, like all &lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@shinmera&apos;s&lt;/a&gt; libraries, has a &lt;a href=&quot;https://shinmera.github.io/atomics/&quot;&gt;good documentation&lt;/a&gt; where you can find details on support for atomics operations in different CL implementations.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>pretty-function</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0057-pretty-function.html</link>
            <description>&lt;p&gt;This small library makes debugging easier when you are using many anonymous functions. With &lt;code&gt;pretty-functions&lt;/code&gt; you can give names to your lambdas.&lt;/p&gt;
&lt;p&gt;Here is a traceback you&apos;ll have with ordinal lambda:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun bar ()
             (error &amp;quot;Hello World!&amp;quot;))

POFTHEDAY&amp;gt; (defun foo (func)
             (funcall func))

POFTHEDAY&amp;gt; (foo (lambda ()
                  (bar)))

-&amp;gt;
Hello World!
   [Condition of type SIMPLE-ERROR]

Restarts:
 0: [RETRY] Retry SLY mREPL evaluation request.
 1: [*ABORT] Return to SLY&amp;#039;s top level.
 2: [ABORT] abort thread (#&amp;lt;THREAD &amp;quot;sly-channel-1-mrepl-remote-1&amp;quot; RUNNING {1003785853}&amp;gt;)

Backtrace:
 0: (BAR)
 1: ((LAMBDA ()))
 2: (SB-INT:SIMPLE-EVAL-IN-LEXENV (FOO (LAMBDA NIL (BAR))) #A&amp;lt;NULL-LEXENV&amp;gt;)
 3: (EVAL (FOO (LAMBDA NIL (BAR))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With &lt;code&gt;pretty-function&lt;/code&gt; we should see the name instead of &lt;code&gt;LAMBDA&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (pretty-function:enable-pretty-function-printing)

POFTHEDAY&amp;gt; (foo (pretty-function:named-lambda bar-caller ()
                  (bar)))

-&amp;gt;
Hello World!
   [Condition of type SIMPLE-ERROR]

Restarts:
 0: [RETRY] Retry SLY mREPL evaluation request.
 1: [*ABORT] Return to SLY&amp;#039;s top level.
 2: [ABORT] abort thread (#&amp;lt;THREAD &amp;quot;sly-channel-1-mrepl-remote-1&amp;quot; RUNNING {100394D853}&amp;gt;)

Backtrace:
 0: (BAR)
 1: ((LAMBDA ()))
 2: (FOO #&amp;lt;FUNCTION (LAMBDA NIL) {2253906B}&amp;gt;)
 3: (SB-INT:SIMPLE-EVAL-IN-LEXENV (FOO (PRETTY-FUNCTION:NAMED-LAMBDA BAR-CALLER NIL (BAR))) #&amp;lt;NULL-LEXENV&amp;gt;)
 4: (EVAL (FOO (PRETTY-FUNCTION:NAMED-LAMBDA BAR-CALLER NIL (BAR))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, it does not work. Probably, because &lt;code&gt;SLY&lt;/code&gt; turns off &lt;code&gt;*pretty-print*&lt;/code&gt; when rendering the traceback. At least, it does not work in SBCL.&lt;/p&gt;
&lt;p&gt;Almost the same result we&apos;ll get if request a backtrace as a list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (block test
               (handler-bind ((error (lambda (c)
                                       (return-from test
                                         (sb-debug:backtrace-as-list 7)))))
                 (foo (pretty-function:named-lambda bar-caller ()
                        (bar)))))

(((FLET &amp;quot;H0&amp;quot; :IN TEST) #&amp;lt;unused argument&amp;gt;)
 (SB-KERNEL::%SIGNAL #&amp;lt;SIMPLE-ERROR &amp;quot;Hello World!&amp;quot; {10050B8763}&amp;gt;)
 (ERROR &amp;quot;Hello World!&amp;quot;)
 (BAR)
 ((LAMBDA () :IN TEST))
 (FOO #&amp;lt;named-lambda BAR-CALLER&amp;gt;)
 ((LAMBDA ())))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Named function has its name only when it is rendered as function&apos;s argument. But anyway, it is useful.&lt;/p&gt;
&lt;p&gt;Probably, it will work better on other supported implementations: Allegro, Clisp, CMU, Lispworks or MCL.&lt;/p&gt;
&lt;p&gt;More complex example uses another macro - &lt;code&gt;named-lambda*&lt;/code&gt;. It allows to use of arbitrary form to return a current name of a lambda function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *f*
             (let ((n 0))
               (pretty-function:named-lambda*
                   ;; a form to return a description
                   (format nil &amp;quot;counter=~A&amp;quot; n)
                   () ;; arguments
                 (incf n))))

POFTHEDAY&amp;gt; *f*
#&amp;lt;named-lambda counter=0&amp;gt;

POFTHEDAY&amp;gt; (funcall *f*)
1

POFTHEDAY&amp;gt; *f*
#&amp;lt;named-lambda counter=1&amp;gt;

POFTHEDAY&amp;gt; (funcall *f*)
2

POFTHEDAY&amp;gt; *f*
#&amp;lt;named-lambda counter=2&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You might want to make a shorter name like &lt;code&gt;&lt;counter=1&gt;&lt;/code&gt;, then you need to use lower-level macro &lt;code&gt;with-function-printer&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *f*
             (let ((n 0))
               (pretty-function:with-function-printer
                   ;; A lambda to wriite a description
                   (lambda (s) (format s &amp;quot;#&amp;lt;counter=~A&amp;gt;&amp;quot; n))
                 ;; A lambda to do a real job
                 (lambda ()
                   (incf n)))))

POFTHEDAY&amp;gt; *f*
#&amp;lt;counter=0&amp;gt;

POFTHEDAY&amp;gt; (funcall *f*)
1

POFTHEDAY&amp;gt; *f*
#&amp;lt;counter=1&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of cause, with Lisp, you always can write your own syntax sugar around this macro.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>trivial-indent</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0056-trivial-indent.html</link>
            <description>&lt;p&gt;This is another great library by &lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@shinmera&lt;/a&gt;. It is a portability layer for defining indentation rules for both SLIME and &lt;a href=&quot;http://joaotavora.github.io/sly/#A-SLY-tour-for-SLIME-users&quot;&gt;SLY&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let&apos;s pretend we have a macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defmacro super-let (name value &amp;amp;body body)
             `(let ((,name ,value))
                ,@body))

POFTHEDAY&amp;gt; (super-let foo
               100500
             (format nil &amp;quot;Foo is ~A&amp;quot; foo))
&amp;quot;Foo is 100500&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what if we want Emacs to indent it like this?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (super-let foo
                      100500
             (format nil &amp;quot;Foo is ~A&amp;quot; foo))
&amp;quot;Foo is 100500&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we can set indentation rule, and &lt;code&gt;trivial-indent&lt;/code&gt; will make it work for both SLIME and SLY:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; This rule says: indent first two arguments
;; with 11 spaces if they are on their own line.
;; And other arguments indent like usual function&amp;#039;s body.
POFTHEDAY&amp;gt; (trivial-indent:define-indentation super-let
               (11 11 &amp;amp;body))

;; And now all super-let form will be indented according to this rule.
POFTHEDAY&amp;gt; (super-let blah
                      &amp;#039;minor
             (format nil &amp;quot;blah -&amp;gt; ~A&amp;quot; blah))
&amp;quot;blah -&amp;gt; MINOR&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I have an advice for you. If you are using &lt;code&gt;SLY&lt;/code&gt;, it might cache indentation rules. When you&apos;ve defined a rule but don&apos;t see an effect, call &lt;code&gt;(slynk:update-indentation-information)&lt;/code&gt; in the REPL.&lt;/p&gt;
&lt;p&gt;Now let&apos;s try to define a more complex indentation rule. Yesterday I wrote such macro for running Genetic Algorithm:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(def macro run-ga ((genome &amp;amp;key (population-size 100)
                                (max-iterations 1000)
                                (survive-ratio 0.5))
                   &amp;amp;body fitness-code)
  (let ((var-names (get-var-names genome)))
    
    (unless genome
      ...)))

;; After that you might run it like this:

(run-ga (((x 0 10)
          (y -10 10)
          (z &amp;#039;(:foo :bar :bazz)))
         :max-iterations 100
         :survive-ratio 0.2)
  
  ;; Our fitness-function
  (abs (- (ecase z
            (:foo 10)
            (:bar 100)
            (:bazz 1000))
           (+ x y))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, without special rules, these algorithm parameters are hard to distinguish from the genom definition (the first argument).&lt;/p&gt;
&lt;p&gt;But what if we want to separate keyword arguments visually and to make this form look like this?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(run-ga (((x 0 10)
          (y -10 10)s
          (z &amp;#039;(:foo :bar :bazz)))
    :max-iterations 100
    :survive-ratio 0.2)
  
  ;; Our fitness-function
  (abs (- (ecase z
            (:foo 10)
            (:bar 100)
            (:bazz 1000))
           (+ x y))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we might define the following rule:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (trivial-indent:define-indentation
               genetic-algorithm:run-ga
               ((&amp;amp;whole &amp;amp;lambda &amp;amp;rest -4) &amp;amp;body))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It says, that &lt;code&gt;run-ga&lt;/code&gt; macro has a list-like first argument. Keyword &lt;code&gt;&amp;whole &amp;lambda&lt;/code&gt; tells that first item of this list would be indented as a regular lambda-list.&lt;/p&gt;
&lt;p&gt;Following &lt;code&gt;&amp;rest -4&lt;/code&gt; tells Emacs to deindent rest items of the first list.&lt;/p&gt;
&lt;p&gt;And finally, &lt;code&gt;&amp;body&lt;/code&gt; keyword says to handle the rest of the macro arguments like a function&apos;s body.&lt;/p&gt;
&lt;p&gt;There is also ability to define a custom function which will decide how to indent a form. But I didn&apos;t use this feature yet.&lt;/p&gt;
&lt;p&gt;You can read detail about the structure of indentation rules in &lt;a href=&quot;https://github.com/jwiegley/emacs-release/blob/adfd5933358fdf6715423dee8169eb3cd7d982db/lisp/emacs-lisp/cl-indent.el#L180-L248&quot;&gt;this Emacs docstring&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-heredoc</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0055-cl-heredoc.html</link>
            <description>&lt;p&gt;This module implements a syntax to read string literals in &lt;a href=&quot;https://en.wikipedia.org/wiki/Here_document&quot;&gt;heredoc&lt;/a&gt; style. Such way of reading is also supported in some other languages.&lt;/p&gt;
&lt;p&gt;Heredoc allows you to define a string literal where any symbols can be used:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (set-dispatch-macro-character
            #\# #\&amp;gt;
            #&amp;#039;cl-heredoc:read-heredoc)

POFTHEDAY&amp;gt; #&amp;gt;some stop sequence&amp;gt;And now I can
use any characters even different quotes:

- &amp;#039;
- &amp;quot;
some stop sequence

;; result is:

&amp;quot;And now I can
use any characters even different quotes:

- &amp;#039;
- \&amp;quot;
&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With &lt;code&gt;cl-heredoc&lt;/code&gt; you can write anything you want without escaping. This might be useful in some cases.&lt;/p&gt;
&lt;p&gt;Also, it exports a function &lt;code&gt;read-until-match&lt;/code&gt; which might be used to read from a string until a given subsequence.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>hu.dwim.def</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/04/0054-hu.dwim.def.html</link>
            <description>&lt;p&gt;Today I want to review this library because it is used in other &lt;code&gt;hu.dwim.*&lt;/code&gt; libraries. Understanding how does &lt;code&gt;hu.dwim.def&lt;/code&gt; works will help to read other libraries code.&lt;/p&gt;
&lt;p&gt;The main concept of the &lt;code&gt;hu.dwim.def&lt;/code&gt; is the &lt;code&gt;definer&lt;/code&gt;. Definer has a name and a function which is used to macro-expand the code.&lt;/p&gt;
&lt;p&gt;This is how usual definition can be used and what it expands to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (def function foo ()
             (format nil &amp;quot;Hello from ~A!&amp;quot;
                     hu.dwim.def:-this-function/name-))
-&amp;gt; (defun foo ()
     (symbol-macrolet ((-this-function/name- &amp;#039;foo))
       (format nil &amp;quot;Hello from ~A!&amp;quot;
               -this-function/name-)))

POFTHEDAY&amp;gt; (foo)
&amp;quot;Hello from FOO!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, this macro expands into a usual function definition, plus a &lt;code&gt;symbol-macrolet&lt;/code&gt;, useful to refer to a current function name.&lt;/p&gt;
&lt;p&gt;When definer is called, a number of options can be passed. Options allow tuning optimization settings and export rules.&lt;/p&gt;
&lt;p&gt;Option &quot;o&quot; adds declaration to maximize performance:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (def (function o) foo ()
             (format nil &amp;quot;Hello World!&amp;quot;))
-&amp;gt; (locally
       (declare (optimize (speed 3) (debug 0) (safety 2)))
     (defun foo ()
       (format nil &amp;quot;Hello World!&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Options &quot;d&quot; adds an opposite declaration to make debugging easier:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (def (function d) foo ()
             (format nil &amp;quot;Hello World!&amp;quot;))

-&amp;gt; (progn
     (declaim (notinline foo))
     (locally
         (declare (optimize (speed 0) (debug 3)))
       (defun foo ()
         (format nil &amp;quot;Hello World!&amp;quot;))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, these declaration depends on the value of the &lt;code&gt;hu.dwim.asdf:*load-as-production?*&lt;/code&gt; variable. When it is nil, then &quot;o&quot; option will lead to these two declarations:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;(declaim (notinline foo))&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;(declare (optimize (speed 0) (debug 1)))&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;and &quot;d&quot; option will generate:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;(declaim (notinline foo))&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;(declare (optimize (speed 0) (debug 3)))&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;This way, functions will be inlined only when compiled for production.&lt;/p&gt;
&lt;p&gt;There is a separate option &quot;i&quot; to add &lt;code&gt;(declaim (inline foo))&lt;/code&gt; declaration. But it works only when &lt;code&gt;hu.dwim.asdf:*load-as-production?*&lt;/code&gt; is &lt;code&gt;nil&lt;/code&gt; and debug is turned off.&lt;/p&gt;
&lt;p&gt;On SBCL debug level is also controlled by a level, declaimed in the REPL. To have a reproducable results you&apos;ll need to evaluate: &lt;code&gt;(declaim (optimize (debug 0)))&lt;/code&gt; otherwise a &lt;code&gt;notinline&lt;/code&gt; declaration will be added.&lt;/p&gt;
&lt;p&gt;Another cool option is &quot;e&quot;. It will export the function, class or other defined entity:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (def (function e) foo ()
             (format nil &amp;quot;Hello World!&amp;quot;))
-&amp;gt; (progn
     (eval-when (:compile-toplevel :load-toplevel :execute)
       (export &amp;#039;foo))
     (defun foo ()
       (format nil &amp;quot;Hello World!&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, a class&apos;s slots can be exported automatically:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (def (class ea) user ()
             ((name :reader get-name)
              (email :reader get-email)))
-&amp;gt; (progn
     (export &amp;#039;user)
     (export &amp;#039;(get-name get-email))
     (defclass user ()
       ((name :reader get-name)
        (email :reader get-email))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Isn&apos;t this amazing? But what is really cool, it that these options will also work with your own custom definers.&lt;/p&gt;
&lt;p&gt;Here is how to transform a macro generating a function into a definer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defmacro blah (name &amp;amp;body body)
             `(defun ,name ()
                (format nil &amp;quot;A function ~S was called&amp;quot;
                        &amp;#039;,name)
                ,@body))

POFTHEDAY&amp;gt; (blah &amp;#039;me)
-&amp;gt; (defun &amp;#039;me ()
     (format nil &amp;quot;A function ~S was called&amp;quot; me))

;; Now we&amp;#039;ll make from a usual macro a new definer:

POFTHEDAY&amp;gt; (def (definer :available-flags &amp;quot;eodi&amp;quot;) blah ()
             (hu.dwim.def::function-like-definer blah))

POFTHEDAY&amp;gt; (def (blah eoi) me)
-&amp;gt; (progn
     (declaim (inline me))
     (locally
         (declare (optimize (speed 3) (debug 0) (safety 2)))
       (eval-when (:compile-toplevel :load-toplevel :execute)
         (export &amp;#039;me))
       (defun me ()
         (format nil &amp;quot;A function ~S was called&amp;quot; &amp;#039;me))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you might write a definer with a body. These special variables will be available during the macro-expansion:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;hu.dwim.def:-definer-&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;hu.dwim.def:-whole-&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;hu.dwim.def:-options-&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;hu.dwim.def:-environment-&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;We can define an experimental definer to see what is accessable during macro-expansion:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (def (definer :available-flags &amp;quot;doe&amp;quot;) guts ()
             (format t &amp;quot;hu.dwim.def:-definer- = ~A~%&amp;quot;
                     -definer-)
             (format t &amp;quot;hu.dwim.def:-options- = ~A~%&amp;quot;
                     -options-)
             (format t &amp;quot;hu.dwim.def:-whole- = ~A~%&amp;quot;
                     -whole-)
             (format t &amp;quot;hu.dwim.def:-environment- = ~A~%&amp;quot;
                     -environment-)
             `(progn))

POFTHEDAY&amp;gt; (def (guts de :any-other &amp;#039;option))
hu.dwim.def:-definer- = #&amp;lt;definer GUTS&amp;gt;
hu.dwim.def:-options- = (EXPORT T DEBUG T ANY-OTHER &amp;#039;OPTION)
hu.dwim.def:-whole- = (DEF (GUTS DE ANY-OTHER &amp;#039;OPTION))
hu.dwim.def:-environment- = #&amp;lt;NULL-LEXENV&amp;gt;
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, any values can be passed into the definer besides builtin flag and you might implement whatever logic you want.&lt;/p&gt;
&lt;p&gt;Final great thing I want to tell you about definers is that there is a registry of them. This makes all definers are easily discoverable.&lt;/p&gt;
&lt;p&gt;Well, not so easy because you need to digg into some internals:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (loop for definer being the hash-values
                   of hu.dwim.def::*definers*
                 for name = (hu.dwim.def::name-of definer)
                 for doc = (when (slot-boundp definer
                                              &amp;#039;hu.dwim.def::documentation)
                             (hu.dwim.def::documentation-of definer))
                 unless doc
                   count 1 into undocumented
                 when doc
                 do (format t &amp;quot;~A -&amp;gt; ~S~2%&amp;quot;
                            name doc)
                 finally (when (&amp;gt; undocumented 0)
                           (format t &amp;quot;~2&amp;amp;Also, there are ~A undocumented definers.~%&amp;quot;
                                   undocumented)))

CLASS -&amp;gt; &amp;quot;Example that exports all the class name and all the readers, writers and slot names:
    (def (class eas) foo (bar baz)
     ((slot1 :reader readerr)
      (slot2 :writer writerr :accessor accessorr))
     (:metaclass fofofo))&amp;quot;

CONDITION -&amp;gt; &amp;quot;See the CLASS definer.&amp;quot;

CONSTANT -&amp;gt; &amp;quot;Use like: (def (constant e :test #&amp;#039;string=) alma \&amp;quot;korte\&amp;quot;)
             test defaults to equal.&amp;quot;

SPECIAL-VARIABLE -&amp;gt; &amp;quot;Uses defvar/defparameter based on whether a
                     value was provided or not, and accepts
                    :documentation definer parameter
                     for value-less defvars.&amp;quot;

PRINT-OBJECT -&amp;gt; &amp;quot;Define a PRINT-OBJECT method using PRINT-UNREADABLE-OBJECT.
  An example:
  (def print-object parenscript-dispatcher ; could be (parenscript-dispatcher :identity nil)
    (when (cachep self)
      (princ \&amp;quot;cached\&amp;quot;)
      (princ \&amp;quot; \&amp;quot;))
    (princ (parenscript-file self)))&amp;quot;

WITH-MACRO -&amp;gt; &amp;quot;(def with-macro with-foo (arg1 arg2)
     (let ((*zyz* 42)
           (local 43))
       (do something)
       (-body- local)))
   Example:
   (with-foo arg1 arg2
     (...))&amp;quot;

WITH-MACRO* -&amp;gt; &amp;quot;(def with-macro* with-foo (arg1 arg2 &amp;amp;key alma)
     (let ((*zyz* 42)
           (local 43))
       (do something)
       (-body- local)))
   Example:
   (with-foo (arg1 arg2 :alma alma)
     (...))&amp;quot;

GUTS -&amp;gt; &amp;quot;This definer shows debug information about environment
         where is expanded.&amp;quot;


Also, there are 33 undocumented definers.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To conclude, &lt;code&gt;hu.dwim.def&lt;/code&gt; is a great library now I&apos;ll use it in my projects!&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-locale</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/04/0053-cl-locale.html</link>
            <description>&lt;p&gt;This project will help you to internationalize your application. Seems, it does not use files in &lt;code&gt;gettext&lt;/code&gt; format, but you might define translations in a lispy way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-locale:define-dictionary hello
             (:en-US &amp;#039;((&amp;quot;Hello World!&amp;quot; . &amp;quot;Hello World!&amp;quot;)))
             (:ru-RU &amp;#039;((&amp;quot;Hello World!&amp;quot; . &amp;quot;&amp;#x41F;&amp;#x440;&amp;#x438;&amp;#x432;&amp;#x435;&amp;#x442; &amp;#x41C;&amp;#x438;&amp;#x440;!&amp;quot;))))

POFTHEDAY&amp;gt; (cl-locale:i18n &amp;quot;Hello World!&amp;quot;)
&amp;quot;Hello World!&amp;quot;

;; Now I&amp;#039;ll switch locale to Russian
POFTHEDAY&amp;gt; (setf cl-locale:*locale*
                 :ru-ru)
:RU-RU

POFTHEDAY&amp;gt; (cl-locale:i18n &amp;quot;Hello World!&amp;quot;)
&amp;quot;&amp;#x41F;&amp;#x440;&amp;#x438;&amp;#x432;&amp;#x435;&amp;#x442; &amp;#x41C;&amp;#x438;&amp;#x440;!&amp;quot;
POFTHEDAY&amp;gt; 

;; Also, a special syntax can be used:
POFTHEDAY&amp;gt; (cl-locale:enable-locale-syntax)

POFTHEDAY&amp;gt; #i&amp;quot;Hello World!&amp;quot;
&amp;quot;&amp;#x41F;&amp;#x440;&amp;#x438;&amp;#x432;&amp;#x435;&amp;#x442; &amp;#x41C;&amp;#x438;&amp;#x440;!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, translations can be stored in separate Lisp files.&lt;/p&gt;
&lt;p&gt;This library does not support an important feature - pluralization.&lt;/p&gt;
&lt;p&gt;Pluralization depends on language rules. For example in Russian it will be:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;0 яблок&lt;/li&gt;&lt;li&gt;1 яблоко&lt;/li&gt;&lt;li&gt;2 яблока&lt;/li&gt;&lt;li&gt;5 яблок&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;I hope, &lt;a href=&quot;https://twitter.com/nitro_idiot&quot;&gt;@nitro_idiot&lt;/a&gt; will be able to add pluralization, or somebody will implement this feature!&lt;/p&gt;
</description>
        </item>
        <item>
            <title>beast</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/04/0052-beast.html</link>
            <description>&lt;p&gt;Today&apos;s overview is about the Beast. This is a small library, written by &lt;a href=&quot;https://twitter.com/stevelosh&quot;&gt;@stevelosh&lt;/a&gt; for describing a game world.&lt;/p&gt;
&lt;p&gt;Game world is full of different entities. Each entity has it a type and characteristics or aspects.&lt;/p&gt;
&lt;p&gt;&quot;Beast&quot; is a simple wrapper over CLOS, which allows you to define aspects and to mix them when defining a new entity type.&lt;/p&gt;
&lt;p&gt;Here is a nice example from projects README:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(define-aspect throwable accuracy damage)
(define-aspect edible nutrition-value)

(define-entity dart (throwable))
(define-entity cheese (edible))
(define-entity pie (throwable edible))

(define-system rot-food ((e edible))
  (decf (edible/nutrition-value e))
  (when (zerop (edible/nutrition-value e))
    (destroy-entity e)))

(defparameter *steel-dart* 
  (create-entity &amp;#039;dart
    :throwable/accuracy 0.9
    :throwable/damage 10))

(defparameter *hunk-of-swiss*
  (create-entity &amp;#039;cheese
    :edible/nutrition-value 50))

(defparameter *banana-cream-pie*
  (create-entity &amp;#039;pie
    :throwable/accuracy 0.3
    :throwable/damage 5
    :edible/nutrition-value 30))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Macro &lt;code&gt;(beast:define-aspect throwable accuracy damage)&lt;/code&gt; is expanded into such class-definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(progn
 (defclass throwable nil
           ((throwable/accuracy :accessor throwable/accuracy :initarg
             :throwable/accuracy)
            (throwable/damage :accessor throwable/damage :initarg
             :throwable/damage)))
 (defun throwable? (beast::object) (typep beast::object &amp;#039;throwable))
 (beast::initialize-aspect-index &amp;#039;throwable)
 (find-class &amp;#039;throwable))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Macro &lt;code&gt;(beast:define-entity pie (throwable edible))&lt;/code&gt; also transformed into a class which inherits all aspects and also has a class-level slot with a list of aspects:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(progn
 (defclass pie (beast:entity throwable edible)
           ((beast::%beast/aspects :allocation :class :initform
             &amp;#039;(throwable edible))))
 (defun pie? (beast::object) (typep beast::object &amp;#039;pie))
 (find-class &amp;#039;pie))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Function &lt;code&gt;create-entity&lt;/code&gt; not only creates a CLOS instance but also adds it to special indexes of entities of this type and entities having these aspects.&lt;/p&gt;
&lt;p&gt;Macro &lt;code&gt;define-system&lt;/code&gt; defines two functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(progn
  (declaim
   (ftype (function ((and beast:entity edible)) (values null &amp;amp;optional))
          rot-food)
   (notinline rot-food))
 
  (defun rot-food (e)
    (decf (edible/nutrition-value e))
    (when (zerop (edible/nutrition-value e)) (beast:destroy-entity e))
    nil)
  
  (defun run-rot-food ()
    (let ((#:argument-indexes1011 (gethash &amp;#039;rot-food beast::*system-index*)))
      (loop :for #:entity1012 :being :the beast::hash-values :of (first
                                                                  #:argument-indexes1011)
            :do (locally
                    (declare (type (and beast:entity edible) #:entity1012))
                  (rot-food #:entity1012)))))
  (beast::initialize-system-index &amp;#039;rot-food #&amp;#039;rot-food &amp;#039;((e edible)))
  &amp;#039;rot-food)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, this macro defines a code which will be applied to all &quot;edible&quot; objects in the game.&lt;/p&gt;
&lt;p&gt;I think Beast is the great library for defining game objects!&lt;/p&gt;
&lt;p&gt;You can find more information about this library in its &lt;a href=&quot;https://docs.stevelosh.com/beast/usage/&quot;&gt;great documentation&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>should-test</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/04/0051-should-test.html</link>
            <description>&lt;p&gt;This is yet another testing framework written by &lt;a href=&quot;https://twitter.com/vseloved&quot;&gt;@vseloved&lt;/a&gt;. It is interesting because provides a protocol to define new kinds of assertions.&lt;/p&gt;
&lt;p&gt;Here is a simple example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun plus-100 (x)
             (+ x x))

POFTHEDAY&amp;gt; (st:deftest test-plus-100 ()
             (st:should be = 200 (plus-100 100))
             (st:should be = 150 (plus-100 50))
             (st:should signal &amp;#039;error (plus-100 &amp;quot;blah&amp;quot;)))

;; Now let&amp;#039;s run the tests in the current package:
POFTHEDAY&amp;gt; (st:test)

Test TEST-PLUS-100: 
(PLUS-100 50) FAIL
expect: 150
actual: 100
(PLUS-100 blah) FAIL
expect: (QUOTE ERROR)
actual: #&amp;lt;TYPE-ERROR expected-type: NUMBER datum: &amp;quot;blah&amp;quot;&amp;gt;
  FAILED

NIL
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 1 {1006D9D273}&amp;gt;
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 0 {1006D9D553}&amp;gt;

;; Second value is a hash with thrown exceptions:
POFTHEDAY&amp;gt; (alexandria:hash-table-alist #v116:1)
((TEST-PLUS-100 #&amp;lt;TYPE-ERROR expected-type: NUMBER datum: &amp;quot;blah&amp;quot;&amp;gt; (100)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s try to extend this library with a custom check which will assert that float value more or less than expected no more than specified delta:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; This method defines a new assertion:
POFTHEDAY&amp;gt; (defmethod st:should-check ((key (eql :be-within)) delta fn &amp;amp;rest expected)
             (assert (= (length expected)
                        1))
             (let* ((result (funcall fn))
                    (real-difference (abs (- result
                                              (first expected)))))
               (or (&amp;lt;= real-difference delta)
                   (values nil
                           (list :result result
                                 :delta real-difference)))))

;; This is the fake function we are going to test:
POFTHEDAY&amp;gt; (defun kind-of-random ()
             0.323)

POFTHEDAY&amp;gt; (st:deftest test-within ()
             (st:should be-within 0.01 0.35
                        (kind-of-random)))

POFTHEDAY&amp;gt; (st:test)
Test TEST-WITHIN: 
(KIND-OF-RANDOM) FAIL
expect: 0.35
actual: :RESULT 0.323 :DELTA 0.02699998
  FAILED

;; Now we will fix the &amp;quot;error&amp;quot;
POFTHEDAY&amp;gt; (defun kind-of-random ()
             0.345)

POFTHEDAY&amp;gt; (st:test)
Test TEST-WITHIN:   OK&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;On my taste, it was not convenient to define a test predicate this way, because I didn&apos;t have control of assertion syntax. It always should be like &quot;name test expected form&quot;.&lt;/p&gt;
&lt;p&gt;In my case I have a 0.01 delta in place of the test, which is not semantic at all and form completion in SLY does not help me to understand what does &quot;should&quot; macro expect if the first argument is &quot;be-within&quot;.&lt;/p&gt;
&lt;p&gt;But this is is relatively young test framework :)&lt;/p&gt;
</description>
        </item>
    </channel>
</rss>