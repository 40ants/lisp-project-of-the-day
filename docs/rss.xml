<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>defclass-std</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0091-defclass-std.html</link>
            <description>&lt;p&gt;This library provides a shortcut macro to define &lt;code&gt;CLOS&lt;/code&gt; classes. Today I needed to define a class which will store stock candles data. It will keep data in the columns.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;defclass-std&lt;/code&gt; we can define such class like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass-std:defclass/std candles ()
             ((timestamps
               lows highs
               opens closes
               volumes)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will be expand into the &lt;code&gt;defclass&lt;/code&gt; full of accessors, init forms, etc:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass candles nil
  ((timestamps :accessor timestamps
               :initarg :timestamps
               :initform nil)
   (lows :accessor lows
         :initarg :lows
         :initform nil)
   (highs :accessor highs
          :initarg :highs
          :initform nil)
   (opens :accessor opens
          :initarg :opens
          :initform nil)
   (closes :accessor closes
           :initarg :closes
           :initform nil)
   (volumes :accessor volumes
            :initarg :volumes
            :initform nil)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what I really want is a class with custom initforms and readers, prefixed by class name.&lt;/p&gt;
&lt;p&gt;Here is the class definition I had before discovered the &lt;code&gt;defclass-std&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass candles ()
  ((timestamps :reader candles-timestamps
               :initform (make-time-vector)
               :initarg :timestamps)
   (lows :reader candles-lows
         :initform (make-price-vector)
         :initarg :lows)
   (highs :reader candles-highs
          :initform (make-price-vector)
          :initarg :highs)
   (opens :reader candles-opens
          :initform (make-price-vector)
          :initarg :opens)
   (closes :reader candles-closes
           :initform (make-price-vector)
           :initarg :closes)
   (volumes :reader candles-volumes
            :initform (make-volume-vector)
            :initarg :volumes))
  (:documentation
   &amp;quot;This is stock candles candles.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how &lt;code&gt;defclass-std&lt;/code&gt; can make this definition shorter and &lt;a href=&quot;https://en.wikipedia.org/wiki/Don%27t_repeat_yourself&quot;&gt;DRY&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass-std:defclass/std candles ()
  ((timestamps
    :ri :with-prefix
    :std (make-time-vector))
   (volumes
    :ri :with-prefix
    :std (make-volume-vector))
   ;; Columns, having common options
   ;; can be grouped together!
   (lows highs opens closes
    :ri :with-prefix
    :std (make-price-vector)))
  (:documentation
   &amp;quot;This is stock candles storage.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It will write &lt;code&gt;:initarg&lt;/code&gt; and &lt;code&gt;:reader&lt;/code&gt; for each slot. Also, slot&apos;s &lt;code&gt;:initform&lt;/code&gt; will have the value, provided after the &lt;code&gt;:std&lt;/code&gt; keyword.&lt;/p&gt;
&lt;p&gt;The syntax can be made even shorter, but such format is not supported yet:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defclass-std:defclass/std candles ()
  ((timestamps
    :std (make-time-vector))
   (volumes
    :std (make-volume-vector))
   (lows highs opens closes
    :std (make-price-vector)))
  (:default-slot-opts :ri :with-prefix)
  (:documentation
   &amp;quot;This is stock candles storage.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This can make class definitions as concise as defstruct.&lt;/p&gt;
</description>
            <pubDate>Sat, 06 Jun 2020 20:58:34 +0300</pubDate>
        </item>
        <item>
            <title>defmain</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0090-defmain.html</link>
            <description>&lt;p&gt;Today I want to tell about my own library for command-line arguments parsing. &lt;code&gt;Defmain&lt;/code&gt; provides a macro for defining the main function.&lt;/p&gt;
&lt;p&gt;All you need is to declare required and optional arguments like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defmain:defmain main
               ((debug &amp;quot;Show traceback instead of short message.&amp;quot;
                       :flag t)
                (log   &amp;quot;Filename to write log to.&amp;quot;)
                (token &amp;quot;GitHub personal access token.&amp;quot;
                       :env-var &amp;quot;TOKEN&amp;quot;)
                &amp;amp;rest repositories)
             &amp;quot;Utility to analyze github forks.&amp;quot;
             
             (format t
                     &amp;quot;Repositories: 誉蕃%                      Debug: S%                      Log: S%                      Token: S%&amp;quot;
                     repositories
                     debug
                     log
                     token))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code expands to a lot of low-level code which uses &lt;a href=&quot;https://twitter.com/didierverna&quot;&gt;@didierverna&lt;/a&gt;&apos;s &lt;code&gt;net.didierverna.clon&lt;/code&gt; for actual arguments parsing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(progn
 (defun main (&amp;amp;rest defmain/defmain::argv)
   (declare (ignorable))
   (let ((defmain/defmain::synopsis
          (net.didierverna.clon:defsynopsis (:postfix &amp;quot;REPOSITORY...&amp;quot;
                                             :make-default nil)
            (defmain/defmain::text :contents &amp;quot;Utility to analyze github forks.&amp;quot;)
            (defmain/defmain::flag :long-name &amp;quot;help&amp;quot; :env-var nil :description
             &amp;quot;Show help on this program.&amp;quot; :short-name &amp;quot;h&amp;quot;)
            (defmain/defmain::flag :long-name &amp;quot;debug&amp;quot; :env-var nil :description
             &amp;quot;Show traceback instead of short message.&amp;quot; :short-name &amp;quot;d&amp;quot;)
            (defmain/defmain::stropt :long-name &amp;quot;log&amp;quot; :env-var nil :description
             &amp;quot;Filename to write log to.&amp;quot; :short-name &amp;quot;l&amp;quot;)
            (defmain/defmain::stropt :long-name &amp;quot;token&amp;quot; :env-var &amp;quot;TOKEN&amp;quot;
             :description &amp;quot;GitHub personal access token.&amp;quot; :short-name &amp;quot;t&amp;quot;)))
         (defmain/defmain::argv
          (or defmain/defmain::argv (uiop/image:command-line-arguments))))
     (change-class defmain/defmain::synopsis &amp;#039;defmain/defmain::cool-synopsis
                   :command &amp;#039;main)
     (net.didierverna.clon:make-context :cmdline
                                        (cons &amp;quot;main&amp;quot; defmain/defmain::argv)
                                        :synopsis defmain/defmain::synopsis))
   (let ((defmain/defmain::%rest-arguments (net.didierverna.clon:remainder)))
     (declare (ignorable defmain/defmain::%rest-arguments))
     (flet ((defmain/defmain::%pop-argument (defmain/defmain::name)
              &amp;quot;This local function is used to pop positional arguments from the command line.&amp;quot;
              (unless defmain/defmain::%rest-arguments
                (check-type defmain/defmain::name symbol)
                (error &amp;#039;defmain/defmain::argument-is-required-error :name
                       defmain/defmain::name))
              (pop defmain/defmain::%rest-arguments)))
       (let ((net.didierverna.clon:help
              (net.didierverna.clon:getopt :long-name &amp;quot;help&amp;quot;))
             (debug (net.didierverna.clon:getopt :long-name &amp;quot;debug&amp;quot;))
             (log (net.didierverna.clon:getopt :long-name &amp;quot;log&amp;quot;))
             (token (net.didierverna.clon:getopt :long-name &amp;quot;token&amp;quot;)))
         (when net.didierverna.clon:help
           (net.didierverna.clon:help)
           (uiop/image:quit 1))
         (handler-bind ((sb-sys:interactive-interrupt
                         (lambda (defmain/defmain::c)
                           (declare (ignorable defmain/defmain::c))
                           (uiop/image:quit 0)))
                        (defmain/defmain::argument-is-required-error
                         (lambda (defmain/defmain::c)
                           (format t &amp;quot;A%&amp;quot; defmain/defmain::c)
                           (uiop/image:quit 1)))
                        (error
                         (lambda (condition)
                           (uiop/image:print-condition-backtrace condition
                                                                 :stream
                                                                 *error-output*)
                           (uiop/image:quit 1))))
           (let ((repositories defmain/defmain::%rest-arguments))
             (flet ()
               (setf (logical-pathname-translations &amp;quot;TEMPORARY-FILES&amp;quot;)
                       `((&amp;quot;*.*.*&amp;quot;
                          ,(uiop/package:symbol-call :cl-fad
                                                     &amp;#039;defmain/defmain::get-default-temporary-directory))))
               (uiop/stream:setup-temporary-directory)
               (format t &amp;quot;Repositories: 誉蕃%                          Debug: S%                          Log: S%                          Token: S%&amp;quot;
                       repositories debug log token)
               nil)))))))
 (setf (get &amp;#039;main :arguments) &amp;#039;(debug log token)
       (documentation &amp;#039;main &amp;#039;function) &amp;quot;Utility to analyze github forks.&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let&apos;s try to call our main function to check how  it processes command-line arguments.&lt;/p&gt;
&lt;p&gt;Defmain calls &lt;code&gt;uiop:quit&lt;/code&gt; at the end of the function on after the printing help message. To suppress this behaviour, I&apos;ll redefine this function to just print to the screen:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun uiop:quit (&amp;amp;optional (code 0))
             (format t &amp;quot;Quit was called with code=A%&amp;quot;
                     code))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can pass it different combinations of arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (main)
Repositories: 
Debug: NIL
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: NIL
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: NIL
Token: NIL

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;--log&amp;quot; &amp;quot;app.log&amp;quot;&amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: &amp;quot;app.log&amp;quot;
Token: NIL

;; Now we&amp;#039;ll check how it will
;; process environment variable:
POFTHEDAY&amp;gt; (setf (uiop:getenv &amp;quot;TOKEN&amp;quot;)
                 &amp;quot;$ome $ecret 7oken&amp;quot;)

POFTHEDAY&amp;gt; (main &amp;quot;--debug&amp;quot; &amp;quot;--log&amp;quot; &amp;quot;app.log&amp;quot;&amp;quot;Foo&amp;quot; &amp;quot;Bar&amp;quot;)
Repositories: &amp;quot;Foo&amp;quot;, &amp;quot;Bar&amp;quot;
Debug: T
Log: &amp;quot;app.log&amp;quot;
Token: &amp;quot;$ome $ecret 7oken&amp;quot;
NIL
POFTHEDAY&amp;gt; (main &amp;quot;--help&amp;quot;)
Usage: main main [-hd] [OPTIONS] REPOSITORY...

Utility to analyze github forks.
  -h, --help                  Show help on this program.
  -d, --debug                 Show traceback instead of short message.
  -l, --log=STR               Filename to write log to.
  -t, --token=STR             GitHub personal access token.
                              Environment: TOKEN
Quit was called with code=1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Defmain&lt;/code&gt; is not in Quicklisp distribution, but you can install it from &lt;a href=&quot;https://ultralisp.org/&quot;&gt;Ultralisp.org&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you are looking to something simpler, you might take a look at &lt;code&gt;unix-opts&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/03/0006-unix-opts.html&quot;&gt;reviewed in the #0006 #poftheday&lt;/a&gt; post.&lt;/p&gt;
</description>
            <pubDate>Fri, 05 Jun 2020 22:24:53 +0300</pubDate>
        </item>
        <item>
            <title>lambda-fiddle</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0089-lambda-fiddle.html</link>
            <description>&lt;p&gt;This library serves a single purpose - to help macro writers to parse lambda lists. In this sense, it is similar to &lt;code&gt;parse-declarations&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0067-parse-declarations.html&quot;&gt;reviewed on 13 May&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The library has a number of functions to extract or remove exact parts of the lambda list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lambda-fiddle:remove-aux-part
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(FOO BAR &amp;amp;KEY BAZ)

POFTHEDAY&amp;gt; (lambda-fiddle:aux-lambda-vars
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(SOMETHING ALTOGETHER)

POFTHEDAY&amp;gt; (lambda-fiddle:extract-all-lambda-vars
            &amp;#039;(foo bar &amp;amp;key baz &amp;amp;aux (something else) altogether))
(FOO BAR BAZ SOMETHING ALTOGETHER)

POFTHEDAY&amp;gt; (lambda-fiddle:split-lambda-list
            &amp;#039;(&amp;amp;whole wide world &amp;amp;key roles))
((WORLD) WIDE NIL NIL NIL NIL (ROLES) NIL)

POFTHEDAY&amp;gt; (lambda-fiddle:with-destructured-lambda-list
               (:required req :optional opt)
               &amp;#039;(foo bar &amp;amp;optional baz)
             (list :required req
                   :optional opt))
(:REQUIRED (FOO BAR) :OPTIONAL (BAZ))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It also provides a higher-level macro to extract particular pieces all at once:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lambda-fiddle:with-destructured-lambda-list
               (:required req :optional opt)
               &amp;#039;(foo bar &amp;amp;optional baz)
             (list :required req
                   :optional opt))
(:REQUIRED (FOO BAR) :OPTIONAL (BAZ))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@Shinmera&lt;/a&gt;&apos;s &quot;legit&quot; contains &lt;a href=&quot;https://github.com/Shinmera/legit/blob/f822ac7aa8ed5aec7f2c63b146f790b0410f8502/toolkit.lisp#L31-L45&quot;&gt;a practical example&lt;/a&gt; of the &lt;code&gt;with-destructured-lambda-list&lt;/code&gt; usage.&lt;/p&gt;
&lt;p&gt;This code replaces optional arguments with keywords and adds optional predicates which can be used to check if a keyword argument was provided:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defmacro define-git-wrapper (name &amp;amp;rest argdefs)
  (lambda-fiddle:with-destructured-lambda-list (:required req :optional opt :key key) argdefs
    (let* ((purereq (purify-args req))
           (purekey (purify-args key))
           (pureopt (purify-args opt))
           (augkeys (mapcar (lambda (a)
                              `(,a NIL ,(p-symb a)))
                            (append pureopt purekey))))
      `(defun ,name (,@purereq &amp;amp;key ,@augkeys)
         (declare (ignorable ,@(mapcar #&amp;#039;third augkeys)))
         (run-git
          ,(subseq (string-downcase name) 4)
          ,@(loop for arg in req 
                  when (front-arg-p arg)
                    collect (parse-rargdef arg))
          ,@(loop for arg in opt
                  when (front-arg-p arg)
                    collect (parse-oargdef arg))
          ,@(mapcar #&amp;#039;parse-kargdef key)
          ,@(loop for arg in req
                  unless (front-arg-p arg)
                    collect (parse-rargdef arg))
          ,@(loop for arg in opt
                  unless (front-arg-p arg)
                    collect
                    (parse-oargdef arg)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. If you want to parse lambda lists, use this little helper instead of searching &amp;optional, &amp;rest, &amp;misc, etc by hand.&lt;/p&gt;
</description>
            <pubDate>Thu, 04 Jun 2020 23:55:08 +0300</pubDate>
        </item>
        <item>
            <title>group-by</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0088-group-by.html</link>
            <description>&lt;p&gt;This small utility library implements a really handy facility. It allows you to group items by one or many keys.&lt;/p&gt;
&lt;p&gt;Here is how it works. In the next example we&apos;ll group names by their first letter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (group-by:group-by
            &amp;#039;(&amp;quot;Alice&amp;quot;
              &amp;quot;Bob&amp;quot;
              &amp;quot;Ashley&amp;quot;
              &amp;quot;Katie&amp;quot;
              &amp;quot;Brittany&amp;quot;
              &amp;quot;Jessica&amp;quot;
              &amp;quot;Daniel&amp;quot;
              &amp;quot;Josh&amp;quot;)
            :key (lambda (name)
                   (elt name 0))
            :value #&amp;#039;identity)

((#\A &amp;quot;Alice&amp;quot;
      &amp;quot;Ashley&amp;quot;)
 (#\B &amp;quot;Bob&amp;quot;
      &amp;quot;Brittany&amp;quot;)
 (#\K &amp;quot;Katie&amp;quot;)
 (#\J &amp;quot;Jessica&amp;quot;
      &amp;quot;Josh&amp;quot;)
 (#\D &amp;quot;Daniel&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we are going to group by the first letter and next by the second, we need to use &lt;code&gt;group-by-repeated&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((first-letter (name)
                    (elt name 0))
                  (second-letter (name)
                    (elt name 1)))
             (group-by:group-by-repeated
              &amp;#039;(&amp;quot;Alice&amp;quot;
                &amp;quot;Bob&amp;quot;
                &amp;quot;Ashley&amp;quot;
                &amp;quot;Katie&amp;quot;
                &amp;quot;Brittany&amp;quot;
                &amp;quot;Jessica&amp;quot;
                &amp;quot;Daniel&amp;quot;
                &amp;quot;Josh&amp;quot;)
            :keys (list #&amp;#039;first-letter
                       #&amp;#039;second-letter)))

((#\D (#\a &amp;quot;Daniel&amp;quot;))
 (#\J (#\o &amp;quot;Josh&amp;quot;)
      (#\e &amp;quot;Jessica&amp;quot;))
 (#\K (#\a &amp;quot;Katie&amp;quot;))
 (#\B (#\r &amp;quot;Brittany&amp;quot;)
      (#\o &amp;quot;Bob&amp;quot;))
 (#\A (#\s &amp;quot;Ashley&amp;quot;)
      (#\l &amp;quot;Alice&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library also provides a way to accumulate grouped items into a special object. This could be useful when you don&apos;t have all items right away, but receiving them one by one from some source.&lt;/p&gt;
&lt;p&gt;Here is how it can be used in the simplest case. First, we&apos;ll request names from the user and will be collecting them into a special grouped list data structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((first-letter (name)
                    (elt name 0))
                  (second-letter (name)
                    (elt name 1))
                  (request-name ()
                    (format t &amp;quot;Enter a name: &amp;quot;)
                    (read)))
             (loop with accumulator = (group-by:make-grouped-list
                                       nil
                                       :keys (list #&amp;#039;first-letter
                                                   #&amp;#039;second-letter))
                   for name = (request-name)
                     then (request-name)
                   while name
                   do (group-by:add-item-to-grouping
                       name
                       accumulator)
                   finally (return accumulator)))
Enter a name: &amp;quot;Markus&amp;quot;
Enter a name: &amp;quot;Bob&amp;quot;
Enter a name: &amp;quot;Betty&amp;quot;
Enter a name: &amp;quot;Mery&amp;quot;
Enter a name: &amp;quot;Oleg&amp;quot;
Enter a name: &amp;quot;Marianna&amp;quot;
Enter a name: nil
#&amp;lt;GROUP-BY:GROUPED-LIST {1006D3EC43}&amp;gt;

POFTHEDAY&amp;gt; (defparameter *grouping* *)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;At any time we can access the data structure to work with already collected items. Let&apos;s write a recursive function to see what we&apos;ve collected so far:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun print-tree (grouping &amp;amp;optional (depth 0))
             (let ((prefix (make-string depth :initial-element #\Space))
                   (key (group-by:key-value grouping))
                   (items (group-by:items-in-group grouping))
                   (subgroups (group-by:child-groupings grouping)))
               (when key
                 (format t &amp;quot;AA&amp;amp;&amp;quot; prefix key)
                 (incf depth))

               (if subgroups
                   (loop for child in subgroups
                         do (print-tree child depth))
                   (loop for item in items
                         do (format t &amp;quot;A - A%&amp;quot;
                                    prefix
                                    item)))))

POFTHEDAY&amp;gt; (print-tree *grouping*)
O
 l
  - Oleg
B
 e
  - Betty
 o
  - Bob
M
 e
  - Mery
 a
  - Marianna
  - Markus&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library is powerful enough to have it in your toolbox. Go and group something now!&lt;/p&gt;
</description>
            <pubDate>Wed, 03 Jun 2020 20:54:39 +0300</pubDate>
        </item>
        <item>
            <title>cl-cron</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0087-cl-cron.html</link>
            <description>&lt;p&gt;This is a small system which allows you to organize a scheduled function execution in a Cron-like manner.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-cron:make-cron-job
            (lambda ()
              (format t &amp;quot;[A] Cron works!%&amp;quot;
                      (local-time:now))))
#:|cron743|

POFTHEDAY&amp;gt; (cl-cron:start-cron)
#&amp;lt;SB-THREAD:THREAD &amp;quot;Anonymous thread&amp;quot; RUNNING {1004D8CB93}&amp;gt;

[2020-06-02T22:29:00.328017+03:00] Cron works!
[2020-06-02T22:30:00.321083+03:00] Cron works!

POFTHEDAY&amp;gt; (cl-cron:stop-cron)
NIL

POFTHEDAY&amp;gt; (defun list-cron-jobs ()
             (loop for key being the hash-key
                     of cl-cron::*cron-jobs-hash*
                   collect key))

POFTHEDAY&amp;gt; (list-cron-jobs)
(#:|cron743|)

POFTHEDAY&amp;gt; (cl-cron:delete-cron-job (first *))
T

POFTHEDAY&amp;gt; (list-cron-jobs)
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Having unnamed cron jobs is not convenient because it is to remove them, you need to get its name using &lt;code&gt;list-cron-jobs&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;But you can provide a &lt;code&gt;hash-key&lt;/code&gt; argument to the &lt;code&gt;make-cron-job&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-cron:make-cron-job
            (lambda ()
              (format t &amp;quot;[A] Cron works!%&amp;quot;
                      (local-time:now)))
            :hash-key :print-every-minute)
:PRINT-EVERY-MINUTE

POFTHEDAY&amp;gt; (list-cron-jobs)
(:PRINT-EVERY-MINUTE)

POFTHEDAY&amp;gt; (cl-cron:delete-cron-job
            :print-every-minute)
T

POFTHEDAY&amp;gt; (list-cron-jobs)
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To make a task which runs not every minute but at the specified time, you can pass keyword arguments to the &lt;code&gt;make-cron-job&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;For example, this will add a callback to run at 10:00 of every Sunday:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-cron:make-cron-job
            (lambda ()
              (format t &amp;quot;Wake Up!%&amp;quot;))

            ;; Days of week are numbered from 0,
            ;; where 0 is Monday.
            ;; Run every Sunday:
            :day-of-week 6
            :hour 10
            :minute 0
            :hash-key :sunday-alarm)
:SUNDAY-ALARM&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I use &lt;code&gt;cl-cron&lt;/code&gt; in the Ultralisp.org, &lt;a href=&quot;https://github.com/ultralisp/ultralisp/blob/517738b087ca5a3eb14de728d855ca70739913c8/src/cron.lisp#L157-L184&quot;&gt;to schedule different tasks&lt;/a&gt;. And another useful trick I do is redefining &lt;code&gt;cl-cron:log-cron-message&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;By default it writes lines to the &lt;code&gt;./cron.log&lt;/code&gt;, but using this definition you can redirect all messages to the &lt;code&gt;log4cl&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; Here we are patching this function because
;; original tries to write into a file cl-cron.log
(defun cl-cron:log-cron-message (message &amp;amp;optional (type &amp;quot;error&amp;quot;))
  (if (string-equal type &amp;quot;error&amp;quot;)
      (log:error message)
      (log:info message)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Probably, I&apos;ll make a pull-request with these fixes soon. But seems the author of this library is not very active neither at BitBucket nor at the GitHub.&lt;/p&gt;
</description>
            <pubDate>Tue, 02 Jun 2020 23:04:49 +0300</pubDate>
        </item>
        <item>
            <title>pythonic-string-reader</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0086-pythonic-string-reader.html</link>
            <description>&lt;p&gt;This is a small package which adds a new syntax for writing multiline string as you do in Python.&lt;/p&gt;
&lt;p&gt;I already reviewed the &quot;heredoc&quot; library providing a similar functionality:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0055-cl-heredoc.html&quot;&gt;http://40ants.com/lisp-project-of-the-day/2020/05/0055-cl-heredoc.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Here is how &lt;code&gt;pythonic-string-reader&lt;/code&gt; can be used:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; Enable the syntax:
POFTHEDAY&amp;gt; (named-readtables:in-readtable
            pythonic-string-reader:pythonic-string-syntax)

;; Using it from the REPL:
POFTHEDAY&amp;gt; &amp;quot;&amp;quot;&amp;quot;
Hello &amp;quot;Lisp World!&amp;quot;
&amp;quot;&amp;quot;&amp;quot;
&amp;quot;
Hello \&amp;quot;Lisp World!\&amp;quot;
&amp;quot;

;; Using it for function&amp;#039;s docstring:
POFTHEDAY&amp;gt; (defun foo (x)
             &amp;quot;&amp;quot;&amp;quot; This is a function
                 which multiplies &amp;quot;x&amp;quot;
                 to itself.
             &amp;quot;&amp;quot;&amp;quot;
             (* x x))
FOO
POFTHEDAY&amp;gt; (documentation &amp;#039;FOO
                          &amp;#039;function)
&amp;quot; This is a function
                 which multiplies \&amp;quot;x\&amp;quot;
                 to itself.
             &amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Whereas &lt;code&gt;cl-heredoc&lt;/code&gt; package allowed you to choose a string which will denote the end of the string literal, &lt;code&gt;pythonic-string-reader&lt;/code&gt; supports only 3 or 4 double-quotes.&lt;/p&gt;
&lt;p&gt;4 double-quotes might be useful if you want to use 3 double quotes in the text:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun foo ()
             &amp;quot;&amp;quot;&amp;quot;&amp;quot;
             You also might enter text with 3 double quotes:

             &amp;quot;&amp;quot;&amp;quot;
             Just use 4 double quotes when starting such string
             literal.
             &amp;quot;&amp;quot;&amp;quot;
&amp;quot;&amp;quot;&amp;quot;&amp;quot;)

POFTHEDAY&amp;gt; (foo)
&amp;quot;
             You also might enter text with 3 double quotes:

             \&amp;quot;\&amp;quot;\&amp;quot;
             Just use 4 double quotes when starting such string
             literal.
             \&amp;quot;\&amp;quot;\&amp;quot;
&amp;quot;&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Mon, 01 Jun 2020 21:24:03 +0300</pubDate>
        </item>
        <item>
            <title>simplified-types</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0085-simplified-types.html</link>
            <description>&lt;p&gt;Yesterday I wrote a simple implementation of dataframe. A dataframe stores data columns as simple vectors of some type.&lt;/p&gt;
&lt;p&gt;For this implementation, I needed a type inference to set vector&apos;s type for each column. An inferred type should be generic enough to work for all items in the column.&lt;/p&gt;
&lt;p&gt;But what if we have positive and negative integers in our data? What type will return the standard &lt;code&gt;type-of&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;Here is the answer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (type-of 21)
(INTEGER 0 4611686018427387903)

POFTHEDAY&amp;gt; (type-of -21)
FIXNUM&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, if I&apos;ll make my vector&apos;s type &lt;code&gt;(INTEGER 0 4611686018427387903)&lt;/code&gt; it will raise an error on the second element:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (make-array
            2
            :element-type &amp;#039;(INTEGER
                            0
                            4611686018427387903)
            :initial-contents &amp;#039;(21 -21))
; Debugger entered on
; #&amp;lt;TYPE-ERROR expected-type:
; (UNSIGNED-BYTE 62) datum: -21&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That&apos;s why I started to search the way to make inferred type more generic and found &lt;code&gt;simplified-types&lt;/code&gt; library.&lt;/p&gt;
&lt;p&gt;Here is how it works:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (mapcar #&amp;#039;type-of
             &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;))

((INTEGER 0 4611686018427387903)
  FIXNUM
  SINGLE-FLOAT
  DOUBLE-FLOAT
  (SIMPLE-ARRAY CHARACTER (6)))
    
POFTHEDAY&amp;gt; (mapcar #&amp;#039;simplified-types:simplified-type-of
             &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;))

((INTEGER 21 21)
 (INTEGER -23 -23)
  SINGLE-FLOAT
  DOUBLE-FLOAT
  T)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, &lt;code&gt;INTEGER&lt;/code&gt; with bounds still is not what I need for my application. Happily, &lt;a href=&quot;https://github.com/marcoheisig&quot;&gt;Marco Heisig&lt;/a&gt; foresee this need and added a switcher which makes integer types more generic.&lt;/p&gt;
&lt;p&gt;With this option, the library produces exactly what I need:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((simplified-types::*precise-integer-types* nil))
             (mapcar #&amp;#039;simplified-types:simplified-type-of
               &amp;#039;(21 -23 1.23 4.56d0 &amp;quot;string&amp;quot;)))

((INTEGER * *)
 (INTEGER * *)
  SINGLE-FLOAT
  DOUBLE-FLOAT
  T)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you&apos;d like to work with types in Common Lisp, then you probably might be interested in the library I&apos;ve reviewed recently - &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/04/0033-trivialib.type-unify.html&quot;&gt;trivialib.type-unify&lt;/a&gt;. It allows us to do pattern-matching on type specifiers.&lt;/p&gt;
</description>
            <pubDate>Sun, 31 May 2020 22:22:49 +0300</pubDate>
        </item>
        <item>
            <title>cl-ascii-table</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0084-cl-ascii-table.html</link>
            <description>&lt;p&gt;Today I want to cheat and to review a library you&apos;ve already seen in action in the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0082-data-table.html&quot;&gt;data-table&apos;s review&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Recently I encounter a task where I needed to print tabulated data. In Python there is really cool library &lt;a href=&quot;https://pypi.org/project/tabulate/&quot;&gt;tabulate&lt;/a&gt; and first thing I did - created &lt;a href=&quot;https://www.reddit.com/r/Common_Lisp/comments/gs115z/looking_for_a_library_to_show_data_frames_and/&quot;&gt;the post on Reddit&lt;/a&gt; asking if there is something similar for Common Lisp exists.&lt;/p&gt;
&lt;p&gt;Comments didn&apos;t give a  variety of choices, but I found a &lt;code&gt;cl-ascii-table&lt;/code&gt; &lt;a href=&quot;http://quickdocs.org/cl-ascii-table/&quot;&gt;on Quickdocs&lt;/a&gt;. Remember, if you need to solve some problem - search o Quickdocs first! ;-)&lt;/p&gt;
&lt;p&gt;So, &lt;code&gt;cl-ascii-table&lt;/code&gt; is a little helper to draw nice ASCII tables. It is very easy to use. Just create a table, then add rows, and command it to render the table:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (loop with rows = &amp;#039;((&amp;quot;Bob&amp;quot; 31 &amp;quot;bob@gmail.com&amp;quot; 89.4)
                               (&amp;quot;Alice&amp;quot; 28 &amp;quot;alice@hot.com&amp;quot; 65.1)
                               (&amp;quot;Garry&amp;quot; 25 &amp;quot;garry@zoumz.in&amp;quot; 76.3))
                 with table = (ascii-table:make-table
                               &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Age&amp;quot; &amp;quot;Email&amp;quot; &amp;quot;Weight&amp;quot;)
                               ;; this is optional
                               :header &amp;quot;Sport Group&amp;quot;)
                 for row in  rows
                 do (ascii-table:add-row table row)
                 finally (ascii-table:display table))
.---------------------------------------.
|              Sport Group              |
+-------+-----+----------------+--------+
| Name  | Age | Email          | Weight |
+-------+-----+----------------+--------+
| Bob   |  31 | bob@gmail.com  |   89.4 |
| Alice |  28 | alice@hot.com  |   65.1 |
| Garry |  25 | garry@zoumz.in |   76.3 |
+-------+-----+----------------+--------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is not so featureful as Python&apos;s tabulate, but does it job.&lt;/p&gt;
&lt;p&gt;By the way, pay attention on the difference between system name and package name. It might be important if you use &lt;a href=&quot;https://common-lisp.net/project/asdf/asdf/The-package_002dinferred_002dsystem-extension.html&quot;&gt;package-inferred-system&lt;/a&gt; ASDF extension for your own system.&lt;/p&gt;
&lt;p&gt;In this case, you can put this line into your ASD file. This will let ASDF to know which system should be loaded when you are importing symbols from &lt;code&gt;ascii-table&lt;/code&gt; package:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(register-system-packages &amp;quot;cl-ascii-table&amp;quot; &amp;#039;(#:ascii-table))&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Sat, 30 May 2020 22:00:38 +0300</pubDate>
        </item>
        <item>
            <title>assoc-utils</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0083-assoc-utils.html</link>
            <description>&lt;p&gt;This is a small utility library by &lt;a href=&quot;https://twitter.com/nitro_idiot&quot;&gt;Eitaro Fukamachi&lt;/a&gt;. It serves a single purpose - make working with alists more convenient.&lt;/p&gt;
&lt;p&gt;The library has good documentation with lots of examples. Here is the excerpt from it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *person*
             &amp;#039;((&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;)
               (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;)))

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;name&amp;quot;)
&amp;quot;Eitaro&amp;quot;

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;address&amp;quot;)
NIL

POFTHEDAY&amp;gt; (assoc-utils:aget *person* &amp;quot;address&amp;quot;
                             ;; This is default
                             &amp;quot;Tokyo, Japan&amp;quot;)
&amp;quot;Tokyo, Japan&amp;quot;

;; The alist remains the same
POFTHEDAY&amp;gt; *person*
((&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;) (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;))

;; But aget is setf-able:
POFTHEDAY&amp;gt; (setf (assoc-utils:aget *person* &amp;quot;address&amp;quot;)
                 &amp;quot;Tokyo, Japan&amp;quot;)

POFTHEDAY&amp;gt; *person*
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;)
 (&amp;quot;email&amp;quot; . &amp;quot;e.arrows@gmail.com&amp;quot;))

POFTHEDAY&amp;gt; (assoc-utils:delete-from-alistf *person*
                                           &amp;quot;email&amp;quot;)
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also conversion functions which automatically converts keys from strings to keywords and vice versa:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; *person*
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;) 
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))

POFTHEDAY&amp;gt; (assoc-utils:alist-plist *person*)
(:ADDRESS &amp;quot;Tokyo, Japan&amp;quot;
 :NAME &amp;quot;Eitaro&amp;quot;)

POFTHEDAY&amp;gt; (assoc-utils:plist-alist *)
((&amp;quot;address&amp;quot; . &amp;quot;Tokyo, Japan&amp;quot;)
 (&amp;quot;name&amp;quot; . &amp;quot;Eitaro&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Read &lt;a href=&quot;http://quickdocs.org/assoc-utils/&quot;&gt;the documentation&lt;/a&gt; to learn more about other functions which allow to compare alists, check their type and to get keys and values.&lt;/p&gt;
</description>
            <pubDate>Fri, 29 May 2020 21:13:27 +0300</pubDate>
        </item>
        <item>
            <title>data-table</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0082-data-table.html</link>
            <description>&lt;p&gt;This library provides a few methods to work with data tables. Think about it as a limited version of &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html&quot;&gt;Pandas Dataframe&lt;/a&gt; for Common Lisp.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Data-table&lt;/code&gt; abilities are really modest. For example, it does not provide methods to investigate data in the table.&lt;/p&gt;
&lt;p&gt;To overcome this limitation, we&apos;ll use another library - &lt;code&gt;cl-ascii-table&lt;/code&gt; and define a &lt;code&gt;describe-object&lt;/code&gt; method for data tables:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (make-instance &amp;#039;data-table:data-table
                            :column-names &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Birthday&amp;quot; &amp;quot;Age&amp;quot;)
                            :rows &amp;#039;((&amp;quot;Bob&amp;quot; &amp;quot;1985-05-17&amp;quot; 35)
                                    (&amp;quot;Alice&amp;quot; &amp;quot;1989-02-23&amp;quot; 31)
                                    (&amp;quot;John&amp;quot; &amp;quot;2000-01-03&amp;quot; 20))))

;; This is what we&amp;#039;ll wee by default:
POFTHEDAY&amp;gt; (describe *dt*)
#&amp;lt;DATA-TABLE:DATA-TABLE {1003D50293}&amp;gt;
  [standard-object]

Slots with :INSTANCE allocation:
  COLUMN-NAMES                   = (&amp;quot;Name&amp;quot; &amp;quot;Birthday&amp;quot; &amp;quot;Age&amp;quot;)
  COLUMN-TYPES                   = (STRING STRING (INTEGER 0 4611686018427387903))
  ROWS                           = ((&amp;quot;Bob&amp;quot; &amp;quot;1985-05-17&amp;quot; 35) (&amp;quot;Alice&amp;quot; &amp;quot;1989-02-23&amp;quot; 31))

;; But with custom method we might make it more
;; more convenient:
POFTHEDAY&amp;gt; (defmethod describe-object ((obj data-table:data-table) stream)
             (loop with table = (ascii-table:make-table
                                 (data-table:column-names obj))
                   for row in (data-table:rows obj)
                   do (ascii-table:add-row table row)
                   finally (ascii-table:display table)))

POFTHEDAY&amp;gt; (describe *dt*)
+-------+------------+-----+
| Name  | Birthday   | Age |
+-------+------------+-----+
| Bob   | 1985-05-17 |  35 |
| Alice | 1989-02-23 |  31 |
| John  | 2000-01-03 |  20 |
+-------+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s see what capabilities for data slicing does it have.&lt;/p&gt;
&lt;p&gt;Here is how we can retrieve columns. Pay attention, column names are case insensitive. But if case mismatch, column names of the resulting table will be different. Maybe this is a bug:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (describe
            (data-table:select-columns *dt*
                                       &amp;#039;(&amp;quot;Name&amp;quot; &amp;quot;Age&amp;quot;)))
+-------+-----+
| Name  | Age |
+-------+-----+
| Bob   |  35 |
| Alice |  31 |
| John  |  20 |
+-------+-----+
; No values
POFTHEDAY&amp;gt; (describe
            (data-table:select-columns *dt*
                                       &amp;#039;(&amp;quot;name&amp;quot; &amp;quot;age&amp;quot;)))
+-------+-----+
| name  | age |
+-------+-----+
| Bob   |  35 |
| Alice |  31 |
| John  |  20 |
+-------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a way to select a subtable using indices.&lt;/p&gt;
&lt;p&gt;This is how we can select contiguous columns with &quot;Name&quot; and &quot;Age&quot; labels:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; We have to do call this method first.
;; It will fill a list of datatypes.
;; Without filled list of datatypes, make-sub-table will fail :(

POFTHEDAY&amp;gt; (data-table:coerce-data-table-of-strings-to-types *dt*)

POFTHEDAY&amp;gt; (describe
            (data-table:make-sub-table *dt*
                                       :lci 1 :uci 3))
+------------+-----+
| Birthday   | Age |
+------------+-----+
| 1985-05-17 |  35 |
| 1989-02-23 |  31 |
| 2000-01-03 |  20 |
+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we want to select only the last two rows, then we have to do some math:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; In pandas.DataFrame this will be just: dt.tail(2)
;;
POFTHEDAY&amp;gt; (let ((rows-count (data-table:number-of-rows *dt*)))
             (describe
              (data-table:make-sub-table *dt*
                                         :lri (- rows-count 2)
                                         :uri rows-count)))
+-------+------------+-----+
| Name  | Birthday   | Age |
+-------+------------+-----+
| Alice | 1989-02-23 |  31 |
| John  | 2000-01-03 |  20 |
+-------+------------+-----+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, we can combine column selection by name with make-sub-table. But this will create an intermediate table.&lt;/p&gt;
&lt;p&gt;There is also a method &lt;code&gt;overlay-region&lt;/code&gt; to combine two tables. Let&apos;s use it to add email for Genry and Mary:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (data-table:plists-to-data-table
              &amp;#039;((:id 1 :name &amp;quot;Bob&amp;quot;)
                (:id 2 :name &amp;quot;Genry&amp;quot;)
                (:id 3 :name &amp;quot;Mary&amp;quot;))))

POFTHEDAY&amp;gt; (describe *dt*)
+----+-------+
| ID | NAME  |
+----+-------+
|  1 | Bob   |
|  2 | Genry |
|  3 | Mary  |
+----+-------+

POFTHEDAY&amp;gt; (data-table:overlay-region
            (data-table:plists-to-data-table
             &amp;#039;((:email &amp;quot;genry@gmail.com&amp;quot;)
               (:email &amp;quot;mary@hormail.com&amp;quot;)))
            *dt*)
NIL

POFTHEDAY&amp;gt; (describe *dt*)
+------------------+-------+
| ID               | NAME  |
+------------------+-------+
| genry@gmail.com  | Bob   |
| mary@hormail.com | Genry |
|                3 | Mary  |
+------------------+-------+

POFTHEDAY&amp;gt; ;; Oh, this method modified the original table :(((&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To fix the issue, we need to recreate an original table and to specify indexes for applied overlay:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *dt*
             (data-table:plists-to-data-table
              &amp;#039;((:id 1 :name &amp;quot;Bob&amp;quot;)
                (:id 2 :name &amp;quot;Genry&amp;quot;)
                (:id 3 :name &amp;quot;Mary&amp;quot;))))

POFTHEDAY&amp;gt; (data-table:overlay-region
            (data-table:plists-to-data-table
             &amp;#039;((:email &amp;quot;genry@gmail.com&amp;quot;)
               (:email &amp;quot;mary@hormail.com&amp;quot;)))
            *dt*
            :col-idx 2
            :row-idx 1)

;; But new column has no name now :(
POFTHEDAY&amp;gt; (describe *dt*)
+----+-------+------------------+
| ID | NAME  | NIL              |
+----+-------+------------------+
|  1 | Bob   | NIL              |
|  2 | Genry | genry@gmail.com  |
|  3 | Mary  | mary@hormail.com |
+----+-------+------------------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It would be nice to have support for indices and joins &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/getting_started/10min.html#join&quot;&gt;like in Pandas&lt;/a&gt;. That is what I expect from the data manipulation library.&lt;/p&gt;
&lt;p&gt;We&apos;ve viewed almost all core functions of the &lt;code&gt;data-table&lt;/code&gt; library. There are also data coercion and comparison functions. But I think this library has lots of room for improvement.&lt;/p&gt;
&lt;p&gt;Maybe &lt;a href=&quot;https://twitter.com/guicho271828&quot;&gt;@guicho271828&lt;/a&gt; has plans to build a dataframe library as supplementary to his &lt;a href=&quot;https://github.com/numcl/numcl&quot;&gt;NumCL&lt;/a&gt;?&lt;/p&gt;
</description>
            <pubDate>Fri, 29 May 2020 00:31:49 +0300</pubDate>
        </item>
        <item>
            <title>cl-ppcre-unicode</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0081-cl-ppcre-unicode.html</link>
            <description>&lt;p&gt;This system adds Unicode support to the &lt;code&gt;cl-ppcre&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What does it mean? It means that after loading &lt;code&gt;cl-ppcre-unicode&lt;/code&gt; you&apos;ll be able to match against Unicode symbol properties.&lt;/p&gt;
&lt;p&gt;A property matcher has a special syntax in cl-ppcre&apos;s regexps: &lt;code&gt;\p{PropertyName}&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; This is how we can find out a position
;; of the first Cyrillic letter:

POFTHEDAY&amp;gt; (ppcre:scan &amp;quot;\\p{Cyrillic}&amp;quot;
                       &amp;quot;123&amp;#x42E;56&amp;quot;)
3

;; Here we are extracting a
;; sequence of Emoji from the text:
POFTHEDAY&amp;gt; (ppcre:regex-replace
            &amp;quot;.*?([\\p{Emoticons}|\\p{Supplemental Symbols and Pictographs}]+).*&amp;quot;
            &amp;quot;Hello, Lisper! &amp;#x1F917;&amp;#x1F603; How are you?&amp;quot;
            &amp;quot;\\1&amp;quot;)
&amp;quot;&amp;#x1F917;&amp;#x1F603;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We are using two different Unicode classes as properties because these two characters belong to different classes.&lt;/p&gt;
&lt;p&gt;You can use &lt;code&gt;cl-unicode&lt;/code&gt; to discover the character&apos;s unicode class:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-unicode:code-block #\&amp;#x1F603;)
&amp;quot;Emoticons&amp;quot;

POFTHEDAY&amp;gt; (cl-unicode:code-block #\&amp;#x1F917;)
&amp;quot;Supplemental Symbols and Pictographs&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The way, how &lt;code&gt;cl-ppcre-unicode&lt;/code&gt; works is very interesting. It turns out that &lt;code&gt;cl-ppcre&lt;/code&gt; has a special hook which allows you to define a property resolver.&lt;/p&gt;
&lt;p&gt;For example, if you want to have a special property for vowels, you might do something like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun my-property-resolver (property-name)
             (if (string-equal property-name
                               &amp;quot;vowel&amp;quot;)
                 (rutils:fn vovel-p (character)
                   (member character &amp;#039;(#\A #\E #\I #\O #\U)
                           :test #&amp;#039;char-equal))
                 (cl-ppcre-unicode:unicode-property-resolver
                  property-name)))

POFTHEDAY&amp;gt; (setf cl-ppcre:*property-resolver*
                 #&amp;#039;my-property-resolver)

;; And now we can use the &amp;quot;Vowel&amp;quot; property in any
;; regular expressions!
POFTHEDAY&amp;gt; (ppcre:regex-replace-all
            &amp;quot;\\p{Vowel}&amp;quot;
            &amp;quot;Hello, Lisper! How are you?&amp;quot;
            &amp;quot;&amp;quot;)
&amp;quot;Hll, Lspr! Hw r y?&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Isn&apos;t this cool!? &lt;/p&gt;
</description>
            <pubDate>Wed, 27 May 2020 20:38:40 +0300</pubDate>
        </item>
        <item>
            <title>jose</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0080-jose.html</link>
            <description>&lt;p&gt;JOSE is an implementation of &lt;a href=&quot;https://datatracker.ietf.org/wg/jose/documents/&quot;&gt;Javascript Object Signing and Encryption&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This &lt;a href=&quot;https://twitter.com/nitro_idiot&quot;&gt;@nitro_idiot&apos;s&lt;/a&gt; library implements a &lt;a href=&quot;https://tools.ietf.org/html/rfc7515&quot;&gt;JSON Web Signature&lt;/a&gt; and allows to encode, decode and inspect JWT tokens.&lt;/p&gt;
&lt;p&gt;JOSE can be useful to implement signed token exchange between microservices.&lt;/p&gt;
&lt;p&gt;I found a &lt;a href=&quot;https://medium.facilelogin.com/jwt-jws-and-jwe-for-not-so-dummies-b63310d201a3&quot;&gt;great article on what JWT, JWS and JWE are&lt;/a&gt;. Read it you want more about them. To demonstrate, how does token inspection work, I took a JWT token from the article and parsed it with Common Lisp JOSE:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (jose/jwt:inspect-token
            &amp;quot;eyJhbGciOiJSUzI1NiIsImtpZCI6Ijc4YjRjZjIzNjU2ZGMzOTUzNjRmMWI2YzAyOTA3NjkxZjJjZGZmZTEifQ.eyJpc3MiOiJhY2NvdW50cy5nb29nbGUuY29tIiwic3ViIjoiMTEwNTAyMjUxMTU4OTIwMTQ3NzMyIiwiYXpwIjoiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiZW1haWwiOiJwcmFiYXRoQHdzbzIuY29tIiwiYXRfaGFzaCI6InpmODZ2TnVsc0xCOGdGYXFSd2R6WWciLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXVkIjoiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiaGQiOiJ3c28yLmNvbSIsImlhdCI6MTQwMTkwODI3MSwiZXhwIjoxNDAxOTEyMTcxfQ.TVKv-pdyvk2gW8sGsCbsnkqsrS0T-H00xnY6ETkIfgIxfotvFn5IwKm3xyBMpy0FFe0Rb5Ht8AEJV6PdWyxz8rMgX2HROWqSo_RfEfUpBb4iOsq4W28KftW5H0IA44VmNZ6zU4YTqPSt4TPhyFC9fP2D_Hg7JQozpQRUfbWTJI&amp;quot;)

((&amp;quot;exp&amp;quot; . 1401912171) (&amp;quot;iat&amp;quot; . 1401908271) (&amp;quot;hd&amp;quot; . &amp;quot;wso2.com&amp;quot;)
 (&amp;quot;aud&amp;quot;
  . &amp;quot;825249835659-te8qgl701kgonnomnp4sqv7erhu1211s.apps.googleusercontent.com&amp;quot;)
 (&amp;quot;email_verified&amp;quot; . T) (&amp;quot;at_hash&amp;quot; . &amp;quot;zf86vNulsLB8gFaqRwdzYg&amp;quot;)
 (&amp;quot;email&amp;quot; . &amp;quot;prabath@wso2.com&amp;quot;)
 (&amp;quot;azp&amp;quot;
  . &amp;quot;825249835659-te8qgl701kgonnomnp4sqv7erhu1211s.apps.googleusercontent.com&amp;quot;)
 (&amp;quot;sub&amp;quot; . &amp;quot;110502251158920147732&amp;quot;) (&amp;quot;iss&amp;quot; . &amp;quot;accounts.google.com&amp;quot;))

((&amp;quot;alg&amp;quot; . &amp;quot;RS256&amp;quot;) (&amp;quot;kid&amp;quot; . &amp;quot;78b4cf23656dc395364f1b6c02907691f2cdffe1&amp;quot;))

#(77 82 175 250 151 114 190 77 160 91 203 6 176 38 236 158 74 172 173 45 19 248
  125 52 198 118 58 17 57 8 126 2 49 126 139 111 22 126 72 192 169 183 199 32
  76 167 45 5 21 237 17 111 145 237 240 1 9 87 163 221 91 44 115 242 179 32 95
  97 209 57 106 146 163 244 95 17 245 41 5 190 34 58 202 184 91 111 10 126 213
  185 31 66 0 227 133 102 53 158 179 83 134 19 168 244 173 225 51 225 200 80
  189 124 253 131 252 120 59 37 10 51 165 4 84 125 181 147 36)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Inspect returns payload, headers and the signature.&lt;/p&gt;
&lt;p&gt;There are also two methods &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt;. Here is how we can use them to issue and verify JWT token:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter
               *secret* (ironclad:ascii-string-to-byte-array
                         &amp;quot;I Love Common Lisp!&amp;quot;))

POFTHEDAY&amp;gt; (defparameter
               *token*
             (jose:encode :hs256 *secret*
                          &amp;#039;((&amp;quot;user&amp;quot;  . &amp;quot;Bob&amp;quot;)
                            (&amp;quot;email&amp;quot; . &amp;quot;bob@gmail.com&amp;quot;))))

;; Now this token can be sent to the authenticated
;; user so that user can pass it back during API calls:
POFTHEDAY&amp;gt; *token*
&amp;quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiQm9iIiwiZW1haWwiOiJib2JAZ21haWwuY29tIn0.NLgg5RxlKDNqw1cqFU0_HysIu-zO7JBYUQN2IZF6c6w&amp;quot;

;; And when we&amp;#039;ll receive such API call,
;; we can know who this user is.
POFTHEDAY&amp;gt; (jose:decode :hs256 *secret*
                        *token*)
((&amp;quot;user&amp;quot; . &amp;quot;Bob&amp;quot;) (&amp;quot;email&amp;quot; . &amp;quot;bob@gmail.com&amp;quot;))
((&amp;quot;alg&amp;quot; . &amp;quot;HS256&amp;quot;) (&amp;quot;typ&amp;quot; . &amp;quot;JWT&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A cool feature of JWT token is that it is signed and you can trust the payload&apos;s content. Let&apos;s pretend, that Bob is the &quot;evil hacker&quot; who wants to get access to another account.&lt;/p&gt;
&lt;p&gt;To do this, Bob will modify payload and use header and sign from the original token:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun replace-payload (token new-payload)
             (rutils:with (((original-header rutils:_ original-sign)
                            (str:split &amp;quot;.&amp;quot; token))
                           (json-payload
                            (jonathan:to-json new-payload :from :alist))
                           (new-encoded-payload
                            (jose/base64:base64url-encode json-payload)))
               (str:join &amp;quot;.&amp;quot;
                         (list original-header
                               new-encoded-payload
                               original-sign))))

POFTHEDAY&amp;gt; (defparameter *new-token*
             (replace-payload *token*
                              &amp;#039;((&amp;quot;user&amp;quot;  . &amp;quot;Alice&amp;quot;)
                                (&amp;quot;email&amp;quot; . &amp;quot;alice@wonderland.in&amp;quot;))))

;; Now we&amp;#039;ll try to decode token on the server-side
;; and receive error from JOSE:
POFTHEDAY&amp;gt; (jose:decode :hs256 *secret*
                        *new-token*)
; Debugger entered on #&amp;lt;JOSE/ERRORS:JWS-VERIFICATION-ERROR {1005C37033}&amp;gt;
[1] POFTHEDAY&amp;gt; 
; Evaluation aborted on #&amp;lt;JOSE/ERRORS:JWS-VERIFICATION-ERROR {1005C37033}&amp;gt;

;; But we still can inspect bad token because
;; it&amp;#039;s content is not encrypted:
POFTHEDAY&amp;gt; (jose:inspect-token *new-token*)

((&amp;quot;email&amp;quot; . &amp;quot;alice@wonderland.in&amp;quot;) (&amp;quot;user&amp;quot; . &amp;quot;Alice&amp;quot;))

((&amp;quot;alg&amp;quot; . &amp;quot;HS256&amp;quot;) (&amp;quot;typ&amp;quot; . &amp;quot;JWT&amp;quot;))

#(52 184 32 229 28 101 40 51 106 195 87 42 21 77 63 31 43 8 187 236 206 236 144
  88 81 3 118 33 145 122 115 172)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BTW, as you can see, tokens are not encoded, they are signed. Because of that, you should pass them only over encrypted channels.&lt;/p&gt;
</description>
            <pubDate>Tue, 26 May 2020 20:17:08 +0300</pubDate>
        </item>
        <item>
            <title>cl-collider</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0079-cl-collider.html</link>
            <description>&lt;p&gt;This library is an interface to a very interesting algorithmic audio synthesizer - &lt;a href=&quot;https://supercollider.github.io/&quot;&gt;SuperCollider&lt;/a&gt;. SuperCollider itself has a builtin programming language, but &lt;code&gt;cl-collider&lt;/code&gt; makes it possible to write music in lisp interactively.&lt;/p&gt;
&lt;p&gt;Here is how a simple program in sclang looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; C&apos;&gt;// 60Hz Gabber Rave 1995
Server.default.boot;

(
SynthDef(\gabberkick, {
    var snd, freq, high, lfo;
    freq = \freq.kr(440) * (Env.perc(0.001, 0.08, curve: -1).ar * 48 * \bend.kr(1)).midiratio;
    snd = Saw.ar(freq);
    snd = (snd * 100).tanh + ((snd.sign - snd) * -8.dbamp);
    high = HPF.ar(snd, 300);
    lfo = SinOsc.ar(8, [0, 0.5pi]).range(0, 0.01);
    high = high.dup(2) + (DelayC.ar(high, 0.01, lfo) * -2.dbamp);
    snd = LPF.ar(snd, 100).dup(2) + high;
    snd = RLPF.ar(snd, 7000, 2);
    snd = BPeakEQ.ar(snd, \ffreq.kr(3000) * XLine.kr(1, 0.8, 0.3), 0.5, 15);
    snd = snd * Env.asr(0.001, 1, 0.05).ar(2, \gate.kr(1));
    Out.ar(\out.kr(0), snd * \amp.kr(0.1));
}).add;

SynthDef(\hoover, {
    var snd, freq, bw, delay, decay;
    freq = \freq.kr(440);
    freq = freq * Env([-5, 6, 0], [0.1, 1.7], [\lin, -4]).kr.midiratio;
    bw = 1.035;
    snd = { DelayN.ar(Saw.ar(freq * ExpRand(bw, 1 / bw)) + Saw.ar(freq * 0.5 * ExpRand(bw, 1 / bw)), 0.01, Rand(0, 0.01)) }.dup(20);
    snd = (Splay.ar(snd) * 3).atan;
    snd = snd * Env.asr(0.01, 1.0, 1.0).kr(0, \gate.kr(1));
    snd = FreeVerb2.ar(snd[0], snd[1], 0.3, 0.9);
    snd = snd * Env.asr(0, 1.0, 4, 6).kr(2, \gate.kr(1));
    Out.ar(\out.kr(0), snd * \amp.kr(0.1));
}).add;
)

(
var durations;
durations = [1, 1, 1, 1, 3/4, 1/4, 1/2, 3/4, 1/4, 1/2];
Ppar([
    Pbind(*[
        instrument: \gabberkick,
        amp: -23.dbamp,
        freq: 60,
        legato: 0.8,
        ffreq: Pseq((0..(durations.size * 4 - 1)).normalize, inf).linexp(0, 1, 100, 4000),
        dur: Pseq(durations, inf),
        bend: Pfuncn({ |x| if(x &amp;lt; (1/2), 0.4, 1) }, inf) &amp;lt;&amp;gt; Pkey(\dur),
    ]),
    Pbind(*[
        instrument: \hoover,
        amp: -20.dbamp,
        midinote: 74,
        dur: durations.sum * 2,
        sustain: 7,
    ])
]).play(TempoClock(210 / 60));
)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I wasn&apos;t able to translate it into the Lisp form, because &lt;code&gt;cl-collider&lt;/code&gt; does not have documentation and diving into it will require too much time. However, there is a working code example from its README, which you can try in the REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:in-readtable :sc)
POFTHEDAY&amp;gt; (setf sc:*s* (sc:make-external-server
                         &amp;quot;localhost&amp;quot; :port 48800))
POFTHEDAY&amp;gt; (use-package :sc)

POFTHEDAY&amp;gt; (defsynth saw-synth ((note 60) (dur 4.0))
             (let* ((env (env-gen.kr (env [0 .2 0]
                                          [(* dur .2) (* dur .8)])
                                     :act :free))
                    (freq (midicps note))
                    (sig (lpf.ar (saw.ar freq env)
                                 (* freq 2))))
               (out.ar 0 [sig sig])))

POFTHEDAY&amp;gt; (defun make-melody (time n &amp;amp;optional (offset 0))
             (when (&amp;gt; n 0)
               (at time (synth &amp;#039;saw-synth
                               :note (+ offset (alexandria:random-elt
                                                &amp;#039;(62 65 69 72)))))
               (let ((next-time (+ time (alexandria:random-elt
                                         &amp;#039;(0 1 2 1.5)))))
                 (callback next-time #&amp;#039;make-melody
                           next-time (- n 1) offset))))

POFTHEDAY&amp;gt; (make-melody (quant 4) 16)
POFTHEDAY&amp;gt; (make-melody (+ 4 (quant 4)) 16 12)

;; This will stop the music
POFTHEDAY&amp;gt; (sc:stop)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is a demo, showing how does live coding works with &lt;code&gt;cl-collider&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=pZyuHjztARY&quot;&gt;https://www.youtube.com/watch?v=pZyuHjztARY&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To try &lt;code&gt;cl-collider&lt;/code&gt;, you&apos;ll need to install a SuperCollider. On OSX it is as simple as doing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; bash&apos;&gt;brew cask install supercollider&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Mon, 25 May 2020 20:34:07 +0300</pubDate>
        </item>
        <item>
            <title>trivial-ssh</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0078-trivial-ssh.html</link>
            <description>&lt;p&gt;This system is a simple wrapper around cl-libssh2 which is binding to the libssh2. Trivial SSH provides a few macros to safely establish a connection, open and close streams.&lt;/p&gt;
&lt;p&gt;In the next example we&apos;ll connect to the host and run two commands to get its hostname and OS description:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; Make this before Quickloading the system:
;; brew upgrade libssh2

POFTHEDAY&amp;gt; (flet ((read-lines (s)
                    (loop for line = (read-line s nil nil)
                          while line
                          collect line)))

             (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot; (ssh:agent &amp;quot;root&amp;quot;))
               (values
                (ssh:with-command (conn iostream &amp;quot;hostname -f&amp;quot;)
                                  (read-lines iostream))
                (ssh:with-command (conn iostream &amp;quot;lsb_release --id --release --codename&amp;quot;)
                                  (read-lines iostream)))))
(&amp;quot;my-lovely-host.inter.net&amp;quot;)
(&amp;quot;Distributor ID:	Ubuntu&amp;quot;
 &amp;quot;Release:	18.04&amp;quot;
 &amp;quot;Codename:	bionic&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, there is are commands to upload and download files using SCP protocol. Here is how we can copy the bootstrap file to the host and execute it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot; (ssh:agent &amp;quot;root&amp;quot;))
               (ssh:upload-file conn &amp;quot;install.sh&amp;quot; &amp;quot;/tmp/install.sh&amp;quot;)
               (ssh:with-command (conn stream &amp;quot;chmod +x /tmp/install.sh&amp;quot;))
                 (ssh:with-command (conn stream &amp;quot;/tmp/install.sh&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The cool part of &lt;code&gt;with-command&lt;/code&gt; macro is that you have a communication stream and can read output during the command execution. Here we are installing Emacs on the remote host and can observe the process:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0078/install-emacs.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here is the code from this sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((-&amp;gt; (from to)
                    (loop for line = (read-line from nil nil)
                       while line
                       do (write-string line to)
                          (terpri))))
             (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot;
                                        (ssh:agent &amp;quot;root&amp;quot;))
               (ssh:with-command
                   (conn stream &amp;quot;apt-get update &amp;amp;&amp;amp;
                                apt-get install -y emacs-nox&amp;quot;)
                   (-&amp;gt; stream *standard-output*))))&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Update&lt;/h2&gt;&lt;p&gt;Found that &lt;code&gt;cl-libssh2&lt;/code&gt; does not support agent forwarding. Because of that, I&apos;m not able to call &lt;code&gt;git pull&lt;/code&gt; on the remote machine.&lt;/p&gt;
&lt;p&gt;I tried to patch &lt;code&gt;cl-libssh2&lt;/code&gt; to support the latest &lt;code&gt;libssh2&lt;/code&gt; where agent forwarding was supported in August 2019, but this patch does not work yet.&lt;/p&gt;
&lt;p&gt;If somebody is interested to help me with that, he might try this pull-request:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alxchk/cl-libssh2/pull/7&quot;&gt;https://github.com/alxchk/cl-libssh2/pull/7&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Sun, 24 May 2020 20:54:00 +0300</pubDate>
        </item>
        <item>
            <title>named-readtables</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0077-named-readtables.html</link>
            <description>&lt;p&gt;This system is highly recommended if you are writing a code which modifies a &lt;code&gt;*readtable*&lt;/code&gt; because it allows to define and switch between readtables as you do with Lisp packages.&lt;/p&gt;
&lt;p&gt;If you are not familiar with what &lt;code&gt;*readtable*&lt;/code&gt; is, then read this article:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lisper.in/reader-macros&quot;&gt;https://lisper.in/reader-macros&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;but pay attention, that the article manipulates with &lt;code&gt;*readtable*&lt;/code&gt; instead of using &lt;code&gt;named-readtables&lt;/code&gt;. This is bad. Use &lt;code&gt;named-readtables&lt;/code&gt; instead.&lt;/p&gt;
&lt;p&gt;First, let&apos;s see how to use &lt;code&gt;named-readtables&lt;/code&gt; to switch between read-tables. As an example, we&apos;ll see how to use &lt;code&gt;cl-interpol&lt;/code&gt; and &lt;code&gt;rutils&lt;/code&gt; readtables.&lt;/p&gt;
&lt;p&gt;This is how you can lookup which tables are available:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ql:quickload &amp;#039;(:cl-interpol :rutils))

POFTHEDAY&amp;gt; (named-readtables:list-all-named-readtables)
(#&amp;lt;NAMED-READTABLE :COMMON-LISP {1000024B73}&amp;gt;
 #&amp;lt;NAMED-READTABLE :CURRENT {1000025663}&amp;gt;
 #&amp;lt;NAMED-READTABLE RUTILS.READTABLE:RUTILS-READTABLE {1004A960E3}&amp;gt;
 #&amp;lt;NAMED-READTABLE RUTILS.READTABLE:STANDARD-READTABLE {1004A96133}&amp;gt;
 #&amp;lt;NAMED-READTABLE :INTERPOL-SYNTAX {1001D19853}&amp;gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s see how does switching work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; First I&amp;#039;ll switch to the interpol&amp;#039;s syntax:
POFTHEDAY&amp;gt; (named-readtables:in-readtable :interpol-syntax)

POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #?&amp;quot;Hello ${username}!&amp;quot;)
&amp;quot;Hello Bob!&amp;quot;

;; Rutils readtable is not active, and we can&amp;#039;t
;; use it&amp;#039;s syntax for hashes:
POFTHEDAY&amp;gt; #h(:foo &amp;quot;bar&amp;quot;)
; Debugger entered on #&amp;lt;SB-INT:SIMPLE-READER-ERROR
; &amp;quot;no dispatch function defined for S&amp;quot; {10068D4C63}&amp;gt;

;; We have to activate  it first
POFTHEDAY&amp;gt; (named-readtables:in-readtable
            rutils:rutils-readtable)

POFTHEDAY&amp;gt; #h(:foo &amp;quot;bar&amp;quot;)
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 1 {10068B9013}&amp;gt;

;; But now we are unable to use iterpol&amp;#039;s syntax:
POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #?&amp;quot;Hello ${username}!&amp;quot;)
; Debugger entered on #&amp;lt;SB-INT:SIMPLE-READER-ERROR
; &amp;quot;no dispatch function defined for S&amp;quot; {1006AE93F3}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what if we want to use both readtables from &lt;code&gt;cl-interpol&lt;/code&gt; and from &lt;code&gt;rutils&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;It is possible if we merge them together and create a new readtable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:defreadtable
               :poftheday
             (:merge
              rutils:rutils-readtable
              :interpol-syntax))

POFTHEDAY&amp;gt; (named-readtables:in-readtable
            :poftheday)

POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #h(:greeting #?&amp;quot;Hello ${username}!&amp;quot;))
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 1 {1003054C23}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-ht *)
#{
  :GREETING &amp;quot;Hello Bob!&amp;quot;
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we&apos;ll define a literal syntax for lambda from &lt;code&gt;rutils&lt;/code&gt; as a separate named read-table:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; &apos;&gt;POFTHEDAY&amp;gt; (defmacro trivial-positional-lambda (body)
             `(lambda (&amp;amp;optional % %%)
                (declare (ignorable %) (ignorable %%))
                ,body))

POFTHEDAY&amp;gt; (defun |^-reader| (stream char)
             (declare (ignore char))
             (let ((sexp (read stream t nil t)))
               `(trivial-positional-lambda
                 ,(if (and (listp sexp) (listp (car sexp)))
                      (cons &amp;#039;progn sexp)
                      sexp))))

POFTHEDAY&amp;gt; (named-readtables:defreadtable
               :lambda
             (:merge :standard)
             (:macro-char #\^ #&amp;#039;|^-reader|))

;; Now we can switch to the new readtable
;; and use new syntax for lambdas:
POFTHEDAY&amp;gt; (named-readtables:in-readtable :lambda)

POFTHEDAY&amp;gt; ^(+ % %%)
#&amp;lt;FUNCTION (LAMBDA (&amp;amp;OPTIONAL % %%)) {2252593B}&amp;gt;

POFTHEDAY&amp;gt; (funcall *
                    2
                    3)
5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Named readtables has yet another useful feature - it integrates with SLIME. When you have a &lt;code&gt;(in-readtable)&lt;/code&gt; call after you package definition, SLIME will know what &lt;code&gt;readtable&lt;/code&gt; to use when you hit &lt;code&gt;Ctrl-C Ctrl-C&lt;/code&gt; on defuns.&lt;/p&gt;
&lt;p&gt;That is what &lt;code&gt;in-readtable&lt;/code&gt; expands to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:in-readtable :interpol-syntax)

;; It expands to:
(eval-when (:compile-toplevel
            :load-toplevel
            :execute)
  (setf *readtable*
        (named-readtables:ensure-readtable
         &amp;#039;:interpol-syntax))
  (when (find-package :swank)
    (named-readtables::%frob-swank-readtable-alist
     *package*
     *readtable*)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This &lt;code&gt;%frob-swank-readtable-alist&lt;/code&gt; modifies &lt;code&gt;swank:*readtable-alist*&lt;/code&gt; to make it know what readtable should be used for the package. But a comment to this code says it is a &lt;code&gt;KLUDGE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Interesting, how this will or should work in the LispWorks?&lt;/p&gt;
</description>
            <pubDate>Sat, 23 May 2020 21:18:23 +0300</pubDate>
        </item>
        <item>
            <title>cl-change-case</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0076-cl-change-case.html</link>
            <description>&lt;p&gt;This cool library is able to transform strings from one time of delimiters to others.&lt;/p&gt;
&lt;p&gt;Previously I&apos;ve used &lt;a href=&quot;http://quickdocs.org/kebab/&quot;&gt;kebab&lt;/a&gt;, but &lt;code&gt;cl-change-case&lt;/code&gt; is much more featureful:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-change-case:path-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo/bar/bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:path-case &amp;quot;foo-bar_bazz&amp;quot;)
&amp;quot;foo/bar/bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:path-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo/bar/bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:sentence-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;Foo bar bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:snake-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo_bar_bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:camel-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;fooBarBazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:no-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo bar bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:header-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;Foo-Bar-Bazz&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When this can be useful? In cases when you interop with other systems, but want to use &lt;code&gt;:this-style-of-symbols&lt;/code&gt; in Lisp. For example, you might generate identifiers for JavaScript or Python.&lt;/p&gt;
&lt;p&gt;Another case is when you want to output labels for UI. Here I have a function which will render an HTML table describing a &lt;code&gt;CLOS&lt;/code&gt; object:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ((created-at :initarg :created-at)
              (name :initarg :name)
              (num-posts :initarg :num-posts)))

POFTHEDAY&amp;gt; (defun render (object)
             (let* ((class-name (type-of object))
                    (class (find-class class-name))
                    (slots (closer-mop:class-slots class)))
               (cl-who:with-html-output-to-string (*standard-output* nil :indent t)
                 (:table
                  (loop for slot in slots
                        for slot-name = (closer-mop:slot-definition-name slot)
                        for label = (cl-change-case:sentence-case (symbol-name slot-name))
                        for value = (rutils:fmt &amp;quot;A&amp;quot;
                                                (slot-value object slot-name))
                        do (cl-who:htm
                            (:tr
                             (:th (cl-who:esc label))
                             (:td (cl-who:esc value)))))))))

POFTHEDAY&amp;gt; (render (make-instance &amp;#039;user
                                  :name &amp;quot;Bob&amp;quot;
                                  :created-at &amp;quot;2020-05-22&amp;quot;
                                  :num-posts 42))
&amp;quot;
&amp;lt;table&amp;gt;
&amp;lt;tr&amp;gt;
  &amp;lt;th&amp;gt;Created at&amp;lt;/th&amp;gt;
  &amp;lt;td&amp;gt;2020-05-22&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
  &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
  &amp;lt;td&amp;gt;Bob&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
  &amp;lt;th&amp;gt;Num posts&amp;lt;/th&amp;gt;
  &amp;lt;td&amp;gt;42&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Sat, 23 May 2020 21:18:23 +0300</pubDate>
        </item>
        <item>
            <title>cl-who</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0075-cl-who.html</link>
            <description>&lt;p&gt;Today we continue to investigate &lt;code&gt;poftheday&lt;/code&gt;&apos;s &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0063-asdf-viz.html&quot;&gt;dependencies&lt;/a&gt; and will look at the well known &lt;code&gt;cl-who&lt;/code&gt; library. &lt;code&gt;CL-Who&lt;/code&gt; is a library Edmund Weitz and provides a DSL for HTML generation.&lt;/p&gt;
&lt;p&gt;For those who are not familiar with &lt;code&gt;cl-who&lt;/code&gt;, here is a quick example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-who:with-html-output-to-string (s)
             (:body
              (:p &amp;quot;Hello world!&amp;quot;)))
&amp;quot;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you want to insert a variable, you have to use a local macro &lt;code&gt;esc&lt;/code&gt;. There is also another macro - &lt;code&gt;str&lt;/code&gt;, and it very easy to misuse it. That is one of the reasons why I don&apos;t like &lt;code&gt;cl-who&lt;/code&gt; and prefer &lt;code&gt;spinneret&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let&apos;s pretend we want to output a username in the comment list on our page. The correct way to do so will be:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ((name :initarg :name
                    :reader get-name)))

POFTHEDAY&amp;gt; (let ((user (make-instance
                        &amp;#039;user
                        :name &amp;quot;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;&amp;quot;))
                 (comment-text &amp;quot;Hello from Bob!&amp;quot;))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:div :class &amp;quot;comment&amp;quot;
                     (:div :class &amp;quot;username&amp;quot;
                           (cl-who:esc (get-name user)))
                     (:div :class &amp;quot;text&amp;quot;
                           (cl-who:esc comment-text)))))
&amp;quot;
&amp;lt;div class=&amp;#039;comment&amp;#039;&amp;gt;
  &amp;lt;div class=&amp;#039;username&amp;#039;&amp;gt;Bob &amp;amp;lt;script&amp;amp;gt;alert(&amp;amp;#039;You are hacked&amp;amp;#039;)&amp;amp;lt;/script&amp;amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;#039;text&amp;#039;&amp;gt;Hello from Bob!
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As I said, this was a correct way, but it is very easy to misuse &lt;code&gt;cl-who&lt;/code&gt; and make your beautiful site open for &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS attacks&lt;/a&gt;. You only have to use &lt;code&gt;str&lt;/code&gt; instead of &lt;code&gt;esc&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((user (make-instance
                        &amp;#039;user
                        :name &amp;quot;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;&amp;quot;))
                 (comment-text &amp;quot;Hello from Bob!&amp;quot;))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:div :class &amp;quot;comment&amp;quot;
                     (:div :class &amp;quot;username&amp;quot;
                           (cl-who:str (get-name user)))
                     (:div :class &amp;quot;text&amp;quot;
                           (cl-who:str comment-text)))))
&amp;quot;
&amp;lt;div class=&amp;#039;comment&amp;#039;&amp;gt;
  &amp;lt;div class=&amp;#039;username&amp;#039;&amp;gt;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;#039;text&amp;#039;&amp;gt;Hello from Bob!
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here &lt;code&gt;script&lt;/code&gt; tag that was not escaped. This way, any code an evil user will enter as his name will be executed in other users browsers.&lt;/p&gt;
&lt;p&gt;Another inconvenience of &lt;code&gt;cl-who&lt;/code&gt; is that you have to use &lt;code&gt;htm&lt;/code&gt; macro if want to mix &lt;code&gt;HTML&lt;/code&gt; pieces with lisp forms. For example, if you want to output a list of items, this will not work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; &apos;&gt;POFTHEDAY&amp;gt; (let ((list (list 1 2 3 4 5)))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:ul
                (loop for item in list
                      do (:li (cl-who:esc
                               (format nil &amp;quot;Item number A&amp;quot;
                                       item)))))))
; in: LET ((LIST (LIST 1 2 3 4 5)))
;     (:LI (CL-WHO:ESC (FORMAT NIL &amp;quot;Item number A&amp;quot; POFTHEDAY::ITEM)))
; 
; caught STYLE-WARNING:
;   undefined function: :LI
; 
; compilation unit finished
;   Undefined function:
;     :LI
;   caught 1 STYLE-WARNING condition&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You have to wrap &lt;code&gt;:li&lt;/code&gt; form with a &lt;code&gt;htm&lt;/code&gt; macro, like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((list (list 1 2 3 4 5)))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:ul
                (loop for item in list
                      do (cl-who:htm
                          (:li 
                           (cl-who:esc
                            (format nil &amp;quot;Item number A&amp;quot;
                                    item))))))))
&amp;quot;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Item number 1
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 2
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 3
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 4
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 5
&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The Common Lisp Project of the Day&apos;s blog uses &lt;code&gt;cl-who&lt;/code&gt; only because this is a dependency of the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/03/0018-cl-bootstrap.html&quot;&gt;cl-bootstrap&lt;/a&gt;. Personally, I prefer &lt;code&gt;spinneret&lt;/code&gt; and probably will rewrite #poftheday site to use it.&lt;/p&gt;
</description>
            <pubDate>Thu, 21 May 2020 21:21:13 +0300</pubDate>
        </item>
        <item>
            <title>lquery</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0074-lquery.html</link>
            <description>&lt;p&gt;Yesterday I&apos;ve &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0073-clss.html&quot;&gt;reviewed a library&lt;/a&gt; to apply CSS3 selectors to the HTML nodes, produced by &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;Plump&lt;/a&gt;. And this allowed making our Twitter crawler more concise.&lt;/p&gt;
&lt;p&gt;lQuery will take it to the next stage because it makes possible to describe a whole HTML processing pipeline in a very declarative way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:$ (initialize (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))
             &amp;quot;.tweet-text&amp;quot;
             (render-text)
             (map (alexandria:curry
                   #&amp;#039;str:shorten 40))
             (lt 5))
#(&amp;quot;Hi, I&amp;#039;m a #gamedev. My latest project...&amp;quot;
  &amp;quot;Aw thank you, here&amp;#039;s the whole story ...&amp;quot;
  &amp;quot;&amp;#x96E8;&amp;#x6797;pic.twitter.com/BFwcd0AWSE&amp;quot;
  &amp;quot;&amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q&amp;quot;
  &amp;quot;The logic of Splatoon.pic.twitter.com...&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Each &quot;call&quot; here is a special function which is applied either to a set of &lt;code&gt;HTML&lt;/code&gt; nodes or to a single node in a set.&lt;/p&gt;
&lt;p&gt;All &lt;code&gt;lquery&lt;/code&gt; functions are defined in the &lt;code&gt;lquery-funcs&lt;/code&gt; package and documented &lt;a href=&quot;https://shinmera.github.io/lquery/#PACKAGE%20LQUERY-FUNCS&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can add your own functions for data processing, using &lt;a href=&quot;https://shinmera.github.io/lquery/#MACRO-FUNCTION%20LQUERY%3ADEFINE-LQUERY-FUNCTION&quot;&gt;define-lquery-function&lt;/a&gt; and &lt;a href=&quot;https://shinmera.github.io/lquery/#MACRO-FUNCTION%20LQUERY%3ADEFINE-LQUERY-LIST-FUNCTION&quot;&gt;define-lquery-list-function&lt;/a&gt;. This can be useful if some operation is frequent. For example, let&apos;s write a function to make strings shorter!&lt;/p&gt;
&lt;p&gt;First, we need to define lQuery function. It will process one node at a time:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:define-lquery-function shorten (text max-length)
             (check-type text string)
             (check-type max-length (integer 0 65535))
             (str:shorten max-length text))

LQUERY-FUNCS::SHORTEN&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use it to make our web crawler even more beautiful!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:$ (initialize (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))
             &amp;quot;.tweet-text&amp;quot;
             (render-text)
             (shorten 40)
             (lt 5))
#(&amp;quot;Hi, I&amp;#039;m a #gamedev. My latest project...&amp;quot;
  &amp;quot;Aw thank you, here&amp;#039;s the whole story ...&amp;quot;
  &amp;quot;&amp;#x96E8;&amp;#x6797;pic.twitter.com/BFwcd0AWSE&amp;quot;
  &amp;quot;&amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q&amp;quot;
  &amp;quot;The logic of Splatoon.pic.twitter.com...&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are other &lt;code&gt;define-*&lt;/code&gt; macros in &lt;code&gt;lquery&lt;/code&gt; as well. Read its documentation to learn more about how to extend it. It would be nice if &lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@shinmera&lt;/a&gt; add more examples on how to extend &lt;code&gt;lquery&lt;/code&gt;!&lt;/p&gt;
</description>
            <pubDate>Wed, 20 May 2020 20:06:02 +0300</pubDate>
        </item>
        <item>
            <title>clss</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0073-clss.html</link>
            <description>&lt;p&gt;Today we continue to review web crawling tools from &lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@shinmera&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This review will be short because I&apos;ll reuse code from the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;previous post&lt;/a&gt; and improve it by replacing four lines with only one.&lt;/p&gt;
&lt;p&gt;A system CLSS allows you to use CSS3 selectors when working with HTML nodes produced by &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;Plump&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here is how we can improve our simple Twitter crawler:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *raw-html*
             (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))

POFTHEDAY&amp;gt; (defvar *html* (plump:parse *raw-html*))

           ;; Now I&amp;#039;ll replaced these lines
           ;; with one clss:select call:
           ;;
           ;; (remove-if-not (lambda (div)
           ;;                  (str:containsp &amp;quot;tweet-text&amp;quot;
           ;;                                 (plump:attribute div &amp;quot;class&amp;quot;)))
           ;;                (plump:get-elements-by-tag-name *html* &amp;quot;p&amp;quot;))
POFTHEDAY&amp;gt; (defparameter *posts*
             (clss:select &amp;quot;.tweet-text&amp;quot; *html*))

POFTHEDAY&amp;gt; (type-of *posts*)
(VECTOR T 40)

POFTHEDAY&amp;gt; (loop repeat 5
                 for post across *posts*
                 for full-text = (plump:render-text post)
                 for short-text = (str:shorten 40 full-text)
                 do (format t &amp;quot;- A2%&amp;quot; short-text))
- Hi, I&amp;#039;m a #gamedev. My latest project...

- &amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q

- The logic of Splatoon.pic.twitter.com...

- The AI is extremely rough still, but ...

- pic.twitter.com/Cpvqytce5G&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As a bonus, I want to show you that &lt;code&gt;CLSS&lt;/code&gt; supports even pseudoclasses:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (plump:parse &amp;quot;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;quot;)
#&amp;lt;PLUMP-DOM:ROOT {10031A93A3}&amp;gt;

POFTHEDAY&amp;gt; (clss:select &amp;quot;li:first-child&amp;quot;
                        *)
#(#&amp;lt;PLUMP-DOM:ELEMENT li {100322C883}&amp;gt;)

POFTHEDAY&amp;gt; (plump:serialize * nil)
&amp;quot;&amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sadly, the documentation says only that it supports almost all CSS3 selectors, but don&apos;t enumerate them. However, we can learn this from sources:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (rutils:hash-table-keys
            clss::*pseudo-selectors*)
(&amp;quot;ROOT&amp;quot; &amp;quot;NTH-CHILD&amp;quot; &amp;quot;NTH-LAST-CHILD&amp;quot; &amp;quot;NTH-OF-TYPE&amp;quot; &amp;quot;NTH-LAST-OF-TYPE&amp;quot;
 &amp;quot;FIRST-CHILD&amp;quot; &amp;quot;LAST-CHILD&amp;quot; &amp;quot;FIRST-OF-TYPE&amp;quot; &amp;quot;LAST-OF-TYPE&amp;quot; &amp;quot;ONLY-CHILD&amp;quot;
 &amp;quot;ONLY-OF-TYPE&amp;quot; &amp;quot;EMPTY&amp;quot; &amp;quot;LINK&amp;quot; &amp;quot;VISITED&amp;quot; &amp;quot;ACTIVE&amp;quot; &amp;quot;HOVER&amp;quot; &amp;quot;FOCUS&amp;quot; &amp;quot;TARGET&amp;quot;
 &amp;quot;LANG&amp;quot; &amp;quot;ENABLED&amp;quot; &amp;quot;DISABLED&amp;quot; &amp;quot;CHECKED&amp;quot; &amp;quot;FIRST-LINE&amp;quot; &amp;quot;FIRST-LETTER&amp;quot; &amp;quot;BEFORE&amp;quot;
 &amp;quot;AFTER&amp;quot; &amp;quot;WARNING&amp;quot; &amp;quot;NOT&amp;quot; &amp;quot;FIRST-ONLY&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is a &lt;code&gt;clss:define-pseudo-selector&lt;/code&gt; macro which allows defining a custom pseudo-selector.&lt;/p&gt;
&lt;p&gt;Yesterday we&apos;ll learn about a more sophisticated tool for web scraping - lQuery.&lt;/p&gt;
</description>
            <pubDate>Tue, 19 May 2020 23:11:00 +0300</pubDate>
        </item>
        <item>
            <title>plump</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html</link>
            <description>&lt;p&gt;Yesterday &lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@Shinmera&lt;/a&gt; mentioned Plump in the &lt;a href=&quot;https://twitter.com/XH004&quot;&gt;@XH004&lt;/a&gt;&apos;s &lt;a href=&quot;https://twitter.com/XH004/status/1261861964818440192&quot;&gt;thread&lt;/a&gt; about performance optimization of it&apos;s new HTML parser. And I decided to review it.&lt;/p&gt;
&lt;p&gt;Plump is able to parse, modify and serialize an HTML back.&lt;/p&gt;
&lt;p&gt;Let&apos;s write a crawler to grab @shinmera&apos;s posts from Twitter!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *raw-html*
              (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))

POFTHEDAY&amp;gt; (defvar *html* (plump:parse *raw-html*))

;; We need all divs with class &amp;quot;tweet-text&amp;quot;
POFTHEDAY&amp;gt; (defvar *posts*
             (remove-if-not (lambda (div)
                              (str:containsp &amp;quot;tweet-text&amp;quot;
                                             (plump:attribute div &amp;quot;class&amp;quot;)))
                            (plump:get-elements-by-tag-name *html* &amp;quot;p&amp;quot;)))

POFTHEDAY&amp;gt; (loop for post in (rutils:take 5 *posts*)
                 for full-text = (plump:render-text post)
                 for short-text = (str:shorten 40 full-text)
                 do (format t &amp;quot;- A2%&amp;quot; short-text))
- 1478 Lighting sketch #onesies https:/...

- Trust Level: Swiss A fridge with cool...

- The arch.pic.twitter.com/gMamJfZ1r4

- &amp;#x3089;&amp;#x304F;&amp;#x304C;&amp;#x304D;&amp;#x3070;&amp;#x304B;&amp;#x308A;&amp;#x30A2;&amp;#x30C3;&amp;#x30D7;&amp;#x3057;&amp;#x3066;&amp;#x3044;&amp;#x305F;&amp;#x3084;&amp;#x3064;&amp;#x3001;&amp;#x4ECA;&amp;#x5EA6;&amp;#x306F;&amp;#x52D5;&amp;#x304D;&amp;#x307E;&amp;#x3059;&amp;#x3002;&amp;#x9031;&amp;#x672B;&amp;#x306B;&amp;#x30D7;&amp;#x30ED;&amp;#x30AF;&amp;#x30EA;&amp;#x30A8;&amp;#x30A4;&amp;#x30C8;&amp;#x3067;&amp;#x63CF;...

- Shit&amp;#039;s broken. Will be back in a few ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library has more utils for HTML parsing. Read the documentation to learn more.&lt;/p&gt;
&lt;p&gt;If you are going to write crawlers  in Common lisp, I recommend you to use Plump together with another @shimera&apos;s library - &lt;a href=&quot;https://shinmera.github.io/CLSS/&quot;&gt;clss&lt;/a&gt; but we&apos;ll play with it tomorrow :)&lt;/p&gt;
</description>
            <pubDate>Mon, 18 May 2020 21:08:33 +0300</pubDate>
        </item>
    </channel>
</rss>