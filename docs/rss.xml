<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>cl-who</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0075-cl-who.html</link>
            <description>&lt;p&gt;Today we continue to investigate &lt;code&gt;poftheday&lt;/code&gt;&apos;s &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0063-asdf-viz.html&quot;&gt;dependencies&lt;/a&gt; and will look at the well known &lt;code&gt;cl-who&lt;/code&gt; library. &lt;code&gt;CL-Who&lt;/code&gt; is a library Edmund Weitz and provides a DSL for HTML generation.&lt;/p&gt;
&lt;p&gt;For those who are not familiar with &lt;code&gt;cl-who&lt;/code&gt;, here is a quick example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-who:with-html-output-to-string (s)
             (:body
              (:p &amp;quot;Hello world!&amp;quot;)))
&amp;quot;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you want to insert a variable, you have to use a local macro &lt;code&gt;esc&lt;/code&gt;. There is also another macro - &lt;code&gt;str&lt;/code&gt;, and it very easy to misuse it. That is one of the reasons why I don&apos;t like &lt;code&gt;cl-who&lt;/code&gt; and prefer &lt;code&gt;spinneret&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let&apos;s pretend we want to output a username in the comment list on our page. The correct way to do so will be:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ((name :initarg :name
                    :reader get-name)))

POFTHEDAY&amp;gt; (let ((user (make-instance
                        &amp;#039;user
                        :name &amp;quot;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;&amp;quot;))
                 (comment-text &amp;quot;Hello from Bob!&amp;quot;))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:div :class &amp;quot;comment&amp;quot;
                     (:div :class &amp;quot;username&amp;quot;
                           (cl-who:esc (get-name user)))
                     (:div :class &amp;quot;text&amp;quot;
                           (cl-who:esc comment-text)))))
&amp;quot;
&amp;lt;div class=&amp;#039;comment&amp;#039;&amp;gt;
  &amp;lt;div class=&amp;#039;username&amp;#039;&amp;gt;Bob &amp;amp;lt;script&amp;amp;gt;alert(&amp;amp;#039;You are hacked&amp;amp;#039;)&amp;amp;lt;/script&amp;amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;#039;text&amp;#039;&amp;gt;Hello from Bob!
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As I said, this was a correct way, but it is very easy to misuse &lt;code&gt;cl-who&lt;/code&gt; and make your beautiful site open for &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS attacks&lt;/a&gt;. You only have to use &lt;code&gt;str&lt;/code&gt; instead of &lt;code&gt;esc&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((user (make-instance
                        &amp;#039;user
                        :name &amp;quot;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;&amp;quot;))
                 (comment-text &amp;quot;Hello from Bob!&amp;quot;))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:div :class &amp;quot;comment&amp;quot;
                     (:div :class &amp;quot;username&amp;quot;
                           (cl-who:str (get-name user)))
                     (:div :class &amp;quot;text&amp;quot;
                           (cl-who:str comment-text)))))
&amp;quot;
&amp;lt;div class=&amp;#039;comment&amp;#039;&amp;gt;
  &amp;lt;div class=&amp;#039;username&amp;#039;&amp;gt;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;#039;text&amp;#039;&amp;gt;Hello from Bob!
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here &lt;code&gt;script&lt;/code&gt; tag that was not escaped. This way, any code an evil user will enter as his name will be executed in other users browsers.&lt;/p&gt;
&lt;p&gt;Another inconvenience of &lt;code&gt;cl-who&lt;/code&gt; is that you have to use &lt;code&gt;htm&lt;/code&gt; macro if want to mix &lt;code&gt;HTML&lt;/code&gt; pieces with lisp forms. For example, if you want to output a list of items, this will not work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; &apos;&gt;POFTHEDAY&amp;gt; (let ((list (list 1 2 3 4 5)))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:ul
                (loop for item in list
                      do (:li (cl-who:esc
                               (format nil &amp;quot;Item number ~A&amp;quot;
                                       item)))))))
; in: LET ((LIST (LIST 1 2 3 4 5)))
;     (:LI (CL-WHO:ESC (FORMAT NIL &amp;quot;Item number ~A&amp;quot; POFTHEDAY::ITEM)))
; 
; caught STYLE-WARNING:
;   undefined function: :LI
; 
; compilation unit finished
;   Undefined function:
;     :LI
;   caught 1 STYLE-WARNING condition&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You have to wrap &lt;code&gt;:li&lt;/code&gt; form with a &lt;code&gt;htm&lt;/code&gt; macro, like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((list (list 1 2 3 4 5)))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:ul
                (loop for item in list
                      do (cl-who:htm
                          (:li 
                           (cl-who:esc
                            (format nil &amp;quot;Item number ~A&amp;quot;
                                    item))))))))
&amp;quot;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Item number 1
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 2
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 3
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 4
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 5
&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The Common Lisp Project of the Day&apos;s blog uses &lt;code&gt;cl-who&lt;/code&gt; only because this is a dependency of the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/03/0018-cl-bootstrap.html&quot;&gt;cl-bootstrap&lt;/a&gt;. Personally, I prefer &lt;code&gt;spinneret&lt;/code&gt; and probably will rewrite #poftheday site to use it.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>lquery</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0074-lquery.html</link>
            <description>&lt;p&gt;Yesterday I&apos;ve &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0073-clss.html&quot;&gt;reviewed a library&lt;/a&gt; to apply CSS3 selectors to the HTML nodes, produced by &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;Plump&lt;/a&gt;. And this allowed making our Twitter crawler more concise.&lt;/p&gt;
&lt;p&gt;lQuery will take it to the next stage because it makes possible to describe a whole HTML processing pipeline in a very declarative way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:$ (initialize (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))
             &amp;quot;.tweet-text&amp;quot;
             (render-text)
             (map (alexandria:curry
                   #&amp;#039;str:shorten 40))
             (lt 5))
#(&amp;quot;Hi, I&amp;#039;m a #gamedev. My latest project...&amp;quot;
  &amp;quot;Aw thank you, here&amp;#039;s the whole story ...&amp;quot;
  &amp;quot;&amp;#x96E8;&amp;#x6797;pic.twitter.com/BFwcd0AWSE&amp;quot;
  &amp;quot;&amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q&amp;quot;
  &amp;quot;The logic of Splatoon.pic.twitter.com...&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Each &quot;call&quot; here is a special function which is applied either to a set of &lt;code&gt;HTML&lt;/code&gt; nodes or to a single node in a set.&lt;/p&gt;
&lt;p&gt;All &lt;code&gt;lquery&lt;/code&gt; functions are defined in the &lt;code&gt;lquery-funcs&lt;/code&gt; package and documented &lt;a href=&quot;https://shinmera.github.io/lquery/#PACKAGE%20LQUERY-FUNCS&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can add your own functions for data processing, using &lt;a href=&quot;https://shinmera.github.io/lquery/#MACRO-FUNCTION%20LQUERY%3ADEFINE-LQUERY-FUNCTION&quot;&gt;define-lquery-function&lt;/a&gt; and &lt;a href=&quot;https://shinmera.github.io/lquery/#MACRO-FUNCTION%20LQUERY%3ADEFINE-LQUERY-LIST-FUNCTION&quot;&gt;define-lquery-list-function&lt;/a&gt;. This can be useful if some operation is frequent. For example, let&apos;s write a function to make strings shorter!&lt;/p&gt;
&lt;p&gt;First, we need to define lQuery function. It will process one node at a time:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:define-lquery-function shorten (text max-length)
             (check-type text string)
             (check-type max-length (integer 0 65535))
             (str:shorten max-length text))

LQUERY-FUNCS::SHORTEN&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use it to make our web crawler even more beautiful!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:$ (initialize (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))
             &amp;quot;.tweet-text&amp;quot;
             (render-text)
             (shorten 40)
             (lt 5))
#(&amp;quot;Hi, I&amp;#039;m a #gamedev. My latest project...&amp;quot;
  &amp;quot;Aw thank you, here&amp;#039;s the whole story ...&amp;quot;
  &amp;quot;&amp;#x96E8;&amp;#x6797;pic.twitter.com/BFwcd0AWSE&amp;quot;
  &amp;quot;&amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q&amp;quot;
  &amp;quot;The logic of Splatoon.pic.twitter.com...&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are other &lt;code&gt;define-*&lt;/code&gt; macros in &lt;code&gt;lquery&lt;/code&gt; as well. Read its documentation to learn more about how to extend it. It would be nice if &lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@shinmera&lt;/a&gt; add more examples on how to extend &lt;code&gt;lquery&lt;/code&gt;!&lt;/p&gt;
</description>
        </item>
        <item>
            <title>clss</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0073-clss.html</link>
            <description>&lt;p&gt;Today we continue to review web crawling tools from &lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@shinmera&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This review will be short because I&apos;ll reuse code from the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;previous post&lt;/a&gt; and improve it by replacing four lines with only one.&lt;/p&gt;
&lt;p&gt;A system CLSS allows you to use CSS3 selectors when working with HTML nodes produced by &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;Plump&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here is how we can improve our simple Twitter crawler:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *raw-html*
             (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))

POFTHEDAY&amp;gt; (defvar *html* (plump:parse *raw-html*))

           ;; Now I&amp;#039;ll replaced these lines
           ;; with one clss:select call:
           ;;
           ;; (remove-if-not (lambda (div)
           ;;                  (str:containsp &amp;quot;tweet-text&amp;quot;
           ;;                                 (plump:attribute div &amp;quot;class&amp;quot;)))
           ;;                (plump:get-elements-by-tag-name *html* &amp;quot;p&amp;quot;))
POFTHEDAY&amp;gt; (defparameter *posts*
             (clss:select &amp;quot;.tweet-text&amp;quot; *html*))

POFTHEDAY&amp;gt; (type-of *posts*)
(VECTOR T 40)

POFTHEDAY&amp;gt; (loop repeat 5
                 for post across *posts*
                 for full-text = (plump:render-text post)
                 for short-text = (str:shorten 40 full-text)
                 do (format t &amp;quot;- ~A~2%&amp;quot; short-text))
- Hi, I&amp;#039;m a #gamedev. My latest project...

- &amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q

- The logic of Splatoon.pic.twitter.com...

- The AI is extremely rough still, but ...

- pic.twitter.com/Cpvqytce5G&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As a bonus, I want to show you that &lt;code&gt;CLSS&lt;/code&gt; supports even pseudoclasses:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (plump:parse &amp;quot;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;quot;)
#&amp;lt;PLUMP-DOM:ROOT {10031A93A3}&amp;gt;

POFTHEDAY&amp;gt; (clss:select &amp;quot;li:first-child&amp;quot;
                        *)
#(#&amp;lt;PLUMP-DOM:ELEMENT li {100322C883}&amp;gt;)

POFTHEDAY&amp;gt; (plump:serialize * nil)
&amp;quot;&amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sadly, the documentation says only that it supports almost all CSS3 selectors, but don&apos;t enumerate them. However, we can learn this from sources:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (rutils:hash-table-keys
            clss::*pseudo-selectors*)
(&amp;quot;ROOT&amp;quot; &amp;quot;NTH-CHILD&amp;quot; &amp;quot;NTH-LAST-CHILD&amp;quot; &amp;quot;NTH-OF-TYPE&amp;quot; &amp;quot;NTH-LAST-OF-TYPE&amp;quot;
 &amp;quot;FIRST-CHILD&amp;quot; &amp;quot;LAST-CHILD&amp;quot; &amp;quot;FIRST-OF-TYPE&amp;quot; &amp;quot;LAST-OF-TYPE&amp;quot; &amp;quot;ONLY-CHILD&amp;quot;
 &amp;quot;ONLY-OF-TYPE&amp;quot; &amp;quot;EMPTY&amp;quot; &amp;quot;LINK&amp;quot; &amp;quot;VISITED&amp;quot; &amp;quot;ACTIVE&amp;quot; &amp;quot;HOVER&amp;quot; &amp;quot;FOCUS&amp;quot; &amp;quot;TARGET&amp;quot;
 &amp;quot;LANG&amp;quot; &amp;quot;ENABLED&amp;quot; &amp;quot;DISABLED&amp;quot; &amp;quot;CHECKED&amp;quot; &amp;quot;FIRST-LINE&amp;quot; &amp;quot;FIRST-LETTER&amp;quot; &amp;quot;BEFORE&amp;quot;
 &amp;quot;AFTER&amp;quot; &amp;quot;WARNING&amp;quot; &amp;quot;NOT&amp;quot; &amp;quot;FIRST-ONLY&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is a &lt;code&gt;clss:define-pseudo-selector&lt;/code&gt; macro which allows defining a custom pseudo-selector.&lt;/p&gt;
&lt;p&gt;Yesterday we&apos;ll learn about a more sophisticated tool for web scraping - lQuery.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>plump</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html</link>
            <description>&lt;p&gt;Yesterday &lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@Shinmera&lt;/a&gt; mentioned Plump in the &lt;a href=&quot;https://twitter.com/XH004&quot;&gt;@XH004&lt;/a&gt;&apos;s &lt;a href=&quot;https://twitter.com/XH004/status/1261861964818440192&quot;&gt;thread&lt;/a&gt; about performance optimization of it&apos;s new HTML parser. And I decided to review it.&lt;/p&gt;
&lt;p&gt;Plump is able to parse, modify and serialize an HTML back.&lt;/p&gt;
&lt;p&gt;Let&apos;s write a crawler to grab @shinmera&apos;s posts from Twitter!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *raw-html*
              (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))

POFTHEDAY&amp;gt; (defvar *html* (plump:parse *raw-html*))

;; We need all divs with class &amp;quot;tweet-text&amp;quot;
POFTHEDAY&amp;gt; (defvar *posts*
             (remove-if-not (lambda (div)
                              (str:containsp &amp;quot;tweet-text&amp;quot;
                                             (plump:attribute div &amp;quot;class&amp;quot;)))
                            (plump:get-elements-by-tag-name *html* &amp;quot;p&amp;quot;)))

POFTHEDAY&amp;gt; (loop for post in (rutils:take 5 *posts*)
                 for full-text = (plump:render-text post)
                 for short-text = (str:shorten 40 full-text)
                 do (format t &amp;quot;- ~A~2%&amp;quot; short-text))
- 1478 Lighting sketch #onesies https:/...

- Trust Level: Swiss A fridge with cool...

- The arch.pic.twitter.com/gMamJfZ1r4

- &amp;#x3089;&amp;#x304F;&amp;#x304C;&amp;#x304D;&amp;#x3070;&amp;#x304B;&amp;#x308A;&amp;#x30A2;&amp;#x30C3;&amp;#x30D7;&amp;#x3057;&amp;#x3066;&amp;#x3044;&amp;#x305F;&amp;#x3084;&amp;#x3064;&amp;#x3001;&amp;#x4ECA;&amp;#x5EA6;&amp;#x306F;&amp;#x52D5;&amp;#x304D;&amp;#x307E;&amp;#x3059;&amp;#x3002;&amp;#x9031;&amp;#x672B;&amp;#x306B;&amp;#x30D7;&amp;#x30ED;&amp;#x30AF;&amp;#x30EA;&amp;#x30A8;&amp;#x30A4;&amp;#x30C8;&amp;#x3067;&amp;#x63CF;...

- Shit&amp;#039;s broken. Will be back in a few ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library has more utils for HTML parsing. Read the documentation to learn more.&lt;/p&gt;
&lt;p&gt;If you are going to write crawlers  in Common lisp, I recommend you to use Plump together with another @shimera&apos;s library - &lt;a href=&quot;https://shinmera.github.io/CLSS/&quot;&gt;clss&lt;/a&gt; but we&apos;ll play with it tomorrow :)&lt;/p&gt;
</description>
        </item>
        <item>
            <title>parenscript</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0071-parenscript.html</link>
            <description>&lt;p&gt;Parenscript is the CL&apos;s answer to the &lt;a href=&quot;https://clojurescript.org/&quot;&gt;ClojureScript&lt;/a&gt;. It makes possible to write client-side code in Lisp and compile it to the Javascript for running in the Browser.&lt;/p&gt;
&lt;p&gt;I used Parenscript in one application, based on Electron and Weblocks.&lt;/p&gt;
&lt;p&gt;Here is a &lt;a href=&quot;https://github.com/40ants/hacrm/blob/464e931fb7eac7f2b8b0d3f5465ba9c255ec1d2b/src/widgets/contacts-list.lisp#L148-L184&quot;&gt;piece of real code&lt;/a&gt; which uses Parenscript to define a client-side code. This code allows switching between different contacts using shortcuts. It uses &lt;code&gt;jQuery&lt;/code&gt; to access &lt;code&gt;DOM&lt;/code&gt; elements:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(weblocks-parenscript:make-dependency
 (let ((numbers-are-visible nil))
   
   ;; With this code we give user ability to press Alt+1, Alt+2,...
   ;; to select one of first 10 contacts in the list.
   (setf (@ document onkeydown)
         (lambda (e)
           (let ((code (@ e &amp;quot;keyCode&amp;quot;))
                 (numbers (j-query &amp;quot;.contact-list__contact-number&amp;quot;)))
             ((@ console log) &amp;quot;Key down with code:&amp;quot; code)
             
             (cond
               ((= code 18)
                ((@ numbers show))
                (setf numbers-are-visible t))
               ((and (&amp;gt;= 57 code 48))
                ;; If user presed 0, then we&amp;#039;l consider it a 10.
                (when (= code 48)
                  (setf code (+ code 10)))
                
                (let ((contact-number (- code 48)))
                  ((@ console log)
                   &amp;quot;Selecting contact&amp;quot; contact-number)
                  ;; jQuery(&amp;quot;#contact-0 a&amp;quot;).click()
                  ((@ (j-query (+ &amp;quot;#contact-&amp;quot; contact-number &amp;quot; a&amp;quot;))
                      click))))))))
   
   (setf (@ document onkeyup)
         (lambda (e)
           (let ((code (@ e &amp;quot;keyCode&amp;quot;))
                 (numbers (j-query &amp;quot;.contact-list__contact-number&amp;quot;)))
             ((@ console log) &amp;quot;Key up with code:&amp;quot; code)
             
             (cond
               ((= code 18)
                ((@ numbers hide))
                (setf numbers-are-visible nil)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are two ways of using Parenscript:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;You can manually compile a &lt;code&gt;s-exp&lt;/code&gt; into Javascript.&lt;/li&gt;&lt;li&gt;You can use it as an ASDF extension to compile some components   automatically. But this will require the use of additional system   &lt;a href=&quot;https://github.com/gonzojive/paren-files&quot;&gt;paren-files&lt;/a&gt;. We&apos;ll review it later.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Let&apos;s investigate the first way by defining a simple JS function which sums two numbers and shows the result in Web Inspector&apos;s console:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (import &amp;#039;(parenscript:ps
                     parenscript:@))

POFTHEDAY&amp;gt; (ps
             (+ 1 2))
&amp;quot;1 + 2;&amp;quot;

POFTHEDAY&amp;gt; (ps
             (defun foo (a b)
               (+ a b)))
&amp;quot;function foo(a, b) {
    return a + b;
};&amp;quot;

POFTHEDAY&amp;gt; (ps
             (defun foo (a b)
               ((@ console log)
                 (+ a b))))
&amp;quot;function foo(a, b) {
    __PS_MV_REG = [];
    return console.log(a + b);
};&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you might notice, instead of dot notation, Parenscript uses a &lt;code&gt;@&lt;/code&gt; macro.&lt;/p&gt;
&lt;p&gt;Parenscript supports a subset of &lt;code&gt;loop&lt;/code&gt; macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps
             (loop :with collection =  &amp;#039;(1 2 3)
                   :for i :in collection
                   :do ((@ console log)
                       i)))
&amp;quot;(function () {
    var collection = [1, 2, 3];
    var _js8 = collection.length;
    for (var _js7 = 0; _js7 &amp;lt; _js8; _js7 += 1) {
        var i = collection[_js7];
        console.log(i);
    };
})();&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And also it allows you to write custom macroses which will expand into the Javascript Code!&lt;/p&gt;
&lt;p&gt;There are few ways to define macroses for Parenscript here is one of them. We&apos;ll define a macro in Common Lisp code and then will call this macro from Parenscript:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps:defpsmacro awhen (test &amp;amp;body body)
             `(let ((it ,test))
                (when it
                  ,@body)))

POFTHEDAY&amp;gt; (ps
             (let ((some-var 100500))
               (awhen (= some-var 42)
                 ((@ console log)
                  &amp;quot;Some var is&amp;quot; it))))
&amp;quot;(function () {
    var someVar = 100500;
    var it = someVar === 42;
    __PS_MV_REG = [];
    return it ? console.log(&amp;#039;Some var is&amp;#039;, it) : null;
})();&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Rewriting macro for Parenscript is not a fan. Why you should do this if macro already exists for Common Lisp?&lt;/p&gt;
&lt;p&gt;You shouldn&apos;t!&lt;/p&gt;
&lt;p&gt;Import existing Lisp macro into the Parenscript!&lt;/p&gt;
&lt;p&gt;In the next example, I&apos;ll show you how to reuse anaphoric &lt;code&gt;if&lt;/code&gt; from &lt;code&gt;rutils&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; First, let&amp;#039;s eval our form in Common Lisp
POFTHEDAY&amp;gt; (rutils:aif (= 1 2)
              (list :status :ok
                    :result rutils:it)
              (list :status :fail
                    :result rutils:it))
(:STATUS :FAIL :RESULT NIL)

;; By default it will not work:
POFTHEDAY&amp;gt; (ps
             (rutils:aif (= 1 2)
                (list :status :ok
                      :result it)
                (list :status :fail
                      :result it)))
&amp;quot;aif(1 === 2,
     [&amp;#039;status&amp;#039;, &amp;#039;ok&amp;#039;, &amp;#039;result&amp;#039;, it],
     [&amp;#039;status&amp;#039;, &amp;#039;fail&amp;#039;, &amp;#039;result&amp;#039;, it]);&amp;quot;

;; But we can import the macro:

POFTHEDAY&amp;gt; (ps:import-macros-from-lisp
            &amp;#039;rutils:aif)

POFTHEDAY&amp;gt; (ps
             (rutils:aif (= 1 2)
                (list :status :ok
                      :result it)
                (list :status :fail
                      :result it)))
&amp;quot;(function () {
    var it = 1 === 2;
    return it ? [&amp;#039;status&amp;#039;, &amp;#039;ok&amp;#039;, &amp;#039;result&amp;#039;, it]
              : [&amp;#039;status&amp;#039;, &amp;#039;fail&amp;#039;, &amp;#039;result&amp;#039;, it];
})();&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also built-in support for HTML rendering. Parenscript supports &lt;a href=&quot;https://github.com/franzinc/aserve/blob/master/doc/htmlgen.md&quot;&gt;Allegro HTMLGen DSL&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps
             (defun render-link (user)
               (ps:ps-html
                ((:a :href (+ &amp;quot;https://foo.bar/&amp;quot;
                               (get-nickname user)))
                 (get-name user)))))
&amp;quot;function renderLink(user) {
    __PS_MV_REG = [];
    return [&amp;#039;&amp;lt;a href=\\\&amp;quot;&amp;#039;,
            &amp;#039;https://foo.bar/&amp;#039; + getNickname(user),
            &amp;#039;\\\&amp;quot;&amp;gt;&amp;#039;,
             getName(user),
            &amp;#039;&amp;lt;/a&amp;gt;&amp;#039;].join(&amp;#039;&amp;#039;);
};&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And &lt;a href=&quot;https://edicl.github.io/cl-who/&quot;&gt;CL-WHO&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps
             (defun render-link (user)
               (ps:who-ps-html
                (:a :href (+ &amp;quot;https://foo.bar/&amp;quot;
                              (get-nickname user))
                 (get-name user)))))
&amp;quot;function renderLink(user) {
    __PS_MV_REG = [];
    return [&amp;#039;&amp;lt;a href=\\\&amp;quot;&amp;#039;,
            &amp;#039;https://foo.bar/&amp;#039; + getNickname(user),
            &amp;#039;\\\&amp;quot;&amp;gt;&amp;#039;,
             getName(user),
            &amp;#039;&amp;lt;/a&amp;gt;&amp;#039;].join(&amp;#039;&amp;#039;);
};&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With Parenscript you can create client-side applications or code for running on Node.js. All of this, using Common Lisp power. Isn&apos;t it cool?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>split-sequence</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0070-split-sequence.html</link>
            <description>&lt;p&gt;This is the utility library with a single purpose – to split, dissect, cut, cleave and partition sequences.&lt;/p&gt;
&lt;p&gt;In the simplest form it is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (split-sequence:split-sequence
            #\Space
            &amp;quot;Bob loves Alice!&amp;quot;)
(&amp;quot;Bob&amp;quot; &amp;quot;loves&amp;quot; &amp;quot;Alice!&amp;quot;)
16&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is also is able to split only N times, split from the and to remove empty subsequences:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0))
(#(1 2 3 4) #(5 6 7) #(8 9) #())

POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0)
            :remove-empty-subseqs t)
(#(1 2 3 4) #(5 6 7) #(8 9))

POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0)
            :remove-empty-subseqs t
            :from-end t
            :count 1)
(#(8 9))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also &lt;code&gt;split-sequence-if&lt;/code&gt; and &lt;code&gt;split-sequence-if-not&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defstruct word text)
POFTHEDAY&amp;gt; (defstruct white-space)

POFTHEDAY&amp;gt; (defmethod print-object ((obj word) stream)
             (format stream &amp;quot;&amp;lt;WORD ~A&amp;gt;&amp;quot; (word-text obj)))

POFTHEDAY&amp;gt; (defmethod print-object ((obj white-space) stream)
             (format stream &amp;quot;&amp;lt;SPACE&amp;gt;&amp;quot;))

POFTHEDAY&amp;gt; (defparameter *tokens*
             (list (make-word :text &amp;quot;Bob&amp;quot;)
                   (make-white-space)
                   (make-word :text &amp;quot;loves&amp;quot;)
                   (make-white-space)
                   (make-word :text &amp;quot;Alice&amp;quot;)))
(&amp;lt;WORD Bob&amp;gt; &amp;lt;SPACE&amp;gt; &amp;lt;WORD loves&amp;gt; &amp;lt;SPACE&amp;gt; &amp;lt;WORD Alice&amp;gt;)

POFTHEDAY&amp;gt; (split-sequence:split-sequence-if
            (lambda (item)
              (typep item &amp;#039;white-space))
              *tokens*)
((&amp;lt;WORD Bob&amp;gt;) (&amp;lt;WORD loves&amp;gt;) (&amp;lt;WORD Alice&amp;gt;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By the way, a library &lt;code&gt;cl-utilities&lt;/code&gt;, reviewed &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0068-cl-utilities.html&quot;&gt;two days ago&lt;/a&gt;, and &lt;code&gt;rutils&lt;/code&gt;, reviewed at &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0065-rutils.html&quot;&gt;the start of the week&lt;/a&gt;, are also include these splitting functions, but code is different. Probably this is because &lt;code&gt;split-sequence&lt;/code&gt; evolved since it was copied into  &lt;code&gt;cl-utilities&lt;/code&gt; and &lt;code&gt;rutils&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This simple &lt;a href=&quot;https://ultralisp.org/search/?query=symbol%3Asplit-sequence-if&quot;&gt;search query&lt;/a&gt; on Ultralisp.org shows that this functionality is also available in some other Common Lisp libraries.&lt;/p&gt;
&lt;h2&gt;Update 1&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/fwoaroof/status/1261736998412271616&quot;&gt;@fwoaroof&lt;/a&gt; gave me a &lt;a href=&quot;https://github.com/fiddlerwoaroof/fwoar.lisputils/blob/master/string-utils/split.lisp&quot;&gt;link to the split function&lt;/a&gt;, optimized to work with very long (&gt; 1G) strings.&lt;/p&gt;
&lt;h2&gt;Update 2&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/stevelosh&quot;&gt;@stevelosh&lt;/a&gt; &lt;a href=&quot;https://twitter.com/stevelosh/status/1261749896656424967&quot;&gt;sent me a code&lt;/a&gt; which uses &lt;code&gt;split-sequence&lt;/code&gt; to make an iterator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun spliterator (delimiter sequence &amp;amp;key (test #&amp;#039;eql) (key #&amp;#039;identity))
  (let ((start 0)
        (length (length sequence)))
    (lambda ()
      (if (= start length)
          (values nil nil)
          (multiple-value-bind (next end)
              (split-sequence:split-sequence delimiter sequence
                                             :count 1 :start start
                                             :key key :test test)
            (setf start end)
            (values (first next) t))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Thank you, Steve!&lt;/p&gt;
</description>
        </item>
        <item>
            <title>osicat</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0069-osicat.html</link>
            <description>&lt;p&gt;This is a library, created by &lt;a href=&quot;https://twitter.com/nsiivola&quot;&gt;@nsiivola&lt;/a&gt;. It is well suited if you need to call &lt;a href=&quot;https://en.wikipedia.org/wiki/POSIX&quot;&gt;POSIX&lt;/a&gt; API. &lt;code&gt;Osicat&lt;/code&gt; has outdated documentation but it is has docstring and the code is well structured.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;osicat&lt;/code&gt;, you can work with files and make other system calls.&lt;/p&gt;
&lt;p&gt;Here is an example of how you can get information about files:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (osicat:file-kind &amp;quot;/tmp&amp;quot;)
:SYMBOLIC-LINK

POFTHEDAY&amp;gt; (osicat:read-link &amp;quot;/tmp&amp;quot;)
#P&amp;quot;private/tmp&amp;quot;

POFTHEDAY&amp;gt; (osicat:file-permissions &amp;quot;/tmp&amp;quot;)
(:USER-READ :USER-WRITE :USER-EXEC :GROUP-READ
 :GROUP-WRITE :GROUP-EXEC :OTHER-READ
 :OTHER-WRITE :OTHER-EXEC :STICKY)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I&apos;ve never used &lt;code&gt;osicat&lt;/code&gt; before. When preparing this review, I noticed it has functions to make such system calls like &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and I wondered if it will be faster to implement such a handy operation like reading lines from a file using these calls instead of streams.&lt;/p&gt;
&lt;p&gt;So, let&apos;s compare the performance of the native Common Lisp streams and raw POSIX calls when we want to read all lines of the large log file.&lt;/p&gt;
&lt;p&gt;I have a 26M log file &lt;code&gt;/var/log/install.log&lt;/code&gt; on my disk.&lt;/p&gt;
&lt;p&gt;As a baseline, we&apos;ll take the performance of the &lt;code&gt;uiop:read-file-lines&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (time
            (length
             (uiop:read-file-lines *filename*)))
Evaluation took:
  0.610 seconds of real time
  0.610132 seconds of total run time (0.549502 user, 0.060630 system)
  [ Run times consist of 0.119 seconds GC time, and 0.492 seconds non-GC time. ]
  100.00% CPU
  1,346,441,256 processor cycles
  300,767,776 bytes consed
  
76560 ;; This is the number of lines&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how we can open a file and read a piece into the buffer, using POSIX system calls:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *filename* &amp;quot;/var/log/install.log&amp;quot;)

POFTHEDAY&amp;gt; (defparameter *fd* (osicat-posix:open *filename*
                                                 osicat-posix::o-rdonly))

POFTHEDAY&amp;gt; (cffi:with-foreign-pointer-as-string ((buf buf-size) 1024)
             (osicat-posix:read *fd* buf buf-size))
&amp;quot;Feb 25 09:58:02 localhost opendirectoryd[231]: opendirectoryd (build 692.000) launched - installer mode
Feb 25 09:58:02 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Initialize trigger support
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] created endpoint for mach service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Registered RPC over XPC &amp;#039;reset_cache&amp;#039; for service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Registered RPC over XPC &amp;#039;reset_online&amp;#039; for service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Re&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But we want to read a string, separated by newlines. In this scenario, code will be more complex:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun read-lines (filename &amp;amp;key (separator #\Newline))
  (declare (optimize (speed 3) (debug 0) (safety 0))
  
  (let ((fd (osicat-posix:open filename
                               osicat-posix::o-rdonly))
        (current-string &amp;quot;&amp;quot;)
        (separator (char-code separator)))
    (uiop:while-collecting (collect-string)
      (unwind-protect
           (cffi:with-foreign-pointer (buf 1024 buf-size)
             (flet ((collect-lines (num-bytes)
                      (loop with begin of-type fixnum = 0
                            for offset of-type fixnum from 0 below num-bytes
                            for char = (cffi:mem-ref buf :unsigned-char offset)
                            
                            when (= char separator)
                              do (let ((part (cffi:foreign-string-to-lisp
                                              buf
                                              :offset begin
                                              :count (- offset begin))))
                                   (setf begin (1+ offset))
                                   
                                   (cond ((zerop (length current-string))
                                          (collect-string part))
                                         (t
                                          (collect-string
                                           (concatenate &amp;#039;string part))
                                          (setf current-string &amp;quot;&amp;quot;))))
                            finally (unless (= offset num-bytes)
                                      (setf current-string
                                            (concatenate &amp;#039;string
                                                         current-string
                                                         (cffi:foreign-string-to-lisp
                                                          buf
                                                          :offset begin
                                                          :count (- offset begin))))))))
               (loop for num-bytes of-type fixnum = (osicat-posix:read fd buf buf-size)
                     while (not (zerop num-bytes))
                     do (collect-lines num-bytes)
                     finally (when (not (zerop (length current-string)))
                               (collect-string current-string))))))
        (osicat-posix:close fd))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I tried to put proper type declarations, and performance is 2.3 times faster than &lt;code&gt;uiop:read-file-lines&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (time (length (read-lines *filename*)))
Evaluation took:
  0.233 seconds of real time
  0.232355 seconds of total run time (0.203830 user, 0.028525 system)
  [ Run times consist of 0.036 seconds GC time, and 0.197 seconds non-GC time. ]
  99.57% CPU
  514,348,582 processor cycles
  87,868,848 bytes consed
  
76560&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the sad part of this story. If we compare performance with such interpreted language as Python, then Python will be 4.5 times faster than my optimized function :(&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; python&apos;&gt;In [1]: def read_lines(filename):
   ...:     l = []
   ...:     with open(filename) as f:
   ...:         for line in f:
   ...:             l.append(line)
   ...:     return l

In [2]: def count_lines(filename):
   ...:     return len(read_lines(filename))

In [3]: %timeit count_lines(&amp;quot;/var/log/install.log&amp;quot;)
55.5 ms &amp;#xB1; 3.94 ms per loop (mean &amp;#xB1; std. dev. of 7 runs, 10 loops each)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CFFI uses &lt;a href=&quot;https://github.com/cl-babel/babel&quot;&gt;Babel&lt;/a&gt; to convert bytes to string but makes few unnecessary calls.&lt;/p&gt;
&lt;p&gt;I tried to extract UTF-8 decoder from the &lt;a href=&quot;https://github.com/cl-babel/babel&quot;&gt;Babel&lt;/a&gt; into a single function, but it&apos;s internals too complex, to finish this task in one evening.&lt;/p&gt;
&lt;p&gt;If somebody knows fast Common Lisp implementation of the UTF-8 decoder, let me know and I&apos;ll update my article with new code. Probably &lt;code&gt;trivial-utf-8:utf-8-bytes-to-string&lt;/code&gt; will do the job if I&apos;ll modify it to read bytes from the alien pointer?&lt;/p&gt;
&lt;h2&gt;Update 1&lt;/h2&gt;&lt;p&gt;I&apos;ve runned the code under a SBCL&apos;s statistical profiler and build this flamegraph:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0069/read-lines-flamegraph.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;It shows that:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;50% of time wasted in my function read-line&lt;/li&gt;&lt;li&gt;10% is utf-8  decoding&lt;/li&gt;&lt;li&gt;40% – in a &quot;read&quot; syscall.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;This is strange, because when I remove all code which converts utf-8 and just reads whole file piece by piece it takes 25-30ms only.&lt;/p&gt;
&lt;p&gt;This can be improved if I&apos;ll use 10kb buffer instead of 1kb. In this case reading will take 7ms.&lt;/p&gt;
&lt;p&gt;Also, I found that the most consing occur in the &lt;code&gt;cffi:foreign-string-to-lisp&lt;/code&gt; call.&lt;/p&gt;
&lt;h2&gt;Update 2&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/luismbo&quot;&gt;@luismbo&lt;/a&gt; &lt;a href=&quot;https://twitter.com/luismbo/status/1261738185203298306&quot;&gt;found&lt;/a&gt; that CPython uses a &lt;a href=&quot;https://github.com/python/cpython/blob/a1d12bb1197d9335fcb62aad7fb0df56098197ac/Objects/unicodeobject.c#L4549&quot;&gt;shortcut trick&lt;/a&gt; to not decode string if it consists of ASCII characters. That is why it can be more performant than my Common Lisp &lt;code&gt;read-lines&lt;/code&gt; function.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-utilities</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0068-cl-utilities.html</link>
            <description>&lt;p&gt;This is a yet another utilities library. It is used by only a single &lt;code&gt;poftheday&lt;/code&gt;&apos;s dependency - &lt;code&gt;xml-emitter&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0064-xml-emitter.html&quot;&gt;reviewed&lt;/a&gt; on 10 May.&lt;/p&gt;
&lt;p&gt;Amount of tools in this toolbox is not very large and mostly covered by more popular libs.&lt;/p&gt;
&lt;p&gt;For example, it has a macro for item collection. For example, this macro can be useful to collect hash key value pairs into an alist. But this facility is also available from UIOP:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (cl-utilities:collecting
               (maphash
                (lambda (key value)
                  (cl-utilities:collect
                      (cons key value)))
                the-hash)))
((:FOO . &amp;quot;bar&amp;quot;) (:BLAH . &amp;quot;minor&amp;quot;))

;; Here is the similar code using UIOP
POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (uiop:while-collecting (collect)
               (maphash
                (lambda (key value)
                  (collect (cons key value)))
                the-hash)))
((:FOO . &amp;quot;bar&amp;quot;) (:BLAH . &amp;quot;minor&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But UIOP is more powerful allows you to collect many types of items simultaneously. For example, we might want to collect keys and values into the separate lists:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (uiop:while-collecting (collect-key collect-value)
               (maphash
                (lambda (key value)
                  (collect-key key)
                  (collect-value value))
                the-hash)))
(:FOO :BLAH)
(&amp;quot;bar&amp;quot; &amp;quot;minor&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An interesting feature is a function &lt;code&gt;read-delimited&lt;/code&gt;. It can be useful to read chars from the stream into a limited buffer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (with-input-from-string (stream &amp;quot;The string
with multiple
lines.&amp;quot;)
             (let ((buffer (str:repeat 10 &amp;quot; &amp;quot;)))
               (loop for num-chars = (cl-utilities:read-delimited
                                      buffer
                                      stream)
                     while (not (zerop num-chars))
                     do (format t &amp;quot;~A chars were read~%&amp;quot;
                                num-chars)
                        (format t &amp;quot;Buffer: ~A~2%&amp;quot;
                                (str:substring 0 num-chars
                                               buffer)))))
10 chars were read
Buffer: The string

10 chars were read
Buffer: with multi

2 chars were read
Buffer: le

6 chars were read
Buffer: lines.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Probably this facility is also covered by more popular utility library?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>parse-declarations</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0067-parse-declarations.html</link>
            <description>&lt;p&gt;This library provides advanced facilities to work with declaration forms and can be useful for writing macroses.&lt;/p&gt;
&lt;p&gt;I wasn&apos;t able to imagine a good enough example, but luckily, this library has &lt;a href=&quot;https://common-lisp.net/project/parse-declarations/manual/html_node/Examples.html#Examples&quot;&gt;great documentation&lt;/a&gt; and I stole this example from it.&lt;/p&gt;
&lt;p&gt;It is an analogue of the standard &lt;code&gt;let*&lt;/code&gt; form which expands into multiple &lt;code&gt;let&lt;/code&gt; forms. Maybe you know, &lt;code&gt;let*&lt;/code&gt; can have declarations inside. But to process them correctly, you need to place a declaration related to each variable into its own &lt;code&gt;let&lt;/code&gt; form.&lt;/p&gt;
&lt;p&gt;Here is how this can be done with &lt;code&gt;parse-declarations&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; System and package names are different:
POFTHEDAY&amp;gt; (ql:quickload :parse-declarations-1.0)

POFTHEDAY&amp;gt; (import &amp;#039;(tcr.parse-declarations-1.0::parse-body
                     tcr.parse-declarations-1.0:filter-declaration-env
                     tcr.parse-declarations-1.0:build-declarations
                     tcr.parse-declarations-1.0:check-declaration-env
                     tcr.parse-declarations-1.0:parse-declarations))

POFTHEDAY&amp;gt; (defmacro custom-let* (bindings &amp;amp;body body &amp;amp;environment macro-env)
    (flet ((normalize-binding (binding)
             (cond ((symbolp binding)    `(,binding nil))
                   ((null (cdr binding)) `(,(car binding) nil))
                   (t binding))))
      (multiple-value-bind (real-body decls) (parse-body body :documentation nil)
        (let ((decl-env (parse-declarations decls macro-env)))
          (check-declaration-env decl-env :unknown-allowed nil :warn-only t)
          (labels ((generate-nested-lets (bindings &amp;amp;optional used-binding-names)
                     (if (null bindings)
                         `(locally
                              ,@(build-declarations &amp;#039;declare
                                  (filter-declaration-env decl-env :include :free)
                                  (filter-declaration-env decl-env :include :bound
                                                          :not-affecting used-binding-names))
                            ,@real-body)
                         (destructuring-bind ((var value) . more-bindings) bindings
                           `(let ((,var ,value))
                              ,@(build-declarations &amp;#039;declare
                                  (filter-declaration-env decl-env :affecting `(,var)))
                              ,(generate-nested-lets more-bindings (cons var used-binding-names)))))))
            (generate-nested-lets (mapcar #&amp;#039;normalize-binding bindings)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pay attention that &lt;code&gt;parse-body&lt;/code&gt; function is intentionally is not exported to not conflict with &lt;code&gt;alexandria:parse-body&lt;/code&gt;. Author considered that many lispers do import all alexandria&apos;s symbols into their packages.&lt;/p&gt;
&lt;p&gt;By the way, Alexandria implements only a simple version of the &lt;code&gt;parse-body&lt;/code&gt; function and does not support all advanced features of &lt;code&gt;parse-declarations&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But let&apos;s see how our macro will expand!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (custom-let* ((a 1)
                         (b (* a 0.01)))
             (declare (type fixnum a)
                      (type single-float b))
             (list a b))

;; It expands to -&amp;gt;
(let ((a 1))
  (declare (type fixnum a))
  (let ((b (* a 0.01)))
    (declare (type single-float b))
    (locally (list a b))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, our single declaration form was torn apart and each part placed into the correct place inside nested &lt;code&gt;lets&lt;/code&gt;. Great!&lt;/p&gt;
&lt;h2&gt;How does it work&lt;/h2&gt;&lt;p&gt;There are three phases:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;parse-declarations&lt;/code&gt; parses whole body passed to the &lt;code&gt;custom-let*&lt;/code&gt; and   extracts forms related to type declarations. It stores them in a   special &lt;code&gt;env&lt;/code&gt; object.&lt;/li&gt;&lt;li&gt;&lt;code&gt;filter-declaration-env&lt;/code&gt; allows us to select only declarations related   to the needed variable.&lt;/li&gt;&lt;li&gt;&lt;code&gt;build-declarations&lt;/code&gt; transforms one or many &lt;code&gt;env&lt;/code&gt; objects into the lists   of symbols so that they can be used for the macro-expansion.&lt;/li&gt;&lt;/ul&gt;
</description>
        </item>
        <item>
            <title>str</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0066-str.html</link>
            <description>&lt;p&gt;This is a single purpose utility library. Before switching to the &lt;code&gt;str&lt;/code&gt;, I used &lt;code&gt;cl-strings&lt;/code&gt;, but &lt;code&gt;str&lt;/code&gt; library is more consistent.&lt;/p&gt;
&lt;p&gt;I like that unlike standard functions, &lt;code&gt;str&lt;/code&gt; is able to work with chars and strings as delimiter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (str:split #\Space
                      &amp;quot;Foo bar bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)

POFTHEDAY&amp;gt; (str:split &amp;quot; &amp;quot;
                      &amp;quot;Foo bar bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)

;; Also it is able to skip empty strings:
POFTHEDAY&amp;gt; (str:split &amp;quot; &amp;quot;
                      &amp;quot;Foo   bar   bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;bazz&amp;quot;)

POFTHEDAY&amp;gt; (str:split-omit-nulls &amp;quot; &amp;quot;
                      &amp;quot;Foo   bar   bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Parameter ordering can seem a little strange at first glance, but they&apos;ve made this way to make it easier to &lt;code&gt;curry&lt;/code&gt; functions.&lt;/p&gt;
&lt;p&gt;For example, if we have a multiline text and want to put ellipsis at the end of string longer than X, we might do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *text* &amp;quot;
This line is much longer than we need.
This one is also too long.

I can&amp;#039;t belive!
&amp;quot;&amp;quot;&amp;quot;)

POFTHEDAY&amp;gt; (str:unlines
            (mapcar (alexandria:curry #&amp;#039;str:shorten 20)
                    (str:lines *text*)))
&amp;quot;
This line is much...
This one is also ...

I can&amp;#039;t belive!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BTW &lt;code&gt;str&lt;/code&gt; has very &lt;a href=&quot;https://vindarel.github.io/cl-str/&quot;&gt;cool documentation&lt;/a&gt;. I&apos;d like to have such docs for other CL libraries.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>rutils</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0065-rutils.html</link>
            <description>&lt;p&gt;Rutils translated as Radical Utilities. It is a collection of many useful utilities. Some of the utilities can be found in other libraries, for example, arrow macro or short notation for lambdas.&lt;/p&gt;
&lt;p&gt;There is an interesting &lt;a href=&quot;https://github.com/vseloved/rutils/blob/master/docs/ann-rutils.md&quot;&gt;document&lt;/a&gt; which describes why &lt;code&gt;rutils&lt;/code&gt; is so radical. In short - it provides a reader macro for hash tables and short aliases for many common lisp operators and generic accessors. &lt;/p&gt;
&lt;p&gt;Previously I didn&apos;t dig into the &lt;code&gt;rutils&lt;/code&gt; documentation and used only a few functions to work with lists. But now I found a &lt;a href=&quot;https://github.com/vseloved/rutils/blob/master/docs/tutorial.md&quot;&gt;great tutorial&lt;/a&gt; covering most &lt;code&gt;rutils&lt;/code&gt; features. I recommend you to spend few evenings reading it and trying different code samples.&lt;/p&gt;
&lt;p&gt;Here is a small example which demonstrates how hash table syntax and generic accessors work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:in-readtable rutils:rutils-readtable)

POFTHEDAY&amp;gt; (import &amp;#039;rutils:?)

POFTHEDAY&amp;gt; (let ((obj #h(:foo &amp;#039;(1 2 3))))
             (? obj :foo 1))
2

;; It also works with curly braces:
POFTHEDAY&amp;gt; (let ((obj #{:foo &amp;#039;(1 2 3)}))
             (? obj :foo 1))
2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here a question mark is an abbreviation for &lt;code&gt;rutils:generic-elt&lt;/code&gt; generic and you can define a custom method to access different kinds of containers.&lt;/p&gt;
&lt;p&gt;I definitely will try to use more of &lt;code&gt;rutils&lt;/code&gt; in my code now.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>xml-emitter</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0064-xml-emitter.html</link>
            <description>&lt;p&gt;This library can be used to generate XML. You can use it for outputting any XML, but I use its builtin helpers to generate RSS feed.&lt;/p&gt;
&lt;p&gt;Here is how to generate RSS feed in Common Lisp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (with-output-to-string (s)
             (xml-emitter:with-rss2 (s :encoding &amp;quot;utf-8&amp;quot;)
               (xml-emitter:rss-channel-header &amp;quot;Common Lisp Project of the Day&amp;quot; 
                                               &amp;quot;https://poftheday.org&amp;quot;)
               (xml-emitter:rss-item &amp;quot;First post&amp;quot;
                                     :description &amp;quot;Hello World&amp;quot;
                                     :category &amp;quot;lisp&amp;quot;)))

&amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;utf-8\&amp;quot;?&amp;gt;
&amp;lt;rss version=\&amp;quot;2.0\&amp;quot;&amp;gt;
    &amp;lt;channel&amp;gt;
        &amp;lt;title&amp;gt;Common Lisp Project of the Day&amp;lt;/title&amp;gt;
        &amp;lt;link&amp;gt;https://poftheday.org&amp;lt;/link&amp;gt;
        &amp;lt;generator&amp;gt;xml-emitter&amp;lt;/generator&amp;gt;
        &amp;lt;language&amp;gt;en-us&amp;lt;/language&amp;gt;
        &amp;lt;item&amp;gt;
            &amp;lt;title&amp;gt;First post&amp;lt;/title&amp;gt;
            &amp;lt;description&amp;gt;Hello World&amp;lt;/description&amp;gt;
            &amp;lt;category&amp;gt;lisp&amp;lt;/category&amp;gt;
        &amp;lt;/item&amp;gt;
    &amp;lt;/channel&amp;gt;
&amp;lt;/rss&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of cause, you easily can generate any XML as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (with-output-to-string (s)
             (xml-emitter:with-xml-output (s)
               (xml-emitter:with-tag (&amp;quot;address-book&amp;quot;)
                 (xml-emitter:with-tag (&amp;quot;contact&amp;quot;)
                   (xml-emitter:emit-simple-tags
                    :name &amp;quot;Bob&amp;quot;
                    :email &amp;quot;bob@perkins.com&amp;quot;
                    :note &amp;quot;My friend.&amp;quot;))
                 (xml-emitter:with-tag (&amp;quot;contact&amp;quot;)
                   (xml-emitter:emit-simple-tags
                    :name &amp;quot;Mary&amp;quot;
                    :twitter &amp;quot;https://twitter.com/mary&amp;quot;)))))

&amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;ISO-8859-1\&amp;quot;?&amp;gt;
&amp;lt;address-book&amp;gt;
    &amp;lt;contact&amp;gt;
        &amp;lt;name&amp;gt;Bob&amp;lt;/name&amp;gt;
        &amp;lt;email&amp;gt;bob@perkins.com&amp;lt;/email&amp;gt;
        &amp;lt;note&amp;gt;My friend.&amp;lt;/note&amp;gt;
    &amp;lt;/contact&amp;gt;
    &amp;lt;contact&amp;gt;
        &amp;lt;name&amp;gt;Mary&amp;lt;/name&amp;gt;
        &amp;lt;twitter&amp;gt;https://twitter.com/mary&amp;lt;/twitter&amp;gt;
    &amp;lt;/contact&amp;gt;
&amp;lt;/address-book&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Please, note that support for &lt;a href=&quot;https://www.w3schools.com/xml/xml_namespaces.asp&quot;&gt;XML namespaces&lt;/a&gt; is very limited. You can only specify a namespace for some tags. Namespace prefixes are not supported.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>asdf-viz</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0063-asdf-viz.html</link>
            <description>&lt;p&gt;Today I decided it will be more interesting to investigate Lisp systems which I already have as dependencies of my projects. That is why I&apos;ve remembered about &lt;code&gt;asdf-viz&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ASDF-VIZ&lt;/code&gt; is able to render a graph of ASDF systems. It can be installed as Unix scripts using &lt;a href=&quot;https://github.com/roswell/roswell&quot;&gt;Roswell&lt;/a&gt; or used from the REPL.&lt;/p&gt;
&lt;p&gt;Also, you&apos;ll need a &lt;a href=&quot;https://www.graphviz.org/&quot;&gt;Graphviz&lt;/a&gt; program installed.&lt;/p&gt;
&lt;p&gt;Now we&apos;ll render a graph of all dependencies of the &lt;code&gt;poftheday&lt;/code&gt; system:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (setf cl-dot:*dot-path* &amp;quot;/usr/local/bin/dot&amp;quot;)

POFTHEDAY&amp;gt; (asdf-viz:visualize-asdf-hierarchy
            &amp;quot;docs/media/0063/systems.png&amp;quot;
            (list (asdf:find-system :poftheday)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the result:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0063/systems.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Interestingly, &lt;code&gt;asdf-viz&lt;/code&gt; not only can draw a system&apos;s dependencies but also class hierarchies and call graphs.&lt;/p&gt;
&lt;p&gt;Here is a small example, how to render a class hierarchy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (asdf-viz.class-hierarchy:visualize-class-hierarchy
            &amp;quot;docs/media/0063/classes.png&amp;quot;
            (list &amp;#039;cl-org-mode::node))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And this is the resulting graph:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0063/classes.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;I think it might be useful to integrate &lt;code&gt;asdf-viz&lt;/code&gt; into IDE.&lt;/p&gt;
&lt;p&gt;Probably Emacs might show graphs in a separate buffer? Or LispWorks IDE is able to do this?&lt;/p&gt;
&lt;p&gt;P.S. – next system will be chosen from the dependencies of the &lt;code&gt;poftheday&lt;/code&gt; system.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>magic-ed</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0062-magic-ed.html</link>
            <description>&lt;p&gt;This strange library replaces standard &lt;code&gt;cl:ed&lt;/code&gt; function with a new one, which executes editor specified in the &lt;code&gt;EDITOR&lt;/code&gt; environment variable.&lt;/p&gt;
&lt;p&gt;It does not work from SLY, so I had to run a raw REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;* sb-ext:*ed-functions*
 NIL
 * (cl:ed &amp;quot;qlfile&amp;quot;)

 debugger invoked on a SB-INT:EXTENSION-FAILURE in thread
 #&amp;lt;THREAD &amp;quot;main thread&amp;quot; RUNNING {1000518083}&amp;gt;:
   Don&amp;#039;t know how to ED qlfile
 See also:
   The SBCL Manual, Variable *ED-FUNCTIONS*

 Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.

 restarts (invokable by number or by possibly-abbreviated name):
   0: [ABORT] Exit debugger, returning to top level.

 (ED &amp;quot;qlfile&amp;quot;)
 0] ^D
 * (ql:quickload :magic-ed)
 To load &amp;quot;magic-ed&amp;quot;:
   Load 1 ASDF system:
     magic-ed
 ; Loading &amp;quot;magic-ed&amp;quot;

 (:MAGIC-ED)
 * sb-ext:*ed-functions*
 (MAGIC-ED:ED-EDITOR)
 * (cl:ed &amp;quot;qlfile&amp;quot;)
 T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, this library provides a function &lt;code&gt;magic-ed&lt;/code&gt; which is able to return file&apos;s content and evaluate the lisp code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;* (magic-ed:magic-ed &amp;quot;/tmp/foo&amp;quot; :output :string)
 ...
 HERE Vim WAS STARTED AND I EDITED THE FILE
 ...
 &amp;quot;(format t \&amp;quot;Blah~%\&amp;quot;)
 &amp;quot;
 *&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Can somebody tell me when this could be useful if you can just use Emacs and SLIME?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-charms</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0061-cl-charms.html</link>
            <description>&lt;p&gt;Two days ago I &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0059-cl-ncurses.html&quot;&gt;reviewed the cl-ncurses&lt;/a&gt;. &lt;code&gt;CL-Charms&lt;/code&gt; is also a binding to &lt;code&gt;ncurses&lt;/code&gt;, but uses more universal and portable &lt;a href=&quot;https://common-lisp.net/project/cffi/manual/html_node/&quot;&gt;CFFI&lt;/a&gt; instead of &lt;a href=&quot;http://quickdocs.org/uffi/&quot;&gt;UFFI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;By the way, LEM (Common Lisp Emacs) uses &lt;code&gt;cl-charms&lt;/code&gt; for it&apos;s console backend.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CL-Charms&lt;/code&gt; provides a high-level API besides a low level. I&apos;ve ported my previous &lt;code&gt;echo&lt;/code&gt; program to it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun main (&amp;amp;rest argv)
  (declare (ignorable argv))
  (with-curses ()
    (enable-raw-input)
    (enable-extra-keys *standard-window*)
    (disable-echoing)

    (write-string-at-cursor *standard-window*
                            &amp;quot;Type any character to see it in bold:
&amp;quot;)

    (let ((ch (get-char *standard-window*)))

      (cond
        ((eql ch (code-char 265))
         (write-string-at-cursor *standard-window*
                                 &amp;quot;F1 Key pressed&amp;quot;))
        (t
         (write-string-at-cursor *standard-window*
                                 &amp;quot;The pressed key is &amp;quot;)

         (cl-charms/low-level:attron cl-charms/low-level:a_bold)
         (write-string-at-cursor *standard-window*
                                 (format nil &amp;quot;~A~%&amp;quot; ch))
         (cl-charms/low-level:attroff cl-charms/low-level:a_bold)))
      

      (get-char *standard-window*))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Interesting that &lt;code&gt;cl-charms/low-level&lt;/code&gt; package can be used as a drop-in replacement for &lt;code&gt;cl-ncurses&lt;/code&gt; and my second example worked without any changes except a change &lt;a href=&quot;https://github.com/40ants/lisp-project-of-the-day/blob/master/test/0061/window.ros#L11-L12&quot;&gt;in the use clause&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;A few words about portability&lt;/h2&gt;&lt;h3&gt;CL-NCURSES&lt;/h3&gt;&lt;p&gt;I must admit, that working with such kind of bindings can be problematic. For example, I haven&apos;t any problems using neither &lt;code&gt;cl-ncurses&lt;/code&gt; nor &lt;code&gt;cl-charms&lt;/code&gt; on OSX, but there was a problem with starting an example program on Ubuntu Bionic.&lt;/p&gt;
&lt;p&gt;On Ubuntu &lt;code&gt;cl-ncurses&lt;/code&gt; is unable to find &lt;code&gt;libncurses.so&lt;/code&gt; and you have to load it manually like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; These paths are harcoded in the cl-ncurses:
(defvar *ncurses-search-paths*
  #-win32&amp;#039;(&amp;quot;/usr/local/lib64/&amp;quot; &amp;quot;/usr/local/lib/&amp;quot; &amp;quot;/lib64/&amp;quot; &amp;quot;/lib/&amp;quot; &amp;quot;/usr/lib64/&amp;quot; &amp;quot;/usr/lib/&amp;quot;)
  #+win32&amp;#039;(&amp;quot;/users/jacob/src/pdc31dll/&amp;quot;))

;; On Ubuntu Bionic you have to add this
;; before cl-ncurses initscr call:
(uffi:load-foreign-library &amp;quot;/lib/x86_64-linux-gnu/libncurses.so.5.9&amp;quot;
                           :module &amp;quot;cl-ncurses&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;CL-CHARMS&lt;/h3&gt;&lt;p&gt;&lt;code&gt;CL-Charms&lt;/code&gt; has another problem. It requires the &lt;code&gt;libncurses5-dev&lt;/code&gt; package to be installed on Ubuntu. Without that, it has problem when compiling the CFFI Grovel&apos;s files:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;; cc -o /root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel-tmpBF3HHBTQ.o -c -g -Wall -Wundef -Wsign-compare -Wpointer-arith -O3 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -Wunused-parameter -fno-omit-frame-pointer -momit-leaf-frame-pointer -fno-pie -fPIC -I/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.21.0/ /root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel.c
/root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel.c:6:10: fatal error: ncurses.h: No such file or directory
 #include &amp;lt;ncurses.h&amp;gt;
          ^~~~~~~~~~~
compilation terminated.
Unhandled CFFI-GROVEL:GROVEL-ERROR in thread #&amp;lt;error printing a SB-THREAD:THREAD: #&amp;lt;PRINT-NOT-READABLE {10042938A3}&amp;gt;&amp;gt;: Subprocess #&amp;lt;UIOP/LAUNCH-PROGRAM::PROCESS-INFO {100428DCF3}&amp;gt;
 with command (&amp;quot;cc&amp;quot; &amp;quot;-o&amp;quot; &amp;quot;/root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel-tmpBF3HHBTQ.o&amp;quot; &amp;quot;-c&amp;quot; &amp;quot;-g&amp;quot; &amp;quot;-Wall&amp;quot; &amp;quot;-Wundef&amp;quot; &amp;quot;-Wsign-compare&amp;quot; &amp;quot;-Wpointer-arith&amp;quot; &amp;quot;-O3&amp;quot; &amp;quot;-D_LARGEFILE_SOURCE&amp;quot; &amp;quot;-D_LARGEFILE64_SOURCE&amp;quot; &amp;quot;-D_FILE_OFFSET_BITS=64&amp;quot; &amp;quot;-Wunused-parameter&amp;quot; &amp;quot;-fno-omit-frame-pointer&amp;quot; &amp;quot;-momit-leaf-frame-pointer&amp;quot; &amp;quot;-fno-pie&amp;quot; &amp;quot;-fPIC&amp;quot; &amp;quot;-I/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.21.0/&amp;quot; &amp;quot;/root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel.c&amp;quot;)
 exited with error code 1

Backtrace for: #&amp;lt;SB-THREAD:THREAD &amp;quot;main thread&amp;quot; RUNNING {10004F04C3}&amp;gt;
0: (SB-DEBUG::DEBUGGER-DISABLED-HOOK #&amp;lt;CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; {1004291F73}&amp;gt; #&amp;lt;unused argument&amp;gt; :QUIT T)
1: (SB-DEBUG::RUN-HOOK *INVOKE-DEBUGGER-HOOK* #&amp;lt;CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; {1004291F73}&amp;gt;)
2: (INVOKE-DEBUGGER #&amp;lt;CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; {1004291F73}&amp;gt;)
3: (ERROR CFFI-GROVEL:GROVEL-ERROR :FORMAT-CONTROL &amp;quot;~a&amp;quot; :FORMAT-ARGUMENTS (#&amp;lt;UIOP/RUN-PROGRAM:SUBPROCESS-ERROR {10042917F3}&amp;gt;))
4: (CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; #&amp;lt;UIOP/RUN-PROGRAM:SUBPROCESS-ERROR {10042917F3}&amp;gt;)
5: ((FLET &amp;quot;THUNK&amp;quot; :IN CFFI-GROVEL:PROCESS-GROVEL-FILE))&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Possible Solution?&lt;/h3&gt;&lt;p&gt;Probably, &lt;a href=&quot;https://twitter.com/borodust&quot;&gt;@borodust&lt;/a&gt;&apos;s &lt;a href=&quot;https://github.com/borodust/claw&quot;&gt;claw&lt;/a&gt; and &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/04/0041-bodge-blobs-support.html&quot;&gt;bodge-blobs-support&lt;/a&gt; can solve these issues?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>clawk</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0060-clawk.html</link>
            <description>&lt;p&gt;This library provides a DSL for text processing in a way as AWK does. For those who aren&apos;t familiar with it, AWK is a language for text processing.&lt;/p&gt;
&lt;p&gt;AWK reads lines, splits them into the fields and applies some pattern-matching to them.&lt;/p&gt;
&lt;p&gt;CLAWK allows forOB solving similar tasks in Lisp.&lt;/p&gt;
&lt;p&gt;It does not have documentation but there are some examples, based on examples from this AWK book from 1988:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0060/awk-book.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;All examples use file &lt;code&gt;emp.data&lt;/code&gt; as an input:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; text&apos;&gt;Beth    4.00    0
Dan     3.75    0
Kathy   4.00    10
Mark    5.00    20
Mary    5.50    22
Suzie   4.25    18&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An example I want to show you is equivalent to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; bash&apos;&gt;$ awk &amp;#039;$3 &amp;gt; 0 {print $1, $2 * $3}&amp;#039; emp.data
Kathy 40
Mark 100
Mary 121
Suzie 76.5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It counts the salary for each employee.&lt;/p&gt;
&lt;p&gt;Here is Common Lisp version which uses CLAWK:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (for-file-lines (&amp;quot;docs/media/0060/emp.data&amp;quot;)
              (with-fields ((name payrate hours))
                 (when ($&amp;gt; hours 0)
                    ($print name ($* payrate hours)))))

Kathy 40.0 
Mark 100.0 
Mary 121.0 
Suzie 76.5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code is more semantic because we used named fields. However, you can use $1, $2, $3 if you with as well.&lt;/p&gt;
&lt;p&gt;Above example is expanded into such code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(with-open-file (#:g1 &amp;quot;docs/media/0060/emp.data&amp;quot;
                      :direction :input
                      :element-type &amp;#039;character
                      :if-does-not-exist :error)
  (let ((#:g1 #:g1))
    (when (eq #:g1 &amp;#039;t)
      (setq #:g1 *standard-input*))
    (unless (null #:g1)
      (let ((*curfile* nil)
            (*curline* &amp;quot;&amp;quot;)
            (*fnr* -1))
        (macrolet ((clawk::next ()
                     &amp;#039;(throw #:g2)))
          (prog (#:g4)
           #:g2
            (setq #:g4 (read-line #:g1 nil :eof))
            (unless (eq #:g4 :eof)
              (setq *curline* #:g4
                    $0 #:g4)
              (incf *nr*)
              (incf *fnr*)
              (catch &amp;#039;#:g2
                (let* ((#:g3 (split nil (clawk::fs)))
                       (*nf* (length #:g3)))
                  (declare (special *nf*))
                  (destructuring-bind
                      (name payrate hours)
                      #:g3
                    (when ($&amp;gt; hours 0)
                      ($print name ($* payrate hours))))))
              (go #:g2))))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code reads and parses the file, tracks some variables like row number, fields count and more. And calls your code to further processing.&lt;/p&gt;
&lt;p&gt;You can find more examples in this file:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sharplispers/clawk/blob/master/clawktest.lisp&quot;&gt;https://github.com/sharplispers/clawk/blob/master/clawktest.lisp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For me, CLAWK seems a nice tool to process files line by line from Common Lisp.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-ncurses</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0059-cl-ncurses.html</link>
            <description>&lt;p&gt;This library is binding to NCurses. It allows for creating windowing interfaces for the console. With NCurses you can print to any place of the screen, change colors and probably do some other awesome things.&lt;/p&gt;
&lt;p&gt;I took a few examples from the original NCurses documentation:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/index.html&quot;&gt;https://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It was pretty straightforward to port them to Common Lisp.&lt;/p&gt;
&lt;p&gt;The first example just wait for any key and print this key in bold:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun main (&amp;amp;rest argv)
  (declare (ignorable argv))
  (initscr)
  (raw)
  (keypad *stdscr* 1)
  (noecho)
  (printw &amp;quot;Type any character to see it in bold:
&amp;quot;)
  (let ((ch (getch)))
    (cond
      ((= ch 265)
       (printw &amp;quot;F1 Key pressed&amp;quot;))
      (t
       (printw &amp;quot;The pressed key is &amp;quot;)
       (attron a_bold)
       (printw (format nil &amp;quot;~A~%&amp;quot; (code-char ch)))
       (attroff a_bold)))
    (refresh)
    (getch)
    (endwin)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Second example a little bit complex. It uses fetches the size of the terminal and prints &quot;Hello Lisp Word!&quot; in the centre. After that, it draws a border using pseudographics:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0059/ncurses-hello.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here is the code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun main (&amp;amp;rest argv)
  &amp;quot;This example is based on:
   https://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/windows.html&amp;quot;
  (declare (ignorable argv))
  (initscr)
  (start-color)
  (init-pair 1
             color_red
             color_black)

  (let ((text &amp;quot;Hello Lisp World!&amp;quot;))
    (multiple-value-bind (screen-height screen-width)
        (get-maxyx *stdscr*)
      (let* ((text-len (length text))
             (box-width (+ text-len 4))
             (box-height 5)
             (box-x (round (/ (- screen-width box-width)
                              2)))
             (box-y (round (/ (- screen-height box-height)
                              2)))
             (plus (char-code #\+))
             (h-line (char-code #\-))
             (v-line (char-code #\|)))

        (attron (color-pair 1))

        ;; It&amp;#039;s time to print a text in the center of the screen:
        (mvprintw (+ box-y 2) (+ box-x 2) text)
        
        ;; Now we&amp;#039;ll draw a border around the box.
        ;; Horizontal lines:
        (mvhline box-y box-x
                 h-line box-width)
        (mvhline (+ box-y (1- box-height)) box-x
                 h-line box-width)
        ;; Vertical lines:
        (mvvline box-y box-x
                 v-line box-height)
        (mvvline box-y (+ box-x (1- box-width))
                 v-line box-height)
        ;; And corners
        (mvaddch box-y box-x
                 plus)
        (mvaddch box-y (+ box-x (1- box-width))
                 plus)
        (mvaddch (+ box-y (1- box-height))
                 (+ box-x (1- box-width))
                 plus)
        (mvaddch (+ box-y (1- box-height)) box-x
                 plus)
        (move 0 0))))

  ;; Wait for key press
  (getch)
  (endwin))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Full examples are available here:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/40ants/lisp-project-of-the-day/tree/master/test/0059&quot;&gt;https://github.com/40ants/lisp-project-of-the-day/tree/master/test/0059&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;That is it. If you need an interactive interface in the console, use cl-ncurses!&lt;/p&gt;
</description>
        </item>
        <item>
            <title>atomics</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0058-atomics.html</link>
            <description>&lt;p&gt;This is a portability library for access to atomic operation primitives such as &lt;code&gt;compare-and-swap&lt;/code&gt;, &lt;code&gt;atomic-incf&lt;/code&gt; and &lt;code&gt;atomic-decf&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Atomic operations are particularly useful for implementing lockless algorithms.&lt;/p&gt;
&lt;p&gt;Here is an example of using compare and swap under SBCL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((foo (list 1 2 3 4)))
             (atomics:cas (car foo)
                          1
                          42)
             foo)

-&amp;gt; (LET ((FOO (LIST 1 2 3 4)))
     (LET ((#:OLD0 1))
       (EQ #:OLD0
           (LET ((#:CONS1 FOO))
             (LET ((#:OLD2 #:OLD0))
               (LET ((#:NEW3 42))
                 (SB-KERNEL:%COMPARE-AND-SWAP-CAR #:CONS1
                                                  #:OLD2
                                                  #:NEW3))))))
     FOO)

(42 2 3 4)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&quot;atomics&quot;, like all &lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@shinmera&apos;s&lt;/a&gt; libraries, has a &lt;a href=&quot;https://shinmera.github.io/atomics/&quot;&gt;good documentation&lt;/a&gt; where you can find details on support for atomics operations in different CL implementations.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>pretty-function</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0057-pretty-function.html</link>
            <description>&lt;p&gt;This small library makes debugging easier when you are using many anonymous functions. With &lt;code&gt;pretty-functions&lt;/code&gt; you can give names to your lambdas.&lt;/p&gt;
&lt;p&gt;Here is a traceback you&apos;ll have with ordinal lambda:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun bar ()
             (error &amp;quot;Hello World!&amp;quot;))

POFTHEDAY&amp;gt; (defun foo (func)
             (funcall func))

POFTHEDAY&amp;gt; (foo (lambda ()
                  (bar)))

-&amp;gt;
Hello World!
   [Condition of type SIMPLE-ERROR]

Restarts:
 0: [RETRY] Retry SLY mREPL evaluation request.
 1: [*ABORT] Return to SLY&amp;#039;s top level.
 2: [ABORT] abort thread (#&amp;lt;THREAD &amp;quot;sly-channel-1-mrepl-remote-1&amp;quot; RUNNING {1003785853}&amp;gt;)

Backtrace:
 0: (BAR)
 1: ((LAMBDA ()))
 2: (SB-INT:SIMPLE-EVAL-IN-LEXENV (FOO (LAMBDA NIL (BAR))) #A&amp;lt;NULL-LEXENV&amp;gt;)
 3: (EVAL (FOO (LAMBDA NIL (BAR))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With &lt;code&gt;pretty-function&lt;/code&gt; we should see the name instead of &lt;code&gt;LAMBDA&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (pretty-function:enable-pretty-function-printing)

POFTHEDAY&amp;gt; (foo (pretty-function:named-lambda bar-caller ()
                  (bar)))

-&amp;gt;
Hello World!
   [Condition of type SIMPLE-ERROR]

Restarts:
 0: [RETRY] Retry SLY mREPL evaluation request.
 1: [*ABORT] Return to SLY&amp;#039;s top level.
 2: [ABORT] abort thread (#&amp;lt;THREAD &amp;quot;sly-channel-1-mrepl-remote-1&amp;quot; RUNNING {100394D853}&amp;gt;)

Backtrace:
 0: (BAR)
 1: ((LAMBDA ()))
 2: (FOO #&amp;lt;FUNCTION (LAMBDA NIL) {2253906B}&amp;gt;)
 3: (SB-INT:SIMPLE-EVAL-IN-LEXENV (FOO (PRETTY-FUNCTION:NAMED-LAMBDA BAR-CALLER NIL (BAR))) #&amp;lt;NULL-LEXENV&amp;gt;)
 4: (EVAL (FOO (PRETTY-FUNCTION:NAMED-LAMBDA BAR-CALLER NIL (BAR))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, it does not work. Probably, because &lt;code&gt;SLY&lt;/code&gt; turns off &lt;code&gt;*pretty-print*&lt;/code&gt; when rendering the traceback. At least, it does not work in SBCL.&lt;/p&gt;
&lt;p&gt;Almost the same result we&apos;ll get if request a backtrace as a list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (block test
               (handler-bind ((error (lambda (c)
                                       (return-from test
                                         (sb-debug:backtrace-as-list 7)))))
                 (foo (pretty-function:named-lambda bar-caller ()
                        (bar)))))

(((FLET &amp;quot;H0&amp;quot; :IN TEST) #&amp;lt;unused argument&amp;gt;)
 (SB-KERNEL::%SIGNAL #&amp;lt;SIMPLE-ERROR &amp;quot;Hello World!&amp;quot; {10050B8763}&amp;gt;)
 (ERROR &amp;quot;Hello World!&amp;quot;)
 (BAR)
 ((LAMBDA () :IN TEST))
 (FOO #&amp;lt;named-lambda BAR-CALLER&amp;gt;)
 ((LAMBDA ())))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Named function has its name only when it is rendered as function&apos;s argument. But anyway, it is useful.&lt;/p&gt;
&lt;p&gt;Probably, it will work better on other supported implementations: Allegro, Clisp, CMU, Lispworks or MCL.&lt;/p&gt;
&lt;p&gt;More complex example uses another macro - &lt;code&gt;named-lambda*&lt;/code&gt;. It allows to use of arbitrary form to return a current name of a lambda function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *f*
             (let ((n 0))
               (pretty-function:named-lambda*
                   ;; a form to return a description
                   (format nil &amp;quot;counter=~A&amp;quot; n)
                   () ;; arguments
                 (incf n))))

POFTHEDAY&amp;gt; *f*
#&amp;lt;named-lambda counter=0&amp;gt;

POFTHEDAY&amp;gt; (funcall *f*)
1

POFTHEDAY&amp;gt; *f*
#&amp;lt;named-lambda counter=1&amp;gt;

POFTHEDAY&amp;gt; (funcall *f*)
2

POFTHEDAY&amp;gt; *f*
#&amp;lt;named-lambda counter=2&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You might want to make a shorter name like &lt;code&gt;&lt;counter=1&gt;&lt;/code&gt;, then you need to use lower-level macro &lt;code&gt;with-function-printer&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *f*
             (let ((n 0))
               (pretty-function:with-function-printer
                   ;; A lambda to wriite a description
                   (lambda (s) (format s &amp;quot;#&amp;lt;counter=~A&amp;gt;&amp;quot; n))
                 ;; A lambda to do a real job
                 (lambda ()
                   (incf n)))))

POFTHEDAY&amp;gt; *f*
#&amp;lt;counter=0&amp;gt;

POFTHEDAY&amp;gt; (funcall *f*)
1

POFTHEDAY&amp;gt; *f*
#&amp;lt;counter=1&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of cause, with Lisp, you always can write your own syntax sugar around this macro.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>trivial-indent</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0056-trivial-indent.html</link>
            <description>&lt;p&gt;This is another great library by &lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@shinmera&lt;/a&gt;. It is a portability layer for defining indentation rules for both SLIME and &lt;a href=&quot;http://joaotavora.github.io/sly/#A-SLY-tour-for-SLIME-users&quot;&gt;SLY&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let&apos;s pretend we have a macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defmacro super-let (name value &amp;amp;body body)
             `(let ((,name ,value))
                ,@body))

POFTHEDAY&amp;gt; (super-let foo
               100500
             (format nil &amp;quot;Foo is ~A&amp;quot; foo))
&amp;quot;Foo is 100500&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what if we want Emacs to indent it like this?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (super-let foo
                      100500
             (format nil &amp;quot;Foo is ~A&amp;quot; foo))
&amp;quot;Foo is 100500&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we can set indentation rule, and &lt;code&gt;trivial-indent&lt;/code&gt; will make it work for both SLIME and SLY:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; This rule says: indent first two arguments
;; with 11 spaces if they are on their own line.
;; And other arguments indent like usual function&amp;#039;s body.
POFTHEDAY&amp;gt; (trivial-indent:define-indentation super-let
               (11 11 &amp;amp;body))

;; And now all super-let form will be indented according to this rule.
POFTHEDAY&amp;gt; (super-let blah
                      &amp;#039;minor
             (format nil &amp;quot;blah -&amp;gt; ~A&amp;quot; blah))
&amp;quot;blah -&amp;gt; MINOR&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I have an advice for you. If you are using &lt;code&gt;SLY&lt;/code&gt;, it might cache indentation rules. When you&apos;ve defined a rule but don&apos;t see an effect, call &lt;code&gt;(slynk:update-indentation-information)&lt;/code&gt; in the REPL.&lt;/p&gt;
&lt;p&gt;Now let&apos;s try to define a more complex indentation rule. Yesterday I wrote such macro for running Genetic Algorithm:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(def macro run-ga ((genome &amp;amp;key (population-size 100)
                                (max-iterations 1000)
                                (survive-ratio 0.5))
                   &amp;amp;body fitness-code)
  (let ((var-names (get-var-names genome)))
    
    (unless genome
      ...)))

;; After that you might run it like this:

(run-ga (((x 0 10)
          (y -10 10)
          (z &amp;#039;(:foo :bar :bazz)))
         :max-iterations 100
         :survive-ratio 0.2)
  
  ;; Our fitness-function
  (abs (- (ecase z
            (:foo 10)
            (:bar 100)
            (:bazz 1000))
           (+ x y))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, without special rules, these algorithm parameters are hard to distinguish from the genom definition (the first argument).&lt;/p&gt;
&lt;p&gt;But what if we want to separate keyword arguments visually and to make this form look like this?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(run-ga (((x 0 10)
          (y -10 10)s
          (z &amp;#039;(:foo :bar :bazz)))
    :max-iterations 100
    :survive-ratio 0.2)
  
  ;; Our fitness-function
  (abs (- (ecase z
            (:foo 10)
            (:bar 100)
            (:bazz 1000))
           (+ x y))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then we might define the following rule:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (trivial-indent:define-indentation
               genetic-algorithm:run-ga
               ((&amp;amp;whole &amp;amp;lambda &amp;amp;rest -4) &amp;amp;body))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It says, that &lt;code&gt;run-ga&lt;/code&gt; macro has a list-like first argument. Keyword &lt;code&gt;&amp;whole &amp;lambda&lt;/code&gt; tells that first item of this list would be indented as a regular lambda-list.&lt;/p&gt;
&lt;p&gt;Following &lt;code&gt;&amp;rest -4&lt;/code&gt; tells Emacs to deindent rest items of the first list.&lt;/p&gt;
&lt;p&gt;And finally, &lt;code&gt;&amp;body&lt;/code&gt; keyword says to handle the rest of the macro arguments like a function&apos;s body.&lt;/p&gt;
&lt;p&gt;There is also ability to define a custom function which will decide how to indent a form. But I didn&apos;t use this feature yet.&lt;/p&gt;
&lt;p&gt;You can read detail about the structure of indentation rules in &lt;a href=&quot;https://github.com/jwiegley/emacs-release/blob/adfd5933358fdf6715423dee8169eb3cd7d982db/lisp/emacs-lisp/cl-indent.el#L180-L248&quot;&gt;this Emacs docstring&lt;/a&gt;.&lt;/p&gt;
</description>
        </item>
    </channel>
</rss>