<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>lack-middleware-csrf</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0113-lack-middleware-csrf.html</link>
            <description>&lt;p&gt;This lack middleware provides some level of security for your webapp, preventing a &lt;a href=&quot;https://owasp.org/www-community/attacks/csrf&quot;&gt;CSRF attacks&lt;/a&gt;. It has a function &lt;code&gt;csrf-html-tag&lt;/code&gt; which returns a hidden &lt;code&gt;input&lt;/code&gt; element to embed into a form.&lt;/p&gt;
&lt;p&gt;The input stores a special token. Middleware saves this token into the current session and ensures the user sends this token in the following requests. If he doesn&apos;t, a 400 status code will be returned.&lt;/p&gt;
&lt;p&gt;Let&apos;s take our yesterday&apos;s app and make it more secure!&lt;/p&gt;
&lt;p&gt;First, we need to rewrite our main application to make it render a login form with CSRF token. Pay attention to how does it call a &lt;code&gt;csrf-html-tag&lt;/code&gt; function at the end.&lt;/p&gt;
&lt;p&gt;If you are going to develop an application with a lots of forms, then it is good idea to define a macro which will apply CSRF protection automatically.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun main (env)
             (let* ((session (getf env :lack.session))
                    (login (gethash :login session)))
               (cond
                 (login
                  (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                        (list (format nil &amp;quot;Welcome, ~A!&amp;quot;
                                      login))))
                 (t
                  (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                        (list (format nil &amp;quot;
&amp;lt;form method=\&amp;quot;POST\&amp;quot; action=\&amp;quot;/login\&amp;quot;&amp;gt;
  &amp;lt;input type=\&amp;quot;text\&amp;quot; name=\&amp;quot;login\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  &amp;lt;input type=\&amp;quot;password\&amp;quot; name=\&amp;quot;password\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  ~A
&amp;lt;/form&amp;gt;
&amp;quot;
                          (lack.middleware.csrf:csrf-html-tag session))))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;All other apps remain the same, we only need to build the whole app including the &lt;code&gt;csrf&lt;/code&gt; middleware.&lt;/p&gt;
&lt;p&gt;This middleware should go after the &lt;code&gt;:session&lt;/code&gt; middleware, because it depends on it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             :session
             :csrf
             (:mount &amp;quot;/login&amp;quot; &amp;#039;login)
             (:mount &amp;quot;/logout&amp;quot; &amp;#039;logout)
             &amp;#039;main)
            :port 8091)
Hunchentoot server is started.
Listening on 127.0.0.1:8091.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is how our form is rendered. Note a &quot;hidden&quot; input at the end of the form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8091/&amp;quot;)
&amp;quot;
&amp;lt;form method=\&amp;quot;POST\&amp;quot; action=\&amp;quot;/login\&amp;quot;&amp;gt;
  &amp;lt;input type=\&amp;quot;text\&amp;quot; name=\&amp;quot;login\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  &amp;lt;input type=\&amp;quot;password\&amp;quot; name=\&amp;quot;password\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  &amp;lt;input type=\&amp;quot;hidden\&amp;quot; name=\&amp;quot;_csrf_token\&amp;quot; value=\&amp;quot;8de1c8a47\&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we try to do a &lt;code&gt;POST&lt;/code&gt; request without the token, we&apos;ll receive a 400 error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (handler-case
               (dex:post &amp;quot;http://localhost:8091/login&amp;quot;
                         :content &amp;#039;((&amp;quot;login&amp;quot; . &amp;quot;bob&amp;quot;)
                                    (&amp;quot;password&amp;quot; . &amp;quot;$ecret&amp;quot;))
                         :headers &amp;#039;((:cookie . &amp;quot;lack.session=75bccc&amp;quot;)))
             (dexador:http-request-failed (c)
               (values (dexador:response-status c)
                       (dexador:response-body c))))
400
&amp;quot;Bad Request: invalid CSRF token&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using the code we&apos;ll be able to log in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:post &amp;quot;http://localhost:8091/login&amp;quot;
                     :content &amp;#039;((&amp;quot;login&amp;quot; . &amp;quot;bob&amp;quot;)
                                (&amp;quot;password&amp;quot; . &amp;quot;$ecret&amp;quot;)
                                (&amp;quot;_csrf_token&amp;quot; . &amp;quot;8de1c8a47&amp;quot;))
                     :headers &amp;#039;((:cookie . &amp;quot;lack.session=75bccc&amp;quot;)))
&amp;quot;Dear Bob, you welcome!&amp;quot;
200&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The middleware also has a few settings.&lt;/p&gt;
&lt;p&gt;You can set &lt;code&gt;:session-key&lt;/code&gt; to a value other than &lt;code&gt;_csrf_token&lt;/code&gt;. But this changes only a token&apos;s key inside the session. Form field&apos;s name remains the &lt;code&gt;_csrf_token&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Other option is &lt;code&gt;:one-time&lt;/code&gt;. Set it to true if you want to remove a token from the session after the first successful &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;PATCH&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And finally, you can define your own handler for the error page and pass it as &quot;:block-app&quot;. It should be a usual Clack app.&lt;/p&gt;
</description>
            <pubDate>Sun, 28 Jun 2020 22:31:02 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-session</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0112-lack-middleware-session.html</link>
            <description>&lt;p&gt;This middleware makes your app stateful and allows to associate some information with the current user.&lt;/p&gt;
&lt;p&gt;There are two abstractions behind Lack sessions - state and store.&lt;/p&gt;
&lt;p&gt;State object defines how to keep track of a session. Lack includes only one type of state class. It keeps state id in the browser&apos;s cookies.&lt;/p&gt;
&lt;p&gt;Store object defines where to store data, associated with a state. There are three store classes in the Lack. The default stores data in memory, using a hash table. There are also &lt;code&gt;dbi&lt;/code&gt; and &lt;code&gt;redis&lt;/code&gt; stores.&lt;/p&gt;
&lt;p&gt;Now let&apos;s create an app that allows a user to login in and logout.&lt;/p&gt;
&lt;p&gt;First, we need an app for logging it checks the password as we did in yesterday&apos;s &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0111-lack-middleware-auth-basic.html&quot;&gt;post on basic auth&lt;/a&gt;. If the password is correct, we&apos;ll put a user&apos;s login into a session&apos;s hash:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun login (env)
             (let* ((params (getf env :body-parameters))
                    (login (alexandria:assoc-value
                            params
                            &amp;quot;login&amp;quot; :test #&amp;#039;string=))
                    (password (alexandria:assoc-value
                               params
                               &amp;quot;password&amp;quot; :test #&amp;#039;string=))
                    (session (getf env
                                   :lack.session)))
               (cond
                 ((and (string= login
                                &amp;quot;bob&amp;quot;)
                       (string= password
                                &amp;quot;$ecret&amp;quot;))
                  (setf (gethash :login
                                 session)
                        login)
                  &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                    (&amp;quot;Dear Bob, you welcome!&amp;quot;)))
                 (t
                  &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                    (&amp;quot;Wrong password!&amp;quot;))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, we need a function to logout. It set&apos;s a special flag to let middleware know that all session data should be wiped from the store:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun logout (env)
             (setf (getf (getf env :lack.session.options)
                         :expire)
                   t)
             &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
               (&amp;quot;Now you are logged our&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The main app will use data from the session and will show a welcome message if the user is authenticated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun main (env)
             (let* ((session (getf env :lack.session))
                    (login (gethash :login session)))
               (cond
                 (login
                  (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                        (list (format nil &amp;quot;Welcome, ~A!&amp;quot;
                                      login))))
                 (t
                  &amp;#039;(403 (:content-type &amp;quot;text/plain&amp;quot;)
                        (&amp;quot;Access denied&amp;quot;))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally, we need to combine these apps using &lt;code&gt;mount&lt;/code&gt; middleware (it was &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0109-lack-middleware-mount.html&quot;&gt;reviewed a few days ago&lt;/a&gt;) and slap the &lt;code&gt;session&lt;/code&gt; middleware on it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             :session
             (:mount &amp;quot;/login&amp;quot; &amp;#039;login)
             (:mount &amp;quot;/logout&amp;quot; &amp;#039;logout)
             &amp;#039;main)
            :port 8089)
Hunchentoot server is started.
Listening on 127.0.0.1:8089.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s try to log in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8090/&amp;quot;))
&amp;quot;Access denied&amp;quot;

POFTHEDAY&amp;gt; (multiple-value-bind (response code headers)
               (dex:post &amp;quot;http://localhost:8090/login&amp;quot;
                         :content &amp;#039;((&amp;quot;login&amp;quot; . &amp;quot;bob&amp;quot;)
                                    (&amp;quot;password&amp;quot; . &amp;quot;$ecret&amp;quot;)))
             (values response code
                     (rutils:hash-table-to-alist headers)))
&amp;quot;Dear Bob, you welcome!&amp;quot;
200
((&amp;quot;date&amp;quot; . &amp;quot;Sat, 27 Jun 2020 20:47:13 GMT&amp;quot;)
 (&amp;quot;server&amp;quot; . &amp;quot;Hunchentoot 1.2.38&amp;quot;)
 (&amp;quot;transfer-encoding&amp;quot; . &amp;quot;chunked&amp;quot;)
 (&amp;quot;content-type&amp;quot; . &amp;quot;text/plain&amp;quot;)
 (&amp;quot;set-cookie&amp;quot;
  &amp;quot;lack.session=b10c66; path=/; expires=Fri, 23 Dec 2140 17:24:51 GMT&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The server returned the &quot;set-cookie&quot; header. Usually, the browser will pass this cookie content during the following requests. We&apos;ll emulate this behavior to make a request to the main app:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((headers &amp;#039;((:cookie . &amp;quot;lack.session=b10c66&amp;quot;))))
             (values (dex:get &amp;quot;http://localhost:8090/&amp;quot;
                              :headers headers)))
&amp;quot;Welcome, bob!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally, we&apos;ll check how does log out will work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((headers &amp;#039;((:cookie . &amp;quot;lack.session=b10c66&amp;quot;))))
             (values (dex:post &amp;quot;http://localhost:8090/logout&amp;quot;
                               :headers headers)))
&amp;quot;Now you are logged out&amp;quot;

POFTHEDAY&amp;gt; (let ((headers &amp;#039;((:cookie . &amp;quot;lack.session=b10c66&amp;quot;))))
             (dex:get &amp;quot;http://localhost:8090/&amp;quot;
                              :headers headers))
&amp;quot;Access denied&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;See!? We&apos;ve built a simple web application using Lack micro-framework! Add something like Spinneret to render HTML and &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/03/0021-lass.html&quot;&gt;Lass&lt;/a&gt; + &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0071-parenscript.html&quot;&gt;Parenscript&lt;/a&gt; to render CSS and JS and we&apos;ll have a full-fledged webapp!&lt;/p&gt;
</description>
            <pubDate>Sat, 27 Jun 2020 23:59:57 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-auth-basic</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0111-lack-middleware-auth-basic.html</link>
            <description>&lt;p&gt;This Lack middleware is also undocumented, but it is short enough to understand from sources how to configure it.&lt;/p&gt;
&lt;p&gt;When configuring this middleware, you should pass it a function which accepts username and password and returns a &lt;code&gt;t&lt;/code&gt; if the password is correct. Also, this function may return a user object as a second value. Returned user or original username from the HTTP header will be added to the environment plist as &lt;code&gt;:remote-user&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil
                                   &amp;quot;Hello ~A!&amp;quot;
                                   (getf env :remote-user))))))

POFTHEDAY&amp;gt; (defun auth (user pass)
             (when (and (string= user &amp;quot;bob&amp;quot;)
                        (string= pass &amp;quot;$ecret&amp;quot;))
               (values t
                       &amp;quot;Bob The Admin&amp;quot;)))

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:auth-basic :authenticator #&amp;#039;auth)
             *app*)
            :port 8080)
Hunchentoot server is started.
Listening on 127.0.0.1:8080.

POFTHEDAY&amp;gt; (handler-case (dex:get &amp;quot;http://localhost:8080/foo/bar&amp;quot;)
             (error (condition)
               (values (dex:response-status condition)
                       (dex:response-body condition))))
401 (9 bits, #x191)
&amp;quot;Authorization required&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8080/foo/bar&amp;quot;
                    :basic-auth &amp;#039;(&amp;quot;bob&amp;quot; . &amp;quot;$ecret&amp;quot;))
&amp;quot;Hello Bob The Admin!&amp;quot;
200&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. Very simple, isn&apos;t it?&lt;/p&gt;
&lt;p&gt;But please, don&apos;t hardcode passwords in the sources as I did :)&lt;/p&gt;
</description>
            <pubDate>Fri, 26 Jun 2020 20:53:29 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-static</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0110-lack-middleware-static.html</link>
            <description>&lt;p&gt;This middleware can be used to serve files from a directory. However, I don&apos;t recommend using it for production because it should be inefficient because a few lambdas are created on each request.&lt;/p&gt;
&lt;p&gt;The middleware should be parametrized with two arguments: &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;root&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;path&lt;/code&gt; is a prefix from the URL. The &lt;code&gt;root&lt;/code&gt; is the root directory on the local filesystem. For example, if &lt;code&gt;root&lt;/code&gt; is &lt;code&gt;/tmp/files/&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;/static/&lt;/code&gt; then for URL &lt;code&gt;http://my-site.com/static/some/file.txt&lt;/code&gt; Lack will return content of the &lt;code&gt;/tmp/files/some/file.txt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is a small example, showing how does it work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lambda (env)
               &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                 (&amp;quot;A main app&amp;#039;s response&amp;quot;))))

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:static
              ;; This is a path of URL
              ;; to serve static files
              :path &amp;quot;/static/&amp;quot;
              ;; from this directory
              ;; on the filesystem
              :root #P&amp;quot;./static-files/&amp;quot;)
             *app*)
            :port 8082)
Hunchentoot server is started.
Listening on 127.0.0.1:8082.

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8082/static/the-file.txt&amp;quot;))
&amp;quot;My static file&amp;quot;

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8082/static/missing.txt&amp;quot;))
; Debugger entered on #&amp;lt;DEXADOR.ERROR:HTTP-REQUEST-NOT-FOUND {100B944133}&amp;gt;

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8082/other/path&amp;quot;))
&amp;quot;A main app&amp;#039;s response&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you can pass a function as a &lt;code&gt;path&lt;/code&gt; argument. This way some sort of filtering may be done. The function should return another path and you probably will need to remove a prefix from it.&lt;/p&gt;
&lt;p&gt;For example, if we want to serve only a &lt;code&gt;css&lt;/code&gt; files from the &lt;code&gt;static-files&lt;/code&gt; directory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (alexandria:write-string-into-file
            &amp;quot;Some secret README&amp;quot;
            #P&amp;quot;static-files/README.txt&amp;quot;)

POFTHEDAY&amp;gt; (alexandria:write-string-into-file
            &amp;quot;Just CSS file&amp;quot;
            #P&amp;quot;static-files/the.css&amp;quot;)

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:static
              ;; This is a function to filter filename
              ;; of the served static files:
              :path (lambda (original-path)
                      ;; When this function returns nil,
                      ;; the request is passed to the main application.
                      (when (and (str:ends-with-p &amp;quot;.css&amp;quot;
                                                  original-path)
                                 (str:starts-with-p &amp;quot;/static/&amp;quot;
                                                    original-path))
                        ;; you need to rewrite the path manually:
                        (subseq original-path 7)))
              ;; from this directory
              ;; on the filesystem
              :root #P&amp;quot;./static-files/&amp;quot;)
             *app*)
            :port 8085)
Hunchentoot server is started.
Listening on 127.0.0.1:8085.

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8085/static/the.css&amp;quot;)
&amp;quot;Just CSS file&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8085/static/README.txt&amp;quot;)
&amp;quot;A main app&amp;#039;s response&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is no any way to return 404 or 403 error in this case. This should be done on the main app&apos;s level.&lt;/p&gt;
&lt;p&gt;That is it for today. Tomorrow we&apos;ll how to protect your app with basic auth!&lt;/p&gt;
</description>
            <pubDate>Thu, 25 Jun 2020 21:15:21 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-mount</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0109-lack-middleware-mount.html</link>
            <description>&lt;p&gt;We continue to review Lack&apos;s middlewares and this one gives you the ability to route requests to different apps depending on the path.&lt;/p&gt;
&lt;p&gt;Here is a quick example. We want to plug a &lt;code&gt;blog&lt;/code&gt; and &lt;code&gt;admin&lt;/code&gt; into our main app:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *main-app*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil &amp;quot;~A~%This is main app!&amp;quot;
                                   (getf env :path-info))))))

POFTHEDAY&amp;gt; (defparameter *blog*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil &amp;quot;~A~%The Blog.&amp;quot;
                                   (getf env :path-info))))))

POFTHEDAY&amp;gt; (defparameter *admin*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil &amp;quot;~A~%Administration interface.&amp;quot;
                                   (getf env :path-info))))))

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:mount &amp;quot;/blog&amp;quot; *blog*)
             (:mount &amp;quot;/admin&amp;quot; *admin*)
             *main-app*)
            :port 8044)
Hunchentoot server is started.
Listening on 127.0.0.1:8044.

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8044/some/page&amp;quot;)
&amp;quot;/some/page
This is main app!&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8044/blog/post-1&amp;quot;)
&amp;quot;/post-1
The Blog.&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8044/admin/blog/posts?id=1&amp;quot;)
&amp;quot;/blog/posts
Administration interface.&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pay attention to paths, returned as the first line of each response. It is relative to the mount point. This middleware rewrites the path so that an app can be mounted with any prefix.&lt;/p&gt;
&lt;p&gt;That is it for today. Yesterday we&apos;ll see how we can serve static with Lack.&lt;/p&gt;
</description>
            <pubDate>Wed, 24 Jun 2020 22:50:22 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-backtrace</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0108-lack-middleware-backtrace.html</link>
            <description>&lt;p&gt;You might consider this a cheating, but I really want to review all Lack middlewares regardless most of them are from the same &lt;code&gt;Lack&lt;/code&gt; project. These middlewares are loadable as separate ASDF systems.&lt;/p&gt;
&lt;p&gt;The problem of Lack middlewares is that they are not documented.&lt;/p&gt;
&lt;p&gt;This middleware will output a backtrace and all request parameters to the stream or a file.&lt;/p&gt;
&lt;p&gt;If you are using &lt;code&gt;clack:clackup&lt;/code&gt; function to start your app, it will apply a &lt;code&gt;backtrace&lt;/code&gt; middleware to it, unless &lt;code&gt;:use-default-middlewares nil&lt;/code&gt; argument was given. Without configuration, all backtraces will be written to &lt;code&gt;*error-output*&lt;/code&gt; stream.&lt;/p&gt;
&lt;p&gt;Let&apos;s see how does it work!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lambda (env)
               (declare (ignorable env))
               (error &amp;quot;Oh my God!&amp;quot;)))
*APP*
POFTHEDAY&amp;gt; (clack:clackup *app*
                          :port 8085)
Hunchentoot server is started.
Listening on 127.0.0.1:8085.

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8085/foo/bar&amp;quot;))
Backtrace for: #&amp;lt;SB-THREAD:THREAD &amp;quot;hunchentoot-worker-127.0.0.1:56469&amp;quot; RUNNING {1007707373}&amp;gt;
0: ((LAMBDA NIL :IN UIOP/IMAGE:PRINT-BACKTRACE))
1: ((FLET &amp;quot;THUNK&amp;quot; :IN UIOP/STREAM:CALL-WITH-SAFE-IO-SYNTAX))
2: (SB-IMPL::%WITH-STANDARD-IO-SYNTAX #&amp;lt;CLOSURE (FLET &amp;quot;THUNK&amp;quot; :IN UIOP/STREAM:CALL-WITH-SAFE-IO-SYNTAX) {D85A24B}&amp;gt;)
3: (UIOP/STREAM:CALL-WITH-SAFE-IO-SYNTAX #&amp;lt;CLOSURE (LAMBDA NIL :IN UIOP/IMAGE:PRINT-BACKTRACE) {100791B9EB}&amp;gt; :PACKAGE :CL)
4: (UIOP/IMAGE:PRINT-CONDITION-BACKTRACE #&amp;lt;SIMPLE-ERROR &amp;quot;Oh my God!&amp;quot; {100791B943}&amp;gt; :STREAM #&amp;lt;SYNONYM-STREAM :SYMBOL SLYNK::*CURRENT-ERROR-OUTPUT* {1001541093}&amp;gt; :COUNT NIL)
5: (LACK.MIDDLEWARE.BACKTRACE::PRINT-ERROR #&amp;lt;SIMPLE-ERROR &amp;quot;Oh my God!&amp;quot; {100791B943}&amp;gt; (:REQUEST-METHOD :GET :SCRIPT-NAME &amp;quot;&amp;quot; :PATH-INFO &amp;quot;/foo/bar&amp;quot; :SERVER-NAME &amp;quot;localhost&amp;quot; :SERVER-PORT 8085 :SERVER-PROTOCOL :HTTP/1.1 ...) #&amp;lt;SYNONYM-STREAM :SYMBOL SLYNK::*CURRENT-ERROR-OUTPUT* {1001541093}&amp;gt;)
6: ((FLET LACK.MIDDLEWARE.BACKTRACE::OUTPUT-BACKTRACE :IN &amp;quot;/Users/art/projects/lisp/lisp-project-of-the-day/.qlot/dists/ultralisp/software/fukamachi-lack-20200524065357/src/middleware/backtrace.lisp&amp;quot;) #&amp;lt;SIMPLE-ERROR &amp;quot;Oh my God!&amp;quot; {100791B943}&amp;gt; (:REQUEST-METHOD :GET :SCRIPT-NAME &amp;quot;&amp;quot; :PATH-INFO &amp;quot;/foo/bar&amp;quot; :SERVER-NAME &amp;quot;localhost&amp;quot; :SERVER-PORT 8085 :SERVER-PROTOCOL :HTTP/1.1 ...))
...
31: (SB-THREAD::NEW-LISP-THREAD-TRAMPOLINE #&amp;lt;SB-THREAD:THREAD &amp;quot;hunchentoot-worker-127.0.0.1:56469&amp;quot; RUNNING {1007707373}&amp;gt; NIL #&amp;lt;CLOSURE (LABELS BORDEAUX-THREADS::%BINDING-DEFAULT-SPECIALS-WRAPPER :IN BORDEAUX-THREADS::BINDING-DEFAULT-SPECIALS) {100770731B}&amp;gt; NIL)
32: (&amp;quot;foreign function: call_into_lisp&amp;quot;)
33: (&amp;quot;foreign function: new_thread_trampoline&amp;quot;)
Above backtrace due to this condition:
Oh my God!

Request:
    REQUEST-METHOD: :GET
    SCRIPT-NAME: &amp;quot;&amp;quot;
    PATH-INFO: &amp;quot;/foo/bar&amp;quot;
    SERVER-NAME: &amp;quot;localhost&amp;quot;
    SERVER-PORT: 8085
    SERVER-PROTOCOL: :HTTP/1.1
    REQUEST-URI: &amp;quot;/foo/bar&amp;quot;
    URL-SCHEME: &amp;quot;http&amp;quot;
    REMOTE-ADDR: &amp;quot;127.0.0.1&amp;quot;
    REMOTE-PORT: 56469
    QUERY-STRING: NIL
    RAW-BODY: #&amp;lt;FLEXI-STREAMS:FLEXI-IO-STREAM {100791B313}&amp;gt;
    CONTENT-LENGTH: 0
    CONTENT-TYPE: NIL
    CLACK.STREAMING: T
    CLACK.IO: #&amp;lt;CLACK.HANDLER.HUNCHENTOOT::CLIENT {100791B363}&amp;gt;
    HEADERS:
        user-agent: &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
        host: &amp;quot;localhost:8085&amp;quot;
        accept: &amp;quot;*/*&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The problem here is that I did not receive a 500 error. An interactive debugger popped up instead and HTTP request finished with a timeout. To solve this problem, we need to pass a &lt;code&gt;:debug nil&lt;/code&gt; argument to &lt;code&gt;clackup&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(clack:clackup *app*
               :port 8085
               :debug nil)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we&apos;ll try other configuration of this backtrace middleware.&lt;/p&gt;
&lt;p&gt;To write output to the file, you need to specify the output option. It can be either a string or a pathname:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:backtrace :output &amp;quot;/tmp/errors.log&amp;quot;)
             *app*)
            :port 8089
            :debug nil
            ;; If you don&amp;#039;t turn off this,
            ;; backtrace also will be written to the
            ;; *error-output*.
            :use-default-middlewares nil)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you can pass as the output a variable pointing to the stream:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:backtrace :output *trace-output*)
             *app*)
            :port 8090
            :debug nil
            :use-default-middlewares nil)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another interesting option is &lt;code&gt;:result-on-error&lt;/code&gt;. It can be a function or a list with the response data. This way we can return a customized error response:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:backtrace :output &amp;quot;/tmp/errors.log&amp;quot;
                         :result-on-error
                         &amp;#039;(500 (:content-type &amp;quot;text/plain&amp;quot;)
                           (&amp;quot;Stay patient. &amp;quot;
                            &amp;quot;We already fixing this error in the REPL&amp;quot;)))
             *app*)
            :port 8092
            :debug nil
            :use-default-middlewares nil)

POFTHEDAY&amp;gt; (handler-case (dex:get &amp;quot;http://localhost:8092/foo/bar&amp;quot;)
             (error (condition)
               condition))

#&amp;lt;DEXADOR.ERROR:HTTP-REQUEST-INTERNAL-SERVER-ERROR {1009B3BA03}&amp;gt;

POFTHEDAY&amp;gt; (dexador:response-status *)
500
POFTHEDAY&amp;gt; (dexador:response-body **)
&amp;quot;Stay patient. We already fixing this error in the REPL&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Specifying a function as an error handler allows you to render an error response using information from the unhandled condition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun make-error-response (condition)
             (list 500 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                   (list (format nil
                                 &amp;quot;Unhandled error: ~A&amp;quot;
                                 condition))))

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:backtrace :output &amp;quot;/tmp/errors.log&amp;quot;
                         :result-on-error
                         #&amp;#039;make-error-response)
             *app*)
            :port 8093
            :use-default-middlewares nil)

POFTHEDAY&amp;gt; (handler-case (dex:get &amp;quot;http://localhost:8093/foo/bar&amp;quot;)
             (error (condition)
               (values (dex:response-status condition)
                       (dex:response-body condition))))
500
&amp;quot;Unhandled error: Oh my God!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Notice, I didn&apos;t specify a &lt;code&gt;:debug nil&lt;/code&gt; argument for &lt;code&gt;clackup&lt;/code&gt;. When you are using &lt;code&gt;:result-on-error&lt;/code&gt; argument on backtrace middleware, it will return a response before the lisp debugger will have a chance to pop up.&lt;/p&gt;
&lt;p&gt;If you want to invoke debugger in some cases, you can call a &lt;code&gt;(invoke-debugger condition)&lt;/code&gt; somewhere inside &lt;code&gt;make-error-response&lt;/code&gt; function.&lt;/p&gt;
&lt;p&gt;Yesterday we&apos;ll review some other Lack&apos;s middleware.&lt;/p&gt;
</description>
            <pubDate>Tue, 23 Jun 2020 23:15:52 +0300</pubDate>
        </item>
        <item>
            <title>lack</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0107-lack.html</link>
            <description>&lt;p&gt;&lt;code&gt;Lack&lt;/code&gt; is a library, used by &lt;code&gt;Clack&lt;/code&gt; to compose web apps from middlewares.&lt;/p&gt;
&lt;p&gt;Yesterday &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0106-lack-middleware-accesslog.html&quot;&gt;we&apos;ve used&lt;/a&gt; the &lt;code&gt;lack-middleware-accesslog&lt;/code&gt; system to log every request to our webapp. But app configuration was not convenient. &lt;code&gt;Lack&lt;/code&gt; provides a macro to compose an application from middlewares:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lack:builder
              ;; middlewares
              :accesslog
              ;; the app
              (lambda (env)
                (declare (ignorable env))
                &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                  (&amp;quot;Hello, World&amp;quot;)))))

POFTHEDAY&amp;gt; (clack:clackup *app*
                          :port 8080)
Hunchentoot server is started.
Listening on 127.0.0.1:8080.

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8080/foo/bar&amp;quot;))
127.0.0.1 - [22/Jun/2020:22:15:23 +03:00] &amp;quot;GET /foo/bar HTTP/1.1&amp;quot;
         200 12 &amp;quot;-&amp;quot; &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You can pass a middleware as a keyword or as a s-exp. In the slatter case, all values except the first one, will be passed to the middleware functions.&lt;/p&gt;
&lt;p&gt;This way a middleware can be configured. Here is for example, how we can replace a logging function to use &lt;code&gt;log4cl&lt;/code&gt; (by the way, remind me to tell you about &lt;code&gt;log4cl&lt;/code&gt;, it is wonderful!):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lack:builder
              ;; middlewares
              (:accesslog :logger
                          (lambda (message)
                            (log:info message)))
              ;; the app
              (lambda (env)
                (declare (ignorable env))
                &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                  (&amp;quot;Hello, World&amp;quot;)))))

POFTHEDAY&amp;gt; (clack:clackup *app*
                          :port 8081)

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8081/foo/bar&amp;quot;))

 &amp;lt;INFO&amp;gt; [22:38:06] poftheday () -
  POFTHEDAY::MESSAGE: &amp;quot;127.0.0.1 - [22/Jun/2020:22:38:06 +03:00] 
                \&amp;quot;GET /foo/bar HTTP/1.1\&amp;quot; 200 12 \&amp;quot;-\&amp;quot;
                \&amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0\&amp;quot;&amp;quot;
  
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Multiple middlewares can be passed to the &lt;code&gt;lack:builder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When we are specifying the middleware&apos;s name as a keyword, lack tries to search a middleware function using &lt;code&gt;lack.util:find-middleware&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lack.util:find-middleware :accesslog)

#&amp;lt;FUNCTION (LAMBDA (LACK.MIDDLEWARE.ACCESSLOG::APP &amp;amp;KEY :LOGGER :FORMATTER)
             :IN
             &amp;quot;/Users/art/projects/lisp/lisp-project-of-the-day/.qlot/dists/\
  ultralisp/software/fukamachi-lack-20200524065357/src/middleware/accesslog.lisp&amp;quot;)
  {22D1F6CB}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you intend to create an opensource library providing &lt;code&gt;Lack&lt;/code&gt; middleware and want this discovery work for it, then you have to follow these rules.&lt;/p&gt;
&lt;p&gt;Your system has to define a package prefixed with &lt;code&gt;LACK.MIDDLEWARE.&lt;/code&gt; And it should export a variable with name matched to the pattern &lt;code&gt;*LACK-MIDDLEWARE-...*&lt;/code&gt;. This variable should be bound to a middleware function.&lt;/p&gt;
&lt;p&gt;For example, access log middleware defines the &lt;code&gt;LACK.MIDDLEWARE.ACCESSLOG:*LACK-MIDDLEWARE-ACCESSLOG*&lt;/code&gt; variable.&lt;/p&gt;
&lt;p&gt;Another interesting feature, I didn&apos;t cover yet the ability to write an app which delays it&apos;s response or stream it back. Luckily, these kinds of applications &lt;a href=&quot;https://github.com/fukamachi/lack#delayed-response-and-streaming-body&quot;&gt;are covered by&lt;/a&gt; &lt;code&gt;Lack&lt;/code&gt;&apos;s documentation.&lt;/p&gt;
&lt;p&gt;Tomorrow, we&apos;ll look at some &lt;code&gt;Lack&apos;s&lt;/code&gt; middleware.&lt;/p&gt;
</description>
            <pubDate>Mon, 22 Jun 2020 22:32:36 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-accesslog</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0106-lack-middleware-accesslog.html</link>
            <description>&lt;p&gt;Yesterday, I&apos;ve showed you how does Clack work. A web app is a function which returns a list with the response or a function which should return create such list pass it to the provided callback.&lt;/p&gt;
&lt;p&gt;Now we&apos;ll add a logging to our app with the &lt;code&gt;lack-middleware-accesslog&lt;/code&gt; system.&lt;/p&gt;
&lt;p&gt;To do this, we must wrap our app&apos;s function into another function like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Now we&amp;#039;ll create a simple app:
POFTHEDAY&amp;gt; (defparameter *app*
             (lambda (env)
               &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                 (&amp;quot;Hello, World&amp;quot;))))

;; And wrap it into the middleware:
POFTHEDAY&amp;gt; (defparameter *app-with-access-log*
             (funcall lack.middleware.accesslog:*lack-middleware-accesslog*
                      *app*))

;; Now it&amp;#039;s time to start our app:
POFTHEDAY&amp;gt; (clack:clackup *app-with-access-log*
                          :port 8000)

Woo server is started.
Listening on 127.0.0.1:8000.

;; And to make a test request:
POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8000/&amp;quot;))
127.0.0.1 - [21/Jun/2020:22:50:52 +03:00] &amp;quot;GET / HTTP/1.1&amp;quot; 
  200 12 &amp;quot;-&amp;quot; &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Look how a log message was printed to the STDOUT.&lt;/p&gt;
&lt;p&gt;Now let&apos;s see how does this middleware works. Here is its content. It is a little bit complicated because the middleware needs to handle cases when an app returns a function instead of the normal response:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defparameter *lack-middleware-accesslog*
  (let ((no-body &amp;#039;#:no-body))
    (lambda (app &amp;amp;key
              (logger
               (lambda (output) (format t &amp;quot;~&amp;amp;~A~%&amp;quot; output)))
              (formatter #&amp;#039;default-formatter))
      (lambda (env)
        (funcall-with-cb
         app env
         (lambda (res)
           (funcall logger
                    (funcall formatter env res (now)))
           res)))))
  &amp;quot;Middleware for logging requests&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I&apos;ll show you a simpler version of this logging middleware:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Here is the middleware:
POFTHEDAY&amp;gt; (defun simple-logging (app)
             (lambda (env)
               (let ((response
                       (funcall app env)))
                 (format t &amp;quot;~A ~A -&amp;gt; ~A~%&amp;quot;
                         (getf env :request-method)
                         (getf env :path-info)
                         (car response))
                 response)))

;; And this is an example how we can apply it to our app:
POFTHEDAY&amp;gt; (defparameter *app-with-simple-log*
             (simple-logging *app*))

POFTHEDAY&amp;gt; (clack:clackup *app-with-simple-log*
                          :port 8000)
Hunchentoot server is started.
Listening on 127.0.0.1:8000.

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8000/&amp;quot;))
GET / -&amp;gt; 200
&amp;quot;Hello, World&amp;quot;

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8000/foo/bar&amp;quot;))
GET /foo/bar -&amp;gt; 200
&amp;quot;Hello, World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow we&apos;ll try the better way to apply middlewares to a Clack app.&lt;/p&gt;
</description>
            <pubDate>Sun, 21 Jun 2020 23:20:42 +0300</pubDate>
        </item>
        <item>
            <title>clack</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0105-clack.html</link>
            <description>&lt;p&gt;Today we begin our sprint around Fukamachi&apos;s web tools and will start from the Clack.&lt;/p&gt;
&lt;p&gt;Clack is an intermediate layer between the real webserver and your application code. It unifies requests parsing and you don&apos;t need to rewrite an app if you&apos;ll decide to run your app under another webserver.&lt;/p&gt;
&lt;p&gt;Today it supports FCGI, Hunchentoot, Toot, Woo, Wookie. Woo and Wookie are asynchronous and can be used to serve hundreds of simultaneous connections.&lt;/p&gt;
&lt;p&gt;Another interesting feature of Clack is that application is the only a lambda function. Because of this, the application code can be wrapped with middlewares. There are a number of middlewares: for logging, handling errors, serving static files, etc.&lt;/p&gt;
&lt;p&gt;Here is an example of the simplest app. A function should return a list of status-code, headers plist and the content. The content should be a list of strings, a vector of bytes or pathname:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *server*
             (clack:clackup
              (lambda (env)
                (declare (ignore env))
                &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                  (&amp;quot;Hello, Lisp World!&amp;quot;)))
              :port 8000))
Hunchentoot server is started.
Listening on 127.0.0.1:8000.

POFTHEDAY&amp;gt; (nth-value 0
             (dex:get &amp;quot;http://localhost:8000&amp;quot;))
&amp;quot;Hello, Lisp World!&amp;quot;

POFTHEDAY&amp;gt; (clack:stop *server*)
T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Compare this with plain Hunchentoot application:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (hunchentoot:define-easy-handler (say-yo :uri &amp;quot;/&amp;quot;) ()
             (setf (hunchentoot:content-type*)
                   &amp;quot;text/plain&amp;quot;)
             &amp;quot;Hello Lisp World&amp;quot;)

POFTHEDAY&amp;gt; (hunchentoot:start
            (make-instance &amp;#039;hunchentoot:easy-acceptor
                           :port 8002))

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8002/&amp;quot;
                    :headers &amp;#039;((&amp;quot;Custom-Header&amp;quot; . &amp;quot;Hello&amp;quot;)))
127.0.0.1 - [2020-06-20 20:58:04] &amp;quot;GET / HTTP/1.1&amp;quot; 200 16 &amp;quot;-&amp;quot; 
            &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
&amp;quot;Hello Lisp World&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Clack version is more coherent. All request parameters are in one place and it is obvious how to return a status code or the headers.&lt;/p&gt;
&lt;p&gt;Here is the content of the env var passed by the Clack to the application function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; For this request:
POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8000/some/path&amp;quot;
                    :headers &amp;#039;((&amp;quot;Custom-Header&amp;quot; . &amp;quot;Hello&amp;quot;)))

;; This plist will be passed as env argument
;; to the function:
(:REQUEST-METHOD :GET
 :SCRIPT-NAME &amp;quot;&amp;quot;
 :PATH-INFO &amp;quot;/some/path&amp;quot;
 :SERVER-NAME &amp;quot;localhost&amp;quot;
 :SERVER-PORT 8000
 :SERVER-PROTOCOL :HTTP/1.1
 :REQUEST-URI &amp;quot;/some/path&amp;quot;
 :URL-SCHEME &amp;quot;http&amp;quot;
 :REMOTE-ADDR &amp;quot;127.0.0.1&amp;quot;
 :REMOTE-PORT 51325
 :QUERY-STRING NIL
 :RAW-BODY #&amp;lt;FLEXI-STREAMS:FLEXI-IO-STREAM {1009183813}&amp;gt;
 :CONTENT-LENGTH 0
 :CONTENT-TYPE NIL
 :CLACK.STREAMING T
 :CLACK.IO #&amp;lt;CLACK.HANDLER.HUNCHENTOOT::CLIENT {1009183863}&amp;gt;
 :HEADERS #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 4 {1009183AE3}&amp;gt;)

;; And here is the content of the HEADERS:
POFTHEDAY&amp;gt; (rutils:print-hash-table
            (getf * :headers))
#{EQUAL
  &amp;quot;user-agent&amp;quot; &amp;quot;Dexador/0.9.14 (SBCL 2.0.2); Darwin; 19.5.0&amp;quot;
  &amp;quot;host&amp;quot; &amp;quot;localhost:8000&amp;quot;
  &amp;quot;accept&amp;quot; &amp;quot;*/*&amp;quot;
  &amp;quot;custom-header&amp;quot; &amp;quot;Hello&amp;quot;
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow we&apos;ll review a Clack middleware and see how to apply to the app.&lt;/p&gt;
</description>
            <pubDate>Sat, 20 Jun 2020 21:12:07 +0300</pubDate>
        </item>
        <item>
            <title>pcall</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0104-pcall.html</link>
            <description>&lt;p&gt;This library contains a few primitives for parallel code execution. It is like a baby lparallel.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PCall&lt;/code&gt; provides a thread pool, few macro to execute and wait parallel task and a thread-safe Queue.&lt;/p&gt;
&lt;p&gt;Here is a simple demo which runs two tasks in parallel and then executes a body. A digit on each line is a number of seconds elapsed since the form was evaluated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((started-at (get-universal-time)))
             (flet ((info (message &amp;amp;rest args)
                      (let ((seconds-since-start
                              (- (get-universal-time)
                                  started-at)))
                        (format t &amp;quot;~A: ~A~%&amp;quot;
                                seconds-since-start
                                (apply #&amp;#039;format nil message
                                       args)))))
               (pcall:plet ((foo (progn (info &amp;quot;Creating Foo&amp;quot;)
                                        (sleep 5)
                                        (info &amp;quot;Foo was created&amp;quot;)
                                        :foo-result))
                            (bar (progn (info &amp;quot;Creating Bar&amp;quot;)
                                        (sleep 3)
                                        (info &amp;quot;Bar was created&amp;quot;)
                                    :bar-result)))
                 (info &amp;quot;Plet&amp;#039;s body is executed immediately.&amp;quot;)
                 (info &amp;quot;And it will wait for the result when you access the value.&amp;quot;)
                 (info &amp;quot;Here is the Bar&amp;#039;s value: ~S&amp;quot;
                       bar)
                 (info &amp;quot;Task foo still executing in the background.&amp;quot;)
                 (info &amp;quot;Here is the Foo&amp;#039;s value: ~S&amp;quot;
                       foo))))
0: Plet&amp;#039;s body is executed immediately.
0: And it will wait for the result when you access the value.
0: Creating Bar
0: Creating Foo
3: Bar was created
3: Here is the Bar&amp;#039;s value: :BAR-RESULT
3: Task foo still executing in the background.
5: Foo was created
5: Here is the Foo&amp;#039;s value: :FOO-RESULT&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are a few more interesting functions allowing to execute and wait for tasks. And a thread-safe queue can be loaded using the standalone system &lt;code&gt;pcall-queue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PCall&lt;/code&gt; can be useful when you don&apos;t need such a sophisticated tool as lparallel and just want to use thread pool or queue.&lt;/p&gt;
&lt;p&gt;If you are interested in trying &lt;code&gt;PCall&lt;/code&gt;, read it&apos;s &lt;a href=&quot;http://marijn.haverbeke.nl/pcall/&quot;&gt;docs here&lt;/a&gt; because it is not hosted on the GitHub and Quickdocs.org does not show it&apos;s docs either.&lt;/p&gt;
</description>
            <pubDate>Fri, 19 Jun 2020 23:16:06 +0300</pubDate>
        </item>
        <item>
            <title>trivial-tco</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0103-trivial-tco.html</link>
            <description>&lt;p&gt;This library could be considered as a &lt;a href=&quot;http://portability.cl/&quot;&gt;portability layer&lt;/a&gt; for tail call optimization.&lt;/p&gt;
&lt;p&gt;When I first found it, I decided it implements a TCO for implementations which do not support it by doing a trampolining trick &lt;a href=&quot;https://macropy3.readthedocs.io/en/latest/tco.html#trampolining&quot;&gt;like this&lt;/a&gt;. But I was wrong.&lt;/p&gt;
&lt;p&gt;It does ensure the proper declaration is used on implementations which support a proper TCO and signals warning or error on others.&lt;/p&gt;
&lt;p&gt;Here is an example on SBCL, which supports TCO only if &lt;code&gt;speed&lt;/code&gt; declared to be greater or equal to &lt;code&gt;debug&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (declaim (optimize (debug 3) (speed 1))

POFTHEDAY&amp;gt; (labels ((sum-aux (acc x)
                        (if (zerop x)
                            acc
                            (sum-aux (+ acc x) (- x 1))))
                      (sum (n)
                        (sum-aux 0 n)))
               (sum 1000000))
Control stack guard page temporarily disabled: proceed with caution
; Debugger entered on #&amp;lt;SB-KERNEL::CONTROL-STACK-EXHAUSTED {1004F12E73}&amp;gt;
[1] POFTHEDAY&amp;gt; 
; Evaluation aborted on #&amp;lt;SB-KERNEL::CONTROL-STACK-EXHAUSTED {1004F12E73}&amp;gt;

POFTHEDAY&amp;gt; (tco:with-tail-call-optimization ()
             (labels ((sum-aux (acc x)
                        (if (zerop x)
                            acc
                            (sum-aux (+ acc x) (- x 1))))
                      (sum (n)
                        (sum-aux 0 n)))
               (sum 1000000)))
500000500000 (39 bits, #x746A5A2920)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This macro gets expanded into:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(let ()
  (declare (optimize (speed 3)))
  (labels ((sum-aux (acc x)
             (if (zerop x)
                 acc
                 (sum-aux (+ acc x) (- x 1))))
           (sum (n)
             (sum-aux 0 n)))
    (sum 1000000)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. Use this library, if you want to employ a tail call and want to ensure they a properly optimized by your Lisp implementation.&lt;/p&gt;
&lt;p&gt;Maybe &lt;a href=&quot;https://0branch.com/notes/tco-cl.html&quot;&gt;this article&lt;/a&gt; by Marc Simpson will be interesting for you. It investigates which Common Lisp implementations have a proper TCO implementation.&lt;/p&gt;
</description>
            <pubDate>Fri, 19 Jun 2020 00:35:23 +0300</pubDate>
        </item>
        <item>
            <title>lass-flexbox</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0102-lass-flexbox.html</link>
            <description>&lt;p&gt;This is an addon to the &lt;code&gt;lass&lt;/code&gt; library, reviewed in &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/03/0021-lass.html&quot;&gt;#0021 post&lt;/a&gt;. &lt;code&gt;Lass-flexbox&lt;/code&gt; adds to &lt;code&gt;lass&lt;/code&gt; an ability to expand Flexbox CSS properties into browser-specific vendor prefixes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lass:compile-and-write
            &amp;#039;(.container :flexbox
              (.item :align-self &amp;quot;center&amp;quot;)))
&amp;quot;.container{
    display: -webkit-box;
    display: -webkit-flex;
    display: -moz-flex;
    display: -ms-flexbox;
    display: flex;
}

.container .item{
    -webkit-align-self: center;
    -moz-align-self: center;
    -ms-flex-item-align: center;
    align-self: center;
}&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I found a great &lt;a href=&quot;https://css-tricks.com/snippets/css/a-guide-to-flexbox/&quot;&gt;illustrated article&lt;/a&gt; on how does Flexbox works and now we&apos;ll try to reproduce some layout from this article:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (format t &amp;quot;&amp;lt;style&amp;gt;~A&amp;lt;/style&amp;gt;
                      &amp;lt;div class=\&amp;quot;example\&amp;quot;&amp;gt;
                        &amp;lt;div class=\&amp;quot;item\&amp;quot;&amp;gt;One&amp;lt;/div&amp;gt;
                        &amp;lt;div class=\&amp;quot;item\&amp;quot;&amp;gt;Two&amp;lt;/div&amp;gt;
                        &amp;lt;div class=\&amp;quot;item\&amp;quot;&amp;gt;Three&amp;lt;/div&amp;gt;
                      &amp;lt;/div&amp;gt;
                     &amp;quot;
                   (lass:compile-and-write
                    &amp;#039;(.example
                      :flexbox
                      :align-items &amp;quot;flex-end&amp;quot;
                      :justify-content &amp;quot;space-around&amp;quot;
                      :border 1px solid gray
                      (.item :margin 0.5rem
                             :padding 0.5rem)
                      ((:and .item (:nth-child 1))
                       :background lime
                       :flex 1
                       :height 30px)
                      ((:and .item (:nth-child 2))
                       :background orange
                       :flex 2
                       :height 70px)
                      ((:and .item (:nth-child 3))
                       :background purple
                       :flex 3
                       :height 50px))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This lisp code will generate us these CSS and HTML:&lt;/p&gt;
&lt;h4&gt;Code&lt;/h4&gt;&lt;pre&gt;&lt;code class=&apos;html :render&apos;&gt;&amp;lt;style&amp;gt;.example{
    display: -webkit-box;
    display: -webkit-flex;
    display: -moz-flex;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-align: end;
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    -moz-align-items: flex-end;
    align-items: flex-end;
    -ms-flex-pack: distribute;
    -webkit-justify-content: space-around;
    -moz-justify-content: space-around;
    justify-content: space-around;
    border: 1px solid gray;
}

.example .item{
    margin: 0.5rem;
    padding: 0.5rem;
}

.example .item:nth-child(1){
    background: lime;
    flex: 1;
    height: 30px;
}

.example .item:nth-child(2){
    background: orange;
    flex: 2;
    height: 70px;
}

.example .item:nth-child(3){
    background: purple;
    flex: 3;
    height: 50px;
}&amp;lt;/style&amp;gt;

&amp;lt;div class=&amp;quot;example&amp;quot;&amp;gt;
  &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;One&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;Two&amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;quot;item&amp;quot;&amp;gt;Three&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;Result&lt;/h4&gt;&lt;style&gt;.example{
    display: -webkit-box;
    display: -webkit-flex;
    display: -moz-flex;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-align: end;
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    -moz-align-items: flex-end;
    align-items: flex-end;
    -ms-flex-pack: distribute;
    -webkit-justify-content: space-around;
    -moz-justify-content: space-around;
    justify-content: space-around;
    border: 1px solid gray;
}

.example .item{
    margin: 0.5rem;
    padding: 0.5rem;
}

.example .item:nth-child(1){
    background: lime;
    flex: 1;
    height: 30px;
}

.example .item:nth-child(2){
    background: orange;
    flex: 2;
    height: 70px;
}

.example .item:nth-child(3){
    background: purple;
    flex: 3;
    height: 50px;
}&lt;/style&gt;

&lt;div class=&quot;example&quot;&gt;
  &lt;div class=&quot;item&quot;&gt;One&lt;/div&gt;
  &lt;div class=&quot;item&quot;&gt;Two&lt;/div&gt;
  &lt;div class=&quot;item&quot;&gt;Three&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Exciting, isn&apos;t it!?&lt;/p&gt;
</description>
            <pubDate>Wed, 17 Jun 2020 20:25:01 +0300</pubDate>
        </item>
        <item>
            <title>prbs</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0101-prbs.html</link>
            <description>&lt;p&gt;&lt;a href=&quot;https://github.com/jlowder/prbs&quot;&gt;This library&lt;/a&gt; provides a pseudo-random binary sequence generator useful for error detection in communication streams. It will be useful, if you are building own protocol over UDP, for example.&lt;/p&gt;
&lt;p&gt;Here is how it works. There is a function which creates a sequence generator. Its result is a lambda function which can return a requested number of random bits:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *generator*
             (prbs:bit-gen 33 :seed (get-universal-time)))

POFTHEDAY&amp;gt; (funcall *generator* 10)
#*0111000101

POFTHEDAY&amp;gt; (funcall *generator* 10)
#*0010011100

POFTHEDAY&amp;gt; (funcall *generator* 10)
#*1011001110&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a function to check if these pieces match the desired sequence. It should be used on the &quot;receiver&quot; to check if the message was corrupted or some packets were lost.&lt;/p&gt;
&lt;p&gt;Let&apos;s simulate a situation when we send our data in 1024 bit chunks and one chunk was lost:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;SENDER&amp;gt; (defparameter *generator*
           (prbs:bit-gen 33 :seed (get-universal-time)))

;; These chunks are generated by the sender side
SENDER&amp;gt; (defparameter *first-chunk*
           (funcall *generator* 1024))

SENDER&amp;gt; *first-chunk*
#*011100010100100111001000001001110111...

SENDER&amp;gt; (defparameter *second-chunk*
           (funcall *generator* 1024))

SENDER&amp;gt; (defparameter *third-chunk*
           (funcall *generator* 1024))

;; The reveiver creates a special tracker
;; when it receives the first chunk of data
RECEIVER&amp;gt; (defparameter *tracker*
             (prbs.err:prbs-lock
              *first-chunk*
              33))
RECEIVER&amp;gt; *tracker*
#&amp;lt;CLOSURE (LAMBDA (PRBS.ERR::BITS) :IN PRBS.ERR::MAKE-TRACKER) {10080FF8BB}&amp;gt;

;; Now let&amp;#039;s pretend we have lost our second packet
;; and process the third right after the first one:
RECEIVER&amp;gt; (funcall *tracker*
             *third-chunk*)
520
2048&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In case of found errors, &lt;code&gt;tracker&lt;/code&gt; returns their number as the first value. The second value is the total number of processed bits. This way we can calculate an error rate. In this case, tracker decided there are 520 bits which have wrong values.&lt;/p&gt;
&lt;p&gt;Let&apos;s simulate another situation when it received the second chunk, but 10 bits were corrupted and their value was flipped:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;SENDER&amp;gt; (defparameter *corrupted-second-chunk*
           (copy-seq *second-chunk*))

;; Accidentally, some bits were corrupted:
IN-THE-MIDDLE&amp;gt; (loop for i from 100 below 110
                     do (setf (bit *corrupted-second-chunk* i)
                              (logxor (bit *corrupted-second-chunk* i)
                                      1)))

RECEIVER&amp;gt; (defparameter *tracker*
            (prbs.err:prbs-lock
             *first-chunk*
             33))

;; Now we process the corrupted chunk:
RECEIVER&amp;gt; (funcall *tracker*
                    *corrupted-second-chunk*)
10
2048

;; After the processing of third chunk,
;; tracker still show us there were encountered 10
;; errors:
RECEIVER&amp;gt; (funcall *tracker*
                   *third-chunk*)
10
3072&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;So, this library will be useful if you&apos;ll decide to implement a protocol which needs to determine if there were errors introduced into the data.&lt;/p&gt;
</description>
            <pubDate>Tue, 16 Jun 2020 22:28:25 +0300</pubDate>
        </item>
        <item>
            <title>the-cost-of-nothing</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0100-the-cost-of-nothing.html</link>
            <description>&lt;p&gt;This is a library by Marco Heisig. It is convenient to use when you want to decide which data structure to use or whether some function is too slow.&lt;/p&gt;
&lt;p&gt;Of cause, you can measure execution time with the &lt;code&gt;time&lt;/code&gt; macro. But in this case, you&apos;ll have to select a number of iteration and to parse &lt;code&gt;time&lt;/code&gt;&apos;s output and do some time manipulation.&lt;/p&gt;
&lt;p&gt;The-cost-of-nothing does everything for you. It runs given form in chunks, measures an execution time for each chunk, divides and calculates average execution time.&lt;/p&gt;
&lt;p&gt;Let&apos;s see how long does it take to access an element in the hash-table.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (time
              (loop repeat 1000000000
                    do (gethash :foo h))))
Evaluation took:
  0.271 seconds of real time
  0.270554 seconds of total run time (0.270170 user, 0.000384 system)
  100.00% CPU
  597,543,804 processor cycles
  0 bytes consed

;; Now we have to calculate a speed of the
;; single operation:
POFTHEDAY&amp;gt; (/ 0.271
              1000000000)
2.71e-10&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I had to guess a number of iteration to get meaningful execution time and also did some arithmetics after that.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:benchmark
              (gethash :foo h)))
1.11d-8

;; You also can receive a human readable value:
POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:bench
              (gethash :foo h)))
11.36 nanoseconds&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here we see result 11 nanoseconds, however with &lt;code&gt;time&lt;/code&gt; macro we received only 0.271 nanoseconds. Probably this is because the overhead introduced by &lt;code&gt;the-cost-of-nothing&lt;/code&gt;. It tries to subtract overhead time from the result, but seems it does works for very fast operations.&lt;/p&gt;
&lt;p&gt;In case if you are measuring the cost of very fast operations it is better to make a loop even when using the-cost-of-nothing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (/ (the-cost-of-nothing:benchmark
                 (loop repeat 1000
                       do (gethash :foo h)))
                1000))
2.59d-10&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;How does &lt;code&gt;benchmark&lt;/code&gt; macro work?&lt;/p&gt;
&lt;p&gt;It has two parameters: &lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;min-sample-time&lt;/code&gt;. A tested form gets wrapped into the lambda function and executed in the loop a number of times to measure samples.&lt;/p&gt;
&lt;p&gt;On each iteration, the form is executed in another loop where the number of iterations is automatically tuned to make this inner loop run no less than &lt;code&gt;min-sample-time&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After that, an average overall sampled times is calculated and &lt;code&gt;overhead&lt;/code&gt; time is subtracted. Overhead time is precalculated as the cost of nil form execution.&lt;/p&gt;
&lt;p&gt;On my system, overhead value is 2.7e-9.&lt;/p&gt;
&lt;p&gt;I tried to rewrite the function which measures a sample&apos;s time to make the calculation fairer, but without significant result.&lt;/p&gt;
&lt;p&gt;Here is what I&apos;ve got:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defun sample-execution-time-of-thunk (thunk min-sample-time)
  &amp;quot;Measure the execution time of invoking THUNK more and more often, until
the execution time exceeds MIN-SAMPLE-TIME.&amp;quot;
  (declare (optimize (speed 3) (debug 1)))
  
  (loop with started-at of-type integer = (get-internal-run-time)
        with run-until of-type integer = (+ started-at
                                             (round (* min-sample-time
                                                       internal-time-units-per-second)))
        for iterations of-type integer = 1 then (* iterations 2)
        summing iterations into total-iterations
        do (loop repeat iterations
                 do (funcall thunk))
        when (&amp;gt;= (get-internal-run-time)
                 run-until)
          do (return (/ (- (get-internal-run-time)
                            started-at)
                        internal-time-units-per-second
                        total-iterations))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I removed a call to an additional function and to &lt;code&gt;local-time:timestamp-difference&lt;/code&gt;, but result is not much better - only 10.71 nanoseconds.&lt;/p&gt;
&lt;p&gt;Am I missing something? Maybe compiler does some optimizations, when it sees a gethash call in a loop which does not change the dict?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:bench
              (gethash :foo h)))
10.71 nanoseconds&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another interesting thing about &lt;code&gt;the-cost-of-nothing&lt;/code&gt; is that it includes a benchmark which measures some the cost of some common operations.&lt;/p&gt;
&lt;p&gt;Even if they are not precise, it is interesting to compare their relative values. Here are numbers received on my Macbook Pro.&lt;/p&gt;
&lt;p&gt;Pay attention to how does cost grow for calling the function with multiple keyword arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (asdf:test-system :the-cost-of-nothing)

= The Cost Of Nothing =
Implementation: SBCL 2.0.2
Machine: X86-64 Intel(R) Core(TM) i7-8750H CPU @ 2.20GHz
Hostname: art-2osx

== Memory Management ==
Cost of allocating a cons cell: 6.76 nanoseconds
Cost of garbage collection: 10.68 milliseconds
Cost of full garbage collection: 107.05 milliseconds

== Functions ==
FUNCALL with zero mandatory arguments: 2.71 nanoseconds
FUNCALL with one mandatory argument: 2.68 nanoseconds
FUNCALL with two mandatory arguments: 2.52 nanoseconds
FUNCALL with three mandatory arguments: 2.43 nanoseconds
FUNCALL with four mandatory arguments: 2.74 nanoseconds
FUNCALL with five mandatory arguments: 2.62 nanoseconds
FUNCALL with six mandatory arguments: 2.78 nanoseconds
FUNCALL with zero optional arguments: 2.71 nanoseconds
FUNCALL with one optional argument: 3.24 nanoseconds
FUNCALL with two optional arguments: 3.00 nanoseconds
FUNCALL with three optional arguments: 3.23 nanoseconds
FUNCALL with four optional arguments: 3.09 nanoseconds
FUNCALL with five optional arguments: 3.42 nanoseconds
FUNCALL with six optional arguments: 3.38 nanoseconds
FUNCALL with zero keyword arguments: 2.71 nanoseconds
FUNCALL with one keyword argument: 5.35 nanoseconds
FUNCALL with two keyword arguments: 5.76 nanoseconds
FUNCALL with three keyword arguments: 8.34 nanoseconds
FUNCALL with four keyword arguments: 12.45 nanoseconds
FUNCALL with five keyword arguments: 14.88 nanoseconds
FUNCALL with six keyword arguments: 17.58 nanoseconds
FUNCALL with zero rest arguments: 2.71 nanoseconds
FUNCALL with one rest argument: 2.65 nanoseconds
FUNCALL with two rest arguments: 2.53 nanoseconds
FUNCALL with three rest arguments: 2.48 nanoseconds
FUNCALL with four rest arguments: 2.79 nanoseconds
FUNCALL with five rest arguments: 2.91 nanoseconds
FUNCALL with six rest arguments: 2.66 nanoseconds

== Numerics ==
Flops (single-float): 4.25 gigaflops
Flops (double-float): 2.71 gigaflops&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I think it would be great to make this library to output some statistics about collected samples - a number of samples, standard deviation, like IPython does:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;python&apos;&gt;Python 3.7.7 (default, Mar 10 2020, 15:43:33)
Type &amp;#039;copyright&amp;#039;, &amp;#039;credits&amp;#039; or &amp;#039;license&amp;#039; for more information
IPython 7.14.0 -- An enhanced Interactive Python. Type &amp;#039;?&amp;#039; for help.

In [1]: d = {&amp;#039;what&amp;#039;: 42}

In [2]: %timeit d[&amp;#039;what&amp;#039;]
35.7 ns &amp;#xB1; 0.405 ns per loop (mean &amp;#xB1; std. dev. of 7 runs, 10000000 loops each)

In [3]:&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As @guicho271828 &lt;a href=&quot;https://twitter.com/guicho271828/status/1272616501187678209&quot;&gt;noted&lt;/a&gt;, SBCL is able to figure out that gethash&apos;s results aren&apos;t used in the loop and optimizes it away.&lt;/p&gt;
&lt;p&gt;I&apos;ve checked this hypothesis, and with &lt;code&gt;gethash&lt;/code&gt; wrapped with a function results of &quot;time&quot; macro and &quot;benchmark&quot; macro are the same:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun get-value (h)
             (gethash :foo h))

POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (time
              (loop repeat 1000000000
                    do (get-value h))))
Evaluation took:
  12.968 seconds of real time
  12.966402 seconds of total run time (12.958497 user, 0.007905 system)
  99.98% CPU
  28,634,122,802 processor cycles
  0 bytes consed
  
POFTHEDAY&amp;gt; (/ 12.968
              1000000000)
1.2968e-8

POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:benchmark
              (get-value h)))
1.1339696e-8

POFTHEDAY&amp;gt; (let ((h (make-hash-table)))
             (the-cost-of-nothing:benchmark
              (gethash :foo h)))
1.0396756e-8&lt;/code&gt;&lt;/pre&gt;</description>
            <pubDate>Mon, 15 Jun 2020 22:19:19 +0300</pubDate>
        </item>
        <item>
            <title>teddy</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0099-teddy.html</link>
            <description>&lt;p&gt;I always wanted to work from Common Lisp with data like we do in Python. That is how does Teddy born.&lt;/p&gt;
&lt;p&gt;Teddy make it possible to define a data frame full of data, to slice it in different ways, to join data frames, see some statistics about the data and render plots.&lt;/p&gt;
&lt;p&gt;This is a proof of the concept and API will be changed. Check the ChangeLog.md to learn about new abilities and refactoring details.&lt;/p&gt;
&lt;p&gt;Here is how we can create a simple data frame:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/data-frame:make-data-frame
            &amp;#039;(&amp;quot;Idx&amp;quot; &amp;quot;Integers&amp;quot; &amp;quot;Uniform floats&amp;quot; &amp;quot;Gaussian&amp;quot;)
            :rows
            (loop repeat 10
                  for idx upfrom 0
                  collect (list idx
                                (random 100)
                                (random 1.0)
                                (statistics:random-normal
                                 :mean 5.0
                                 :sd 0.2))))
+-----+----------+----------------+----------+
| Idx | Integers | Uniform floats | Gaussian |
+-----+----------+----------------+----------+
|   0 |       41 |           0.27 |   4.89d0 |
|   1 |       98 |           0.08 |   4.93d0 |
|   2 |        8 |           0.45 |   5.15d0 |
|   3 |       56 |           0.63 |   4.87d0 |
|   4 |       79 |           0.42 |   4.72d0 |
|   5 |       19 |           0.04 |   4.73d0 |
|   6 |        1 |           0.34 |   4.93d0 |
|   7 |       79 |           0.60 |   5.25d0 |
|   8 |       42 |           0.08 |   5.10d0 |
|   9 |        7 |           0.86 |   5.31d0 |
+-----+----------+----------------+----------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can slice it by columns, rows or both:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/data-frame:head *d* 2)
+-----+----------+----------------+----------+
| Idx | Integers | Uniform floats | Gaussian |
+-----+----------+----------------+----------+
|   0 |       41 |           0.27 |   4.89d0 |
|   1 |       98 |           0.08 |   4.93d0 |
+-----+----------+----------------+----------+
POFTHEDAY&amp;gt; (teddy/data-frame:tail *d* 2)
+-----+----------+----------------+----------+
| Idx | Integers | Uniform floats | Gaussian |
+-----+----------+----------------+----------+
|   8 |       42 |           0.08 |   5.10d0 |
|   9 |        7 |           0.86 |   5.31d0 |
+-----+----------+----------------+----------+
POFTHEDAY&amp;gt; (teddy/data-frame:slice
            *d*
            :columns &amp;#039;(&amp;quot;idx&amp;quot; &amp;quot;gaussian&amp;quot;))
+-----+----------+
| Idx | Gaussian |
+-----+----------+
|   0 |   4.89d0 |
|   1 |   4.93d0 |
|   2 |   5.15d0 |
|   3 |   4.87d0 |
|   4 |   4.72d0 |
|   5 |   4.73d0 |
|   6 |   4.93d0 |
|   7 |   5.25d0 |
|   8 |   5.10d0 |
|   9 |   5.31d0 |
+-----+----------+
POFTHEDAY&amp;gt; (teddy/data-frame:slice *d*
            :columns &amp;#039;(&amp;quot;idx&amp;quot; &amp;quot;gaussian&amp;quot;)
            :from 4
            :to 6)
+-----+----------+
| Idx | Gaussian |
+-----+----------+
|   4 |   4.72d0 |
|   5 |   4.73d0 |
+-----+----------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, we might want to see some descriptive statistical data about our data frame. This is pretty easy with Teddy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/stats:stats *d*)
+----------------+--------+--------+--------+--------+--------+-------+-------+---------+
| Column         | Min    | p25    | p50    | p75    | Max    | Mean  | SD    | Sum     |
+----------------+--------+--------+--------+--------+--------+-------+-------+---------+
| Idx            |      0 |      2 |   4.50 |      7 |      9 |  4.50 |  3.03 |      45 |
| Integers       |      1 |      8 |  41.50 |     79 |     98 | 43.00 | 34.40 |     430 |
| Uniform floats |   0.04 |   0.08 |   0.38 |   0.60 |   0.86 |  0.38 |  0.27 |    3.75 |
| Gaussian       | 4.72d0 | 4.87d0 | 4.93d0 | 5.15d0 | 5.31d0 |  4.99 |  0.20 | 49.88d0 |
+----------------+--------+--------+--------+--------+--------+-------+-------+---------+&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Probably, we can make some extandable protocol to calculate other properties.&lt;/p&gt;
&lt;p&gt;Data frame stores data as columns. Each column is a vector of a particular type. If you want to process a row, you can create an iterator and use it to go through rows like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (loop with iterator = (teddy/data-frame:make-iterator *d*)
                 for row = (funcall iterator)
                 while row
                 do (format t &amp;quot;Row: ~S~%&amp;quot;
                            row))
Row: (0 41 0.26806116 4.887522971759381d0)
Row: (1 98 0.081421256 4.928584134866222d0)
Row: (2 8 0.45165908 5.147222819038834d0)
Row: (3 56 0.62647486 4.874349648519968d0)
Row: (4 79 0.41671002 4.7239718274963485d0)
Row: (5 19 0.04152584 4.727268395019779d0)
Row: (6 1 0.3369373 4.93339303609316d0)
Row: (7 79 0.59791017 5.2466443304900965d0)
Row: (8 42 0.076958776 5.103448455243024d0)
Row: (9 7 0.85732913 5.310498824093041d0)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Plotting facilities as rudimentary, but should be improved.. All functions related to plotting are in the &lt;code&gt;teddy/plot&lt;/code&gt; package. Right now &lt;code&gt;GNUPlot&lt;/code&gt; is used via &lt;a href=&quot;http://quickdocs.org/eazy-gnuplot/&quot;&gt;eazy-gnuplot&lt;/a&gt; library.&lt;/p&gt;
&lt;p&gt;Here is how we can plot our data from all columns:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/plot:plot *d*
            &amp;quot;docs/media/0099/simple-plot.png&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0099/simple-plot.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;If we want to plot only gaussian, then it will be wrong, because we need a histogram type of plot. This feature is &quot;to be done&quot;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (teddy/plot:plot
            (teddy/data-frame:slice *d*
                                    :columns &amp;#039;(&amp;quot;Idx&amp;quot; &amp;quot;Gaussian&amp;quot;))
            &amp;quot;docs/media/0099/gaussian.png&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0099/gaussian.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Another type of plots &lt;code&gt;Teddy&lt;/code&gt; is able to render right now is a &quot;timeseries&quot;.&lt;/p&gt;
&lt;p&gt;Let&apos;s plot how does Moscow&apos;s population was changed over years:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *moscow-population*
             (teddy/data-frame:make-data-frame
              &amp;#039;(&amp;quot;Date&amp;quot; &amp;quot;Population&amp;quot;)
              :rows &amp;#039;((&amp;quot;1350-01-01&amp;quot; 30000)
                      (&amp;quot;1840-01-01&amp;quot; 349000)
                      (&amp;quot;1907-01-01&amp;quot; 1345700)
                      (&amp;quot;1967-01-01&amp;quot; 6422000)
                      (&amp;quot;1994-01-01&amp;quot; 9066000)
                      (&amp;quot;2010-01-01&amp;quot; 11500000)
                      (&amp;quot;2020-01-01&amp;quot; 12680000))))
*MOSCOW-POPULATION*
POFTHEDAY&amp;gt; (teddy/plot:plot-timeseries
            *moscow-population* &amp;quot;docs/media/0099/moscow2.png&amp;quot;
            :title &amp;quot;Moscow population&amp;quot;)
&amp;quot;docs/media/0099/moscow.png&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0099/moscow.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Right now, Teddy installable only from Ultralisp, because it is the best place to host unstable fast-changing Common Lisp libraries.&lt;/p&gt;
&lt;p&gt;Join the effort to make &lt;code&gt;Teddy&lt;/code&gt; really useful for data analysis!&lt;/p&gt;
&lt;p&gt;Send your pull-requests to:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/40ants/teddy&quot;&gt;https://github.com/40ants/teddy&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Sun, 14 Jun 2020 23:31:39 +0300</pubDate>
        </item>
        <item>
            <title>cl-store</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0098-cl-store.html</link>
            <description>&lt;p&gt;I use this library in a few of my projects. It is much like Python&apos;s &lt;a href=&quot;https://docs.python.org/3/library/pickle.html&quot;&gt;pickle module&lt;/a&gt;, but a lot more extensible.&lt;/p&gt;
&lt;p&gt;CL-Store is able to store and restore back almost any Lisp object. For example, &lt;code&gt;lfarm&lt;/code&gt;, &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0094-lfarm.html&quot;&gt;reviewed four days ago&lt;/a&gt; uses it to serialize and deserialize parameters when executing remote jobs on the server.&lt;/p&gt;
&lt;p&gt;To demonstrate how it works, I&apos;ll create a vector of objects. Then we&apos;ll save this vector to the file and restore it back:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ((name :initarg :name
                    :reader user-name)))

POFTHEDAY&amp;gt; (defmethod print-object ((user user) stream)
             (print-unreadable-object (user stream :type t)
               (format stream &amp;quot;~A&amp;quot;
                       (user-name user))))

POFTHEDAY&amp;gt; (defparameter *users*
             (make-array 2
                         :initial-contents
                         (list (make-instance &amp;#039;user :name &amp;quot;Bob&amp;quot;)
                               (make-instance &amp;#039;user :name &amp;quot;Alice&amp;quot;))))

POFTHEDAY&amp;gt; *users*
#(#&amp;lt;USER Bob&amp;gt; #&amp;lt;USER Alice&amp;gt;)

;; Now we are ready to store our data to the file
POFTHEDAY&amp;gt; (cl-store:store *users* #P&amp;quot;/tmp/users.bin&amp;quot;)

;; and to restore it back:
POFTHEDAY&amp;gt; (cl-store:restore #P&amp;quot;/tmp/users.bin&amp;quot;)
#(#&amp;lt;USER Bob&amp;gt; #&amp;lt;USER Alice&amp;gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the resulting file. Don&apos;t be deceived by the readable content. This is the binary format and it might contain nonreadable characters:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;text&apos;&gt;[art@poftheday] cat /tmp/users.bin
CLCL
#USER#  POFTHEDAY
#NAMEBobAlice&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CL-Store can be extended. Originally it also provided a backend to serialize data into the XML. But now this backend is considered as deprecated.&lt;/p&gt;
&lt;p&gt;Previously I didn&apos;t write backends for CL-Store, but today I found in its docs an example, &lt;a href=&quot;https://common-lisp.net/project/cl-store/docs/cl-store_5.html#SEC19&quot;&gt;how to write a backend&lt;/a&gt;, compatible with  Python&apos;s pickle.&lt;/p&gt;
&lt;p&gt;Documentation is 13 years old, let&apos;s see if we&apos;ll be able to reproduce it!&lt;/p&gt;
&lt;p&gt;First, we need to define a new backend:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-store:defbackend pickle
             :stream-type &amp;#039;character)
#&amp;lt;PICKLE {100369EBB3}&amp;gt;

;; This small call expands into this huge amount of code:

(eval-when (:load-toplevel :execute)
  (eval-when (:compile-toplevel :load-toplevel :execute)
    (defclass pickle (cl-store:backend) nil
              (:documentation
               &amp;quot;Autogenerated cl-store class for backend pickle.&amp;quot;))
    (defmacro defstore-pickle
              ((cl-store::var type stream &amp;amp;optional cl-store::qualifier)
               &amp;amp;body cl-store::body)
      (cl-store::with-gensyms (cl-store::gbackend)
        `(defmethod cl-store:internal-store-object ,@(if cl-store::qualifier
                                                         (list
                                                          cl-store::qualifier)
                                                         nil)
                    ((,cl-store::gbackend ,&amp;#039;pickle) (,cl-store::var ,type)
                     ,stream)
           ,(format nil &amp;quot;Definition for storing an object of type ~A with ~
 backend ~A&amp;quot;
                    type &amp;#039;pickle)
           (declare (ignorable ,cl-store::gbackend))
           ,@cl-store::body)))
    (defmacro defrestore-pickle
              ((type cl-store::place &amp;amp;optional cl-store::qualifier)
               &amp;amp;body cl-store::body)
      (cl-store::with-gensyms (cl-store::gbackend cl-store::gtype)
        `(defmethod cl-store::internal-restore-object ,@(if cl-store::qualifier
                                                            (list
                                                             cl-store::qualifier)
                                                            nil)
                    ((,cl-store::gbackend ,&amp;#039;pickle)
                     (,cl-store::gtype (eql &amp;#039;,type)) (,cl-store::place t))
           (declare (ignorable ,cl-store::gbackend ,cl-store::gtype))
           ,@cl-store::body))))
  (cl-store::register-backend &amp;#039;pickle &amp;#039;pickle nil &amp;#039;character &amp;#039;nil &amp;#039;nil))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use &lt;code&gt;defstore-pickle&lt;/code&gt; and &lt;code&gt;defrestore-pickle&lt;/code&gt; macroses to define rules for the processing of different data types.&lt;/p&gt;
&lt;p&gt;Here is where all real work is done:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *pickle-mapping*
             &amp;#039;((#\S . string))
             &amp;quot;A mapping from Pickle&amp;#039;s char codes
              to a Lisp data type&amp;quot;)

POFTHEDAY&amp;gt; (defmethod cl-store:get-next-reader ((backend pickle) (stream stream))
             &amp;quot;This method is responsible for recognizing what
              type of object should be read next.&amp;quot;
             (let ((type-code (read-char stream)))
               (or (cdr (assoc type-code *pickle-mapping*))
                   (values nil (format nil &amp;quot;Type ~A&amp;quot; type-code)))))

POFTHEDAY&amp;gt; (defrestore-pickle (noop stream)
             &amp;quot;We&amp;#039;ll skip unknown objects&amp;quot;)

POFTHEDAY&amp;gt; (defstore-pickle (obj string stream)
             &amp;quot;Here is how string should be written in Pickle&amp;#039;s format.&amp;quot;
             (format stream &amp;quot;S&amp;#039;~A&amp;#039;~%p0~%.&amp;quot; obj))

POFTHEDAY&amp;gt; (defrestore-pickle (string stream)
             &amp;quot;And this is a code to read string back&amp;quot;
             (let ((val (read-line stream)))
               (read-line stream) ;; remove the PUSH op
               (read-line stream) ;; remove the END op
               (subseq val 1 (1- (length val)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is time to test our functions. To make this old example work, I had to use old Python2.7, because Python3&apos;s pickle serializes into a little bit different format.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;python&apos;&gt;[art@poftheday] python2.7

&amp;gt;&amp;gt;&amp;gt; with open(&amp;#039;/tmp/word.pickle&amp;#039;, &amp;#039;w&amp;#039;) as f:
...     pickle.dump(&amp;#039;Hello Lisp World!&amp;#039;, f, protocol=0)
...
&amp;gt;&amp;gt;&amp;gt; ^D

[art@poftheday] cat /tmp/word.pickle
S&amp;#039;Hello Lisp World!&amp;#039;
p0
.

# Here is what I&amp;#039;ve got under Python3:

In [9]: with open(&amp;#039;/tmp/word.pickle&amp;#039;, &amp;#039;bw&amp;#039;) as f:
   ...:     pickle.dump(&amp;#039;Hello Lisp World!&amp;#039;, f, protocol=0)
   ...:

In [10]: !cat /tmp/word.pickle
VHello Lisp World!
p0
.
# This cl-store backend does not support V type code.
# Seems, it stands for a Unicode string.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can read this file from Lisp and write it back:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-store:restore #P&amp;quot;/tmp/word.pickle&amp;quot;
                             &amp;#039;pickle)
&amp;quot;Hello Lisp World!&amp;quot;

POFTHEDAY&amp;gt; (cl-store:store &amp;quot;Howdy, Python!&amp;quot;
                           #P&amp;quot;/tmp/word.pickle&amp;quot;
                           &amp;#039;pickle)
&amp;quot;Howdy, Python!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally, to ensure our backend works as expected, we&apos;ll read this response in Python2:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;python&apos;&gt;&amp;gt;&amp;gt;&amp;gt; import pickle
&amp;gt;&amp;gt;&amp;gt; with open(&amp;#039;/tmp/word.pickle&amp;#039;) as f:
...     pickle.load(f)
...
&amp;#039;Howdy, Python!&amp;#039;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. If you need a time-proved serialization library, check out the CL-Store! To extend it, just read the &lt;a href=&quot;https://common-lisp.net/project/cl-store/docs/cl-store.html&quot;&gt;docs&lt;/a&gt;.&lt;/p&gt;
</description>
            <pubDate>Sat, 13 Jun 2020 23:53:16 +0300</pubDate>
        </item>
        <item>
            <title>sblint</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0097-sblint.html</link>
            <description>&lt;p&gt;Today I want to review not a library but a tool. &lt;code&gt;SBLint&lt;/code&gt; is a program, which can be run from the command-line. It loads your lisp code and outputs all warnings and notes from SBCL compiler.&lt;/p&gt;
&lt;p&gt;I must admit, that SBLint&apos;s output is very readable. You&apos;ll see where you left unused variables or called a function with wrong parameters.&lt;/p&gt;
&lt;p&gt;To show you an example, I&apos;ve added this bad code to one of my libraries:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(declaim (ftype (function (fixnum fixnum)
                          fixnum)
                foo))
(defun foo (a b)
  (+ a 10))


(defun bar ()
  (foo))


(defun blah ()
  (foo 2
       3.14))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This code is full of problems :) Let&apos;s see how SBLint will highlight them!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[art@poftheday] sblint
src/appenders.lisp:41:0: style-warning: \
    The variable B is defined but never used.
src/appenders.lisp:46:2: simple-warning: \
    The function FOO is called with zero arguments, but wants exactly two.
src/appenders.lisp:50:2: type-warning: \
    Constant 3.14 conflicts with its asserted type FIXNUM.
WARNING: Compilation failed in a system &amp;quot;log4cl-extras&amp;quot;.

# But return code is still SUCCESS:
[art@poftheday] echo $?
0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, all errors are caught. However, &lt;code&gt;SBLint&lt;/code&gt; itself exited with 0 exit code. Because of this, we can&apos;t add it into our CI pipeline.&lt;/p&gt;
&lt;p&gt;I consider this is a bug and will made a pull-request to fix it. Hopefully, the current maintainer will merge it soon:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/cxxxr/sblint/pull/19&quot;&gt;https://github.com/cxxxr/sblint/pull/19&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Fri, 12 Jun 2020 23:43:40 +0300</pubDate>
        </item>
        <item>
            <title>cl-reddit</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0096-cl-reddit.html</link>
            <description>&lt;p&gt;This is an API wrapper for Reddit.&lt;/p&gt;
&lt;p&gt;Today I found &lt;a href=&quot;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&quot;&gt;an interesting thread from SpaceX&lt;/a&gt;, where it&apos;s software developers answer the questions. I wondered if there was a discussion around Lisp in the Space?&lt;/p&gt;
&lt;p&gt;But this post has about 8000 comments and I didn&apos;t found a search in a single post&apos;s comments on the Reddit. So, I decided to use &lt;code&gt;cl-reddit&lt;/code&gt; to fetch all post comments and to search through them a &quot;lisp&quot; term.&lt;/p&gt;
&lt;p&gt;Here is how you can connect to the Reddit and list of your subreddits:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *user*
             (cl-reddit:api-login
              :username &amp;quot;svetlyak40wt&amp;quot;
              :password *password*))

;; This is how we can retrieve a list of my subreddits:

POFTHEDAY&amp;gt; (mapcar #&amp;#039;cl-reddit:subreddit-title
                   (cl-reddit::get-reddits-mine *user*))
(&amp;quot;programming&amp;quot; &amp;quot;Lisp Advocates&amp;quot; &amp;quot;Lisp&amp;quot; &amp;quot;Scheme Programming Language articles&amp;quot;
 &amp;quot;M-x emacs-reddit&amp;quot; &amp;quot;Web Startups&amp;quot; &amp;quot;Common Lisp&amp;quot; &amp;quot;Filmmakers&amp;quot; &amp;quot;coding&amp;quot;
 &amp;quot;Github: social coding&amp;quot; &amp;quot;EarthPorn: Amazing images of light and landscape&amp;quot;
 &amp;quot;LISP ja&amp;quot; &amp;quot;Learn Lisp&amp;quot; &amp;quot;Startup Accelerators&amp;quot; &amp;quot;defunkydrummer&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot;
 &amp;quot;Steel Bank Common Lisp&amp;quot;
 &amp;quot;(find-if (alexandria:conjoin #&amp;#039;funny-p #&amp;#039;about-lisp-p) *reddit*)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But we want to run a search in the post comments, right?&lt;/p&gt;
&lt;p&gt;Then we need to extract post id from this link:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&quot;&gt;https://www.reddit.com/r/spacex/comments/gxb7j1/we_are_the_spacex_software_team_ask_us_anything/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;and to fetch comments tree using &lt;code&gt;cl-reddit&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-reddit::get-comments &amp;quot;gxb7j1&amp;quot; *user*)

(#&amp;lt;CL-REDDIT:COMMENT {1002009693}&amp;gt; #&amp;lt;CL-REDDIT:COMMENT {10020098F3}&amp;gt;
 #&amp;lt;CL-REDDIT:COMMENT {1002016BF3}&amp;gt; #&amp;lt;CL-REDDIT:COMMENT {1002016CB3}&amp;gt;
 ...
 #&amp;lt;CL-REDDIT:COMMENT {1002016D73}&amp;gt; #&amp;lt;CL-REDDIT:MORE {1002016E33}&amp;gt;)

POFTHEDAY&amp;gt; (length *)
151&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Well, we received 151 comments, but real comments count is about 7.7k. This is because other items either replies or &lt;code&gt;CL-REDDIT:MORE&lt;/code&gt; objects which contain ids of the replies:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;&apos;&gt;POFTHEDAY&amp;gt; (defparameter *comments*
              (cl-reddit::get-comments &amp;quot;gxb7j1&amp;quot; *user*))

POFTHEDAY&amp;gt; (rutils:last-elt *comments*)
#&amp;lt;CL-REDDIT:MORE {1002016E33}&amp;gt;

POFTHEDAY&amp;gt; (cl-reddit:more-children *)
(&amp;quot;ft35r7m&amp;quot; &amp;quot;ft0rpxi&amp;quot; &amp;quot;ft0jn61&amp;quot; &amp;quot;ft34002&amp;quot; &amp;quot;ft4b6z4&amp;quot;
 ...
 &amp;quot;ft0pado&amp;quot; ...)

POFTHEDAY&amp;gt; (cl-reddit:comment-replies
               (first *comments*))
(#&amp;lt;CL-REDDIT:MORE {1003607093}&amp;gt;)

POFTHEDAY&amp;gt; (cl-reddit:comment-replies
               (second *comments*))
(#&amp;lt;CL-REDDIT:COMMENT {1007607293}&amp;gt;)

POFTHEDAY&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We need to write a comment walker which &lt;code&gt;cl-reddit&lt;/code&gt; does not provide.&lt;/p&gt;
&lt;p&gt;This walker will expand all &lt;code&gt;MORE&lt;/code&gt; items and collect comments into the flat list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((post-id &amp;quot;gxb7j1&amp;quot;))
             (uiop:while-collecting (collect)
               (labels ((visit (item)
                          (etypecase item
                            (cl-reddit:comment
                             (collect item)
                             (mapc #&amp;#039;visit
                                   (cl-reddit:comment-replies
                                    item)))
                            (cl-reddit:more
                             (expand-more item))))
                        (expand-more (more)
                          (loop for id in (cl-reddit:more-children more)
                                for comments = (cl-reddit::get-comments
                                                post-id
                                                *user*
                                                :comment id)
                                do (mapc #&amp;#039;visit
                                         comments))))
                 (mapcar #&amp;#039;visit
                         (cl-reddit::get-comments post-id
                                                  *user*)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When I started this code the first time, it broke my Lisp. A quick investigation showed a resource leak. This library uses &lt;a href=&quot;https://edicl.github.io/drakma/&quot;&gt;Drakma&lt;/a&gt; for data fetching and instead of receiving response bodies, request a stream.&lt;/p&gt;
&lt;p&gt;Drakma&apos;s documentation says, that you might need to close the stream. If you don&apos;t - a connection to the server remains opene.&lt;/p&gt;
&lt;p&gt;Seems, the library&apos;s author never used it for making thousands of requests.&lt;/p&gt;
&lt;p&gt;I&apos;ve fixed this leak, but comments fetching still was too slow - about 2 comments per second. This is because &lt;code&gt;MORE&lt;/code&gt; item contains comment ids and I have to fetch them individually one by one.&lt;/p&gt;
&lt;p&gt;I tried to parallelize the fetching process using lparallel, reviewed two days ago:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *all-comments*
             (let ((post-id &amp;quot;gxb7j1&amp;quot;)
                 (counter 0))
               (uiop:while-collecting (collect)
                 (labels ((visit (item)
                            (etypecase item
                              (cl-reddit:comment
                               (collect item)
                               (incf counter)
                               (when (zerop (mod counter 10))
                                 (log:info &amp;quot;~A comments collected&amp;quot;
                                           counter))
                               (mapc #&amp;#039;visit (cl-reddit:comment-replies item)))
                              (cl-reddit:more
                               (expand-more item))))
                          (expand-more (more)
                            (log:info &amp;quot;Expanding&amp;quot; more)
                            (loop with more-ids = (cl-reddit:more-children more)
                                  with replies = (lparallel:pmapcar
                                                  (lambda (id)
                                                    (cl-reddit::get-comments
                                                     post-id
                                                     *user*
                                                     :comment id))
                                                  more-ids)
                                  for comments in replies
                                  do (lparallel:pmapc #&amp;#039;visit comments))))
                   (lparallel:pmapc #&amp;#039;visit
                           (cl-reddit::get-comments post-id
                                                    *user*))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But encountered these strange errors:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;The condition Socket error in &amp;quot;connect&amp;quot;: EINTR (Interrupted system call) occurred with errno: 0.

Condition USOCKET:TIMEOUT-ERROR was signalled.
   [Condition of type USOCKET:TIMEOUT-ERROR]

Restarts:
 0: [TRANSFER-ERROR] Transfer this error to a dependent thread, if one exists.
 1: [KILL-ERRORS] Kill errors in workers (remove debugger instances).
 2: [ABORT] abort thread (#&amp;lt;THREAD &amp;quot;lparallel&amp;quot; RUNNING {10071B3DE3}&amp;gt;)

Backtrace:
 0: (USOCKET::HANDLE-CONDITION #&amp;lt;SB-EXT:TIMEOUT {10059E7C53}&amp;gt; #&amp;lt;USOCKET:STREAM-USOCKET {100871AB43}&amp;gt; &amp;quot;www.reddit.com&amp;quot;)
 1: (SB-KERNEL::%SIGNAL #&amp;lt;SB-EXT:TIMEOUT {10059E7C53}&amp;gt;)
 2: (ERROR SB-EXT:TIMEOUT)
 3: (USOCKET:SOCKET-CONNECT &amp;quot;www.reddit.com&amp;quot; 80 :PROTOCOL :STREAM :ELEMENT-TYPE FLEXI-STREAMS:OCTET :TIMEOUT 20 :DEADLINE NIL :NODELAY :IF-SUPPORTED :LOCAL-HOST NIL :LOCAL-PORT NIL)
 4: (DRAKMA:HTTP-REQUEST #&amp;lt;PURI:URI http://www.reddit.com/comments/gxb7j1.json?comment=ft3odzl&amp;gt; :METHOD :GET :USER-AGENT &amp;quot;cl-reddit/0.2 (common lisp api wrapper)&amp;quot; :COOKIE-JAR #&amp;lt;DRAKMA:COOKIE-JAR (with 5 c..
 5: (CL-REDDIT::GET-JSON &amp;quot;http://www.reddit.com/comments/gxb7j1.json?comment=ft3odzl&amp;quot; #&amp;lt;CL-REDDIT:USER {10079B9973}&amp;gt;)
 6: (CL-REDDIT:GET-COMMENTS &amp;quot;gxb7j1&amp;quot; #&amp;lt;CL-REDDIT:USER {10079B9973}&amp;gt; :ARTICLE NIL :COMMENT &amp;quot;ft3odzl&amp;quot; :CONTEXT NIL :DEPTH NIL :LIMIT NIL :SORT NIL :THREADED NIL :SHOWMORE NIL)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tried to switch to the Dexador instead of Drakma, but found another bug - it is not able to work in multiple threads:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/fukamachi/dexador/issues/88&quot;&gt;https://github.com/fukamachi/dexador/issues/88&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So, we&apos;ll never know if SpaceX developers are using Lisp in their space ships :)&lt;/p&gt;
</description>
            <pubDate>Thu, 11 Jun 2020 23:45:15 +0300</pubDate>
        </item>
        <item>
            <title>cl-gearman</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0095-cl-gearman.html</link>
            <description>&lt;p&gt;Yesterday, we &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0094-lfarm.html&quot;&gt;talked about&lt;/a&gt; distributing jobs across a cluster using &lt;code&gt;lfarm&lt;/code&gt;. &lt;code&gt;lfarm&lt;/code&gt; is not well suited to environments where worker hosts can go down and return back later.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://gearman.org/&quot;&gt;Gearman&lt;/a&gt; is the RPC server. Multiple workers can connect to this server and advertise which functions they are supporting. A client can call these functions and receive a result.&lt;/p&gt;
&lt;p&gt;Here is the diagram showing how does it work in the common case:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0095/gearman-cluster.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;A cool feature of Gearman is its language independence. Workers can be written in any language. This means that in your distributed system some functions can be written in Lisp, others in Python or even in Bash and some UNIX tools.&lt;/p&gt;
&lt;p&gt;Now we&apos;ll see how to write a simple worker in Common Lisp and call it. But first, let&apos;s start Gearman server in the Docker container:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[art@poftheday:~]% docker run --rm -p 4730:4730 artefactual/gearmand:1.1.19.1-alpine
Unable to find image &amp;#039;artefactual/gearmand:1.1.19.1-alpine&amp;#039; locally
1.1.19.1-alpine: Pulling from artefactual/gearmand
cbdbe7a5bc2a: Pull complete
33291983401c: Pull complete
b4a2ffd9f406: Pull complete
c5f0c79c81bd: Pull complete
c3b95f315fd4: Pull complete
e8fb3c47a5c3: Pull complete
Digest: sha256:585921f3509b86a9e78aac6c3512c894e0f0a8e0497d194483bafc5ebc275edc
Status: Downloaded newer image for artefactual/gearmand:1.1.19.1-alpine
   INFO 2020-06-10 13:34:35.722249 [  main ] Initializing Gear on port 4730 with SSL: false
   INFO 2020-06-10 13:34:35.000000 [  main ] Starting up with pid 1, verbose is set to INFO
   INFO 2020-06-10 13:34:35.000000 [  main ] Listening on 0.0.0.0:4730 (9)
   INFO 2020-06-10 13:34:35.000000 [  main ] Adding event for listening socket (9)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next, we need to start a simple worker which supports two functions. It can reverse any string and report about it&apos;s Lisp implementation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-gearman:with-worker (worker &amp;quot;localhost:4730&amp;quot;)
             (cl-gearman:add-ability worker &amp;quot;get-implementation&amp;quot;
                                     (lambda (arg job)
                                       (declare (ignorable arg job))
                                       (format nil &amp;quot;~A ~A&amp;quot;
                                               (lisp-implementation-type)
                                               (lisp-implementation-version))))
             (cl-gearman:add-ability worker &amp;quot;reverse&amp;quot;
                                     (lambda (arg job)
                                       (declare (ignorable job))
                                       (reverse arg)))
             (loop (cl-gearman:work worker)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is how we can call these functions from the console:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[art@poftheday:~]% echo &amp;#039;Hello Lisp World!&amp;#039; | gearman -f reverse
!dlroW psiL olleH

[art@poftheday:~]% echo &amp;#039;&amp;#039; | gearman -f get-implementation
SBCL 2.0.2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This way you can communicate with the Lisp from the outer world.&lt;/p&gt;
&lt;p&gt;If we want to call these functions from other Lisp program, then we can do it like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;OTHER-LISP&amp;gt; (cl-gearman:with-client (client &amp;quot;localhost:4730&amp;quot;)
              (format t &amp;quot;~A&amp;quot;
                      (cl-gearman:submit-job client &amp;quot;reverse&amp;quot;
                                             :arg &amp;quot;Hello Lisp World!&amp;quot;)))
!dlroW psiL olleH

OTHER-LISP&amp;gt; (cl-gearman:with-client (client &amp;quot;localhost:4730&amp;quot;)
              (format t &amp;quot;~A&amp;quot;
                      (cl-gearman:submit-job client &amp;quot;get-implementation&amp;quot;)))
SBCL 2.0.2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Gearman uses a very simple protocol. Every function accepts only one string as its argument. If you want to pass something complex, you&apos;ll need to use some sort of serialization.&lt;/p&gt;
&lt;p&gt;For example, here is how I use &lt;code&gt;cl-store&lt;/code&gt; and &lt;code&gt;base64&lt;/code&gt; to pass lisp data-structures between a worker and a client in Ultralisp.org:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ultralisp/ultralisp/blob/f52411bd89dc5b0bcb6701e4ba0712dd5aee128b/src/rpc/core.lisp#L23-L47&quot;&gt;https://github.com/ultralisp/ultralisp/blob/f52411bd89dc5b0bcb6701e4ba0712dd5aee128b/src/rpc/core.lisp#L23-L47&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;That is it for today. Play with both &lt;code&gt;lfarm&lt;/code&gt; and &lt;code&gt;cl-gearman&lt;/code&gt; to decide which one is better suited for your task.&lt;/p&gt;
</description>
            <pubDate>Wed, 10 Jun 2020 21:28:59 +0300</pubDate>
        </item>
        <item>
            <title>lfarm</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0094-lfarm.html</link>
            <description>&lt;p&gt;This library is similar to Python&apos;s multiprocessing which is also &lt;a href=&quot;https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing.connection&quot;&gt;able to run processes on different hosts&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Use &lt;code&gt;lfarm&lt;/code&gt; when you need to run jobs on the cluster.&lt;/p&gt;
&lt;p&gt;The cool &lt;code&gt;lfarm&lt;/code&gt;&apos;s feature is the ability to run jobs on workers, running on different Common Lisp implementation.&lt;/p&gt;
&lt;p&gt;To demonstrate how it works, I started a LispWorks Personal edition on my laptop and SBCL with ClozureCL in the Docker containers.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(ql:quickload :lfarm-server)

;; This how I started it on LispWorks
(lfarm-server:start-server &amp;quot;127.0.0.1&amp;quot; 10003)

;; inside the Docker:
(lfarm-server:start-server &amp;quot;0.0.0.0&amp;quot; 10000)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After that, I created a workers pool in my SBCL REPL and called &lt;code&gt;broadcast-task&lt;/code&gt; to run a function on every worker:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (setf lfarm:*kernel* (lfarm:make-kernel &amp;#039;((&amp;quot;127.0.0.1&amp;quot; 10001)
                                                     (&amp;quot;127.0.0.1&amp;quot; 10002)
                                                     (&amp;quot;127.0.0.1&amp;quot; 10003))))
#&amp;lt;LFARM-CLIENT.KERNEL:KERNEL :WORKER-COUNT 3 {1004E7C7C3}&amp;gt;

POFTHEDAY&amp;gt; (lfarm:broadcast-task
            (lambda ()
              (list :lisp (lisp-implementation-type)
                    :lisp-version (lisp-implementation-version)
                    :system (string-trim
                             (list #\Newline #\Space)
                             (with-output-to-string (s)
                               (uiop:run-program &amp;quot;uname -s -m -n&amp;quot;
                                                 :output s))))))
#((:LISP &amp;quot;LispWorks Personal Edition&amp;quot;
   :LISP-VERSION &amp;quot;7.1.2&amp;quot;
   :SYSTEM &amp;quot;Darwin lispbook x86_64&amp;quot;)
  (:LISP &amp;quot;SBCL&amp;quot;
   :LISP-VERSION &amp;quot;1.5.6&amp;quot;
   :SYSTEM &amp;quot;Linux 5d4cc1b96f7e x86_64&amp;quot;)
  (:LISP &amp;quot;Clozure Common Lisp&amp;quot;
   :LISP-VERSION &amp;quot;Version 1.11.5/v1.11.5  (LinuxX8664)&amp;quot;
   :SYSTEM &amp;quot;Linux d2c83144fce3 x86_64&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another great feature is API compatibility with &lt;code&gt;lparallel&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/06/0093-lparallel.html&quot;&gt;reviewed yesterday&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I took our yesterday code and modified it to be able to distinguish a machine processed a task:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lfarm:pmapcar
            (lambda (idx)
              (loop for iteration from 1 to 10
                    do (format t &amp;quot;~A task is processing ~A iteration~%&amp;quot;
                               idx iteration)
                       (sleep (random 1.0))
                    finally (return (format nil &amp;quot;~A result processed by ~A&amp;quot;
                                            idx
                                            (lisp-implementation-type)))))
              (alexandria:iota 10))
(&amp;quot;0 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;1 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;2 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;3 result processed by Clozure Common Lisp&amp;quot;
 &amp;quot;4 result processed by SBCL&amp;quot;
 &amp;quot;5 result processed by SBCL&amp;quot;
 &amp;quot;6 result processed by SBCL&amp;quot;
 &amp;quot;7 result processed by LispWorks Personal Edition&amp;quot;
 &amp;quot;8 result processed by LispWorks Personal Edition&amp;quot;
 &amp;quot;9 result processed by LispWorks Personal Edition&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The bad news is that &lt;code&gt;lfarm&lt;/code&gt; is not suite well to the cloud environment, where workers can disappear at any time and become available later.&lt;/p&gt;
&lt;p&gt;Some time ago, I tried to use &lt;code&gt;lfarm&lt;/code&gt; in Ultralisp, to run some jobs in separate containers, but found that &lt;code&gt;lfarm&lt;/code&gt; does not like when worker process disconnects.&lt;/p&gt;
&lt;p&gt;For example, if some of the workers aren&apos;t running, &lt;code&gt;make-kernel&lt;/code&gt; will hang forever. Or if some of the workers will go offline, then &lt;code&gt;broadcast-task&lt;/code&gt; also will hang.&lt;/p&gt;
&lt;p&gt;Tomorrow I&apos;ll tell you about another solution which helped me to solve this problem.&lt;/p&gt;
</description>
            <pubDate>Tue, 09 Jun 2020 21:06:00 +0300</pubDate>
        </item>
    </channel>
</rss>