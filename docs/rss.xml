<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>scriptl</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0144-scriptl.html</link>
            <description>&lt;p&gt;This system implements a very interesting idea. It makes it very easy to call any lisp function from the command line.&lt;/p&gt;
&lt;p&gt;The cool part of this story is the ability to quickly hack on your functions in the Emacs while calling them from the command line. This can be especially useful in many cases like writing a plugin for &lt;a href=&quot;https://getbitbar.com/&quot;&gt;the BitBar&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ScriptL&lt;/code&gt; consists of three parts:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;a server, running in your lisp image&lt;/li&gt;&lt;li&gt;a client binary for passing parameters to the server and returning   results&lt;/li&gt;&lt;li&gt;a thin wrapper for each command.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Here is a minimal example to show you how it works.&lt;/p&gt;
&lt;p&gt;The first command starts the server. Second, defines the usual function and third creates a shell script &quot;hello-world&quot; in the current directory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (scriptl:start)

POFTHEDAY&amp;gt; (defun hello-world (&amp;amp;optional (name &amp;quot;Anonymous&amp;quot;))
             (format t &amp;quot;Hello, ~A!~%&amp;quot; name))

POFTHEDAY&amp;gt; (scriptl:make-script &amp;quot;hello-world&amp;quot;
                                &amp;#039;hello-world)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s switch to the command line and call our function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[poftheday] ./hello-world
Hello, Anonymous!

[poftheday] ./hello-world Bob
Hello, Bob!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how the wrapper looks like under the hood:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;text&apos;&gt;[poftheday] cat hello-world
#!/bin/sh
SCRIPTLCOM=&amp;quot;./.qlot/dists/quicklisp/software/
            scriptl-20180228-git/src/scriptlcom/src/scriptlcom&amp;quot;
FUNCTION=&amp;quot;POFTHEDAY::HELLO-WORLD&amp;quot;
ERRORS=&amp;quot;COMMON-LISP::NIL&amp;quot;
SYSTEM=&amp;quot;&amp;quot;

$SCRIPTLCOM --sl-version 2 -E &amp;quot;$ERRORS&amp;quot; -l &amp;quot;$SYSTEM&amp;quot; -f &amp;quot;$FUNCTION&amp;quot; -- &amp;quot;$@&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, it calls &lt;code&gt;scriptlcom&lt;/code&gt; binary, written in C.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;ScriptL&lt;/code&gt; server can also be started on a remote machine, but the documentation does not cover this setup.&lt;/p&gt;
&lt;p&gt;Playing with this system I recall where I seen a similar way of calling the server from the command line. It is possible with &lt;code&gt;CL-Gearman&lt;/code&gt;, reviewed in &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0095-cl-gearman.html&quot;&gt;post number 0095&lt;/a&gt;. Gearman has a command-line client but, is more suitable for server-server communication.&lt;/p&gt;
</description>
            <pubDate>Tue, 28 Jul 2020 20:40:04 +0300</pubDate>
        </item>
        <item>
            <title>cl-html-diff</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0143-cl-html-diff.html</link>
            <description>&lt;p&gt;Yesterday I&apos;ve reviewed the &lt;code&gt;cl-difflib&lt;/code&gt; and today I want to show you a library which uses &lt;code&gt;cl-difflib&lt;/code&gt; to compare HTML files. It parses both HTML&apos;s into nodes and compares these node lists:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (html-diff:html-diff
            &amp;quot;
&amp;lt;p&amp;gt;This is the HTML &amp;lt;b&amp;gt;Hello World&amp;lt;/b&amp;gt;:&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second iem&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;quot;
            &amp;quot;
&amp;lt;p&amp;gt;This is the HTML &amp;lt;i&amp;gt;Hello World&amp;lt;/i&amp;gt;:&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;quot;)

;; Result
&amp;quot;
&amp;lt;p&amp;gt;This is the HTML &amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;b&amp;gt;&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;i&amp;gt;&amp;lt;/ins&amp;gt;Hello World&amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/ins&amp;gt;:&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second &amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;iem&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;item&amp;lt;/ins&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;quot;
4 ;; don&amp;#039;t touched nodes
3 ;; replaced nodes
0 ;; inserted nodes
0 ;; deleted nodes&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the result rendered by the browser:&lt;/p&gt;
&lt;h4&gt;Code&lt;/h4&gt;&lt;pre&gt;&lt;code class=&apos;html :render&apos;&gt;&amp;lt;p&amp;gt;This is the HTML &amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;b&amp;gt;&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;i&amp;gt;&amp;lt;/ins&amp;gt;Hello World&amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/ins&amp;gt;:&amp;lt;/p&amp;gt;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second &amp;lt;del class=\&amp;quot;diff\&amp;quot;&amp;gt;iem&amp;lt;/del&amp;gt;&amp;lt;ins class=\&amp;quot;diff\&amp;quot;&amp;gt;item&amp;lt;/ins&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4&gt;Result&lt;/h4&gt;&lt;p&gt;This is the HTML &lt;del class=\&quot;diff\&quot;&gt;&lt;b&gt;&lt;/del&gt;&lt;ins class=\&quot;diff\&quot;&gt;&lt;i&gt;&lt;/ins&gt;Hello World&lt;del class=\&quot;diff\&quot;&gt;&lt;/b&gt;&lt;/del&gt;&lt;ins class=\&quot;diff\&quot;&gt;&lt;/i&gt;&lt;/ins&gt;:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;First item&lt;/li&gt;
  &lt;li&gt;Second &lt;del class=\&quot;diff\&quot;&gt;iem&lt;/del&gt;&lt;ins class=\&quot;diff\&quot;&gt;item&lt;/ins&gt;&lt;/li&gt;
  &lt;li&gt;Third item&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;You can see how it highlighted the fixed typo in the &lt;code&gt;item&lt;/code&gt; word, but wasn&apos;t able to figure out how to process changed tag around &quot;Hello World&quot; :(&lt;/p&gt;
&lt;p&gt;Such a library can be used to compare HTML documents rendered by some markup engined. For example, &lt;code&gt;cl-markdown&lt;/code&gt; uses it in its test suite, to compare results produced by CL engine and original Perl version of Markdown.&lt;/p&gt;
</description>
            <pubDate>Tue, 28 Jul 2020 20:15:44 +0300</pubDate>
        </item>
        <item>
            <title>cl-difflib</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0142-cl-difflib.html</link>
            <description>&lt;p&gt;This library is able to compute differences between sequences. For example, if we want to generate a unified diff for two lists of strings, we can do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (difflib:unified-diff
            t
            &amp;#039;(&amp;quot;one&amp;quot; &amp;quot;two&amp;quot; &amp;quot;three&amp;quot; &amp;quot;four&amp;quot; &amp;quot;five&amp;quot; &amp;quot;six&amp;quot;)
            &amp;#039;(&amp;quot;one&amp;quot; &amp;quot;three&amp;quot; &amp;quot;four&amp;quot; &amp;quot;seven&amp;quot; &amp;quot;eight&amp;quot;)
            :test-function &amp;#039;equal)

---  
+++  
@@ -1,6 +1,5 @@
 one
-two
 three
 four
-five
-six
+seven
+eight&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is also possible to provide filenames:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (difflib:unified-diff
            t
            &amp;#039;(&amp;quot;one&amp;quot; &amp;quot;two&amp;quot; &amp;quot;three&amp;quot; &amp;quot;four&amp;quot; &amp;quot;five&amp;quot; &amp;quot;six&amp;quot;)
            &amp;#039;(&amp;quot;one&amp;quot; &amp;quot;three&amp;quot; &amp;quot;four&amp;quot; &amp;quot;seven&amp;quot; &amp;quot;eight&amp;quot;)
            :test-function &amp;#039;equal
            :from-file &amp;quot;a.txt&amp;quot;
            :to-file &amp;quot;b.txt&amp;quot;)

--- a.txt 
+++ b.txt 
@@ -1,6 +1,5 @@
 one
-two
 three
 four
-five
-six
+seven
+eight&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a lower-level API. We can make a diff of any objects. Here is an example of how to get a diff of two lists of symbols:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *diff*
             (make-instance &amp;#039;difflib:sequence-matcher
                            :a &amp;#039;(:one :two :three :four :five :six)
                            :b &amp;#039;(:one :three :four :seven :eight)))

POFTHEDAY&amp;gt; (difflib:get-opcodes *diff*)
(#&amp;lt;DIFFLIB:OPCODE :EQUAL   0 1 0 1&amp;gt;
 #&amp;lt;DIFFLIB:OPCODE :DELETE  1 2 1 1&amp;gt;
 #&amp;lt;DIFFLIB:OPCODE :EQUAL   2 4 1 3&amp;gt;
 #&amp;lt;DIFFLIB:OPCODE :REPLACE 4 6 3 5&amp;gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;These &quot;opcodes&quot; tell us what to do with subsequences of two lists. For example, &lt;code&gt;REPLACE&lt;/code&gt; opcode from the results tell us that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; This should be replaced:
POFTHEDAY&amp;gt; (subseq &amp;#039;(:one :two :three :four :five :six)
                   4 6)
(:FIVE :SIX)

;; with:
POFTHEDAY&amp;gt; (subseq &amp;#039;(:one :three :four :seven :eight)
                   3 5)
(:SEVEN :EIGHT)

;; The same as we seen in the text output in the beginning:
--- a.txt 
+++ b.txt 
@@ -1,6 +1,5 @@
 one
-two
 three
 four
-five
-six
+seven
+eight&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorow we&apos;ll see the library, which uses &lt;code&gt;cl-difflib&lt;/code&gt; for something more interesting.&lt;/p&gt;
</description>
            <pubDate>Sun, 26 Jul 2020 22:38:01 +0300</pubDate>
        </item>
        <item>
            <title>cl-flow</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0141-cl-flow.html</link>
            <description>&lt;p&gt;&lt;code&gt;CL-Flow&lt;/code&gt; is &lt;a href=&quot;https://twitter.com/borodust&quot;&gt;@borodust&lt;/a&gt;&apos;s library and provides a way for lock-free parallel code execution. You can combine blocks of code and define how they should be executed - serially or in parallel.&lt;/p&gt;
&lt;p&gt;This system is in the Quicklisp, but is not installable because requires &lt;code&gt;bodge-queue&lt;/code&gt; which is not in the Quicklisp yet (or now). You need to install @borodust&apos;s distribution first:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDDAY&amp;gt; (ql-dist:install-dist
             &amp;quot;http://bodge.borodust.org/dist/org.borodust.bodge.txt&amp;quot;
             :replace t :prompt nil)

POFTHEDAY&amp;gt; (ql:quickload &amp;#039;(:simple-flow-dispatcher
                           :cl-flow
                           :log4cl
                           :dexador))

POFTHEDAY&amp;gt; (defun handle-error (e)
             (log:error &amp;quot;Unhandled error&amp;quot; e))

;; This code will help us to run flow blocks
;; in the thread pool:
POFTHEDAY&amp;gt; (defvar *dispatcher*
             (simple-flow-dispatcher:make-simple-dispatcher
              :threads 4
              :error-handler #&amp;#039;handle-error))

POFTHEDAY&amp;gt; (defun run (flow)
             (cl-flow:run *dispatcher* flow))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is an example from &lt;code&gt;cl-flow&lt;/code&gt;&apos;s documentation.&lt;/p&gt;
&lt;p&gt;This code will run three blocks of code in parallel and then pass their results into another block:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (run (flow:serially
                  (flow:concurrently
                    (flow:atomically :first ()
                      &amp;quot;Hello&amp;quot;)
                    (flow:atomically :second ()
                      &amp;quot;Lisp&amp;quot;)
                    (flow:atomically :third ()
                      &amp;quot;World&amp;quot;))
                  ;; Last block will receive results
                  ;; of all previous blocks:
                  (flow:atomically :finally (results)
                    (destructuring-bind (first second third)
                        results
                      (format t &amp;quot;~A ~A ~A~%&amp;quot;
                              first
                              second
                              third)))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sadly, the documentation does not cover a more interesting topic - blocks which generate other blocks. Let&apos;s try to figure out how to use &lt;code&gt;flow:dynamically&lt;/code&gt; to define a web crawler which will process pages recursively:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *base-url*
             &amp;quot;https://borodust.org/projects/cl-flow/&amp;quot;)

POFTHEDAY&amp;gt; (defun is-external (url)
             (or (str:starts-with-p &amp;quot;mailto:&amp;quot; url)
                 (and (str:starts-with-p &amp;quot;http&amp;quot; url)
                      (not (str:starts-with-p *base-url* url)))))

POFTHEDAY&amp;gt; (defun make-full (url)
             (let ((new-url
                     (cond
                       ((or (str:starts-with-p &amp;quot;http&amp;quot; url)
                            (str:starts-with-p &amp;quot;mailto:&amp;quot; url))
                        url)
                       ((str:starts-with-p &amp;quot;/&amp;quot; url)
                        (concatenate &amp;#039;string &amp;quot;https://borodust.org&amp;quot; url))
                       (t
                        (concatenate &amp;#039;string *base-url* url)))))
               (cl-ppcre:regex-replace &amp;quot;#.*&amp;quot; new-url &amp;quot;&amp;quot;)))

POFTHEDAY&amp;gt; (defun make-url-processor (already-processed url)
             (flow:serially
               (flow:atomically url ()
                 (log:info &amp;quot;Downloading ~A&amp;quot; url)
                 (dex:get url))

               ;; This block creates new blocks where each
               ;; will process a single url and produce more
               ;; blocks to process links from fetched pages:
               (flow:dynamically (content)
                 (flow:concurrently
                   (loop with page = (ignore-errors
                                      (plump:parse content))
                         for link in (when page
                                       (plump:get-elements-by-tag-name page &amp;quot;a&amp;quot;))
                         for link-url = (plump:attribute link &amp;quot;href&amp;quot;)
                         for full-url = (make-full link-url)
                         unless (or (is-external full-url)
                                    (gethash full-url already-processed))
                           collect (progn
                                     (setf (gethash full-url already-processed)
                                           t)
                                     (make-url-processor already-processed
                                                         full-url)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can start it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((already-processed (make-hash-table :test &amp;#039;equal)))
             (run
              (make-url-processor already-processed *base-url*))
             already-processed)

 &amp;lt;INFO&amp;gt; [23:10:00] poftheday (make-url-processor body-fu3) -
  Downloading https://borodust.org/projects/
#&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 0 {10073D59A3}&amp;gt;
 &amp;lt;INFO&amp;gt; [23:10:00] poftheday (make-url-processor body-fu3) -
  Downloading https://borodust.org/projects/vinoyaku/
...
 &amp;lt;INFO&amp;gt; [23:10:01] poftheday (make-url-processor body-fu3) -
  Downloading https://borodust.org/projects/cl-bodge/overview/

;; These URL were processed by our crawler:
POFTHEDAY&amp;gt; (rutils:hash-table-to-alist *)
((&amp;quot;https://borodust.org/projects/vinoyaku/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/trivial-gamekit/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/cl-flow/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/cl-bodge/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/cl-flow/getting-started/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/trivial-gamekit/getting-started/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/trivial-gamekit/advanced/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/trivial-gamekit/manual/&amp;quot; . T)
 (&amp;quot;https://borodust.org/projects/cl-bodge/overview/&amp;quot; . T))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It would be nice if &lt;a href=&quot;https://twitter.com/borodust&quot;&gt;@borodust&lt;/a&gt; will do a little code review and check if I used &lt;code&gt;cl-flow&lt;/code&gt; correctly or not.&lt;/p&gt;
</description>
            <pubDate>Sat, 25 Jul 2020 23:26:42 +0300</pubDate>
        </item>
        <item>
            <title>cl-mechanize</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0140-cl-mechanize.html</link>
            <description>&lt;p&gt;The README says this library tries to be a Perl&apos;s WWW:Mechanize clon. There is also Python library &lt;a href=&quot;https://github.com/python-mechanize/mechanize&quot;&gt;mechanize&lt;/a&gt; as well. Seems the stateful web scrapers is popular among some developers.&lt;/p&gt;
&lt;p&gt;When I tried cl-mechanize to log into Reddit, it didn&apos;t work. The &lt;code&gt;fetch&lt;/code&gt; function should discover all forms with their inputs but the login form was empty. Without CSRF token I wasn&apos;t able to log in.&lt;/p&gt;
&lt;p&gt;But I found a fork &lt;a href=&quot;https://github.com/ilook/cl-mechanize&quot;&gt;https://github.com/ilook/cl-mechanize&lt;/a&gt; where this problem was fixed.&lt;/p&gt;
&lt;p&gt;Let&apos;s create a program which will fetch your karma and latest comments from the Reddit!&lt;/p&gt;
&lt;p&gt;First, we need to log in. Mechanize operates on the &lt;code&gt;browser&lt;/code&gt; object which keeps the information about the current page and cookies:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *browser*
             (make-instance &amp;#039;cl-mechanize:browser))

POFTHEDAY&amp;gt; (cl-mechanize:fetch &amp;quot;https://www.reddit.com/login/&amp;quot;
                               *browser*)
#&amp;lt;CL-MECHANIZE:PAGE {100A2D7FA3}&amp;gt;

POFTHEDAY&amp;gt; (mechanize:page-forms *)
(#&amp;lt;CL-MECHANIZE:FORM {100A2D4923}&amp;gt;)

POFTHEDAY&amp;gt; (defparameter *login-form* (first *))

POFTHEDAY&amp;gt; (mechanize:form-inputs *login-form*)
((&amp;quot;otp-type&amp;quot; . &amp;quot;app&amp;quot;) (&amp;quot;otp&amp;quot; . &amp;quot;&amp;quot;) (&amp;quot;password&amp;quot; . &amp;quot;&amp;quot;) (&amp;quot;username&amp;quot; . &amp;quot;&amp;quot;)
 (&amp;quot;is_mobile_ui&amp;quot; . &amp;quot;False&amp;quot;) (&amp;quot;ui_mode&amp;quot; . &amp;quot;&amp;quot;) (&amp;quot;frontpage_signup_variant&amp;quot; . &amp;quot;&amp;quot;)
 (&amp;quot;is_oauth&amp;quot; . &amp;quot;False&amp;quot;)
 (&amp;quot;csrf_token&amp;quot; . &amp;quot;ba038152b86951ab28725c37ed0b3e96d640d083&amp;quot;)
 (&amp;quot;dest&amp;quot; . &amp;quot;https://www.reddit.com&amp;quot;) (&amp;quot;cookie_domain&amp;quot; . &amp;quot;.reddit.com&amp;quot;))

POFTHEDAY&amp;gt; (setf (alexandria:assoc-value
                  (mechanize:form-inputs *login-form*)
                  &amp;quot;username&amp;quot; :test #&amp;#039;string=)
                 &amp;quot;svetlyak40wt&amp;quot;)

POFTHEDAY&amp;gt; (setf (alexandria:assoc-value
                  (mechanize:form-inputs *login-form*)
                  &amp;quot;password&amp;quot; :test #&amp;#039;string=)
                 &amp;quot;********&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;However, ilook&apos;s version of the cl-mechanize does not work either. It fails on form submission with the following error:&lt;/p&gt;
&lt;p&gt;&quot;Don&apos;t know how to handle method :|post|.&quot;&lt;/p&gt;
&lt;p&gt;To overcome this issue we&apos;ll set the method to the proper keyword:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (setf (mechanize:form-method *login-form*)
                 :post)

POFTHEDAY&amp;gt; (mechanize:submit *login-form* *browser*)

POFTHEDAY&amp;gt; (cl-mechanize:fetch &amp;quot;https://www.reddit.com/&amp;quot;
                               *browser*)

POFTHEDAY&amp;gt; (cl-ppcre:scan-to-strings
            &amp;quot;(\\d+) karma&amp;quot;
            (mechanize:page-content *))
&amp;quot;708 karma&amp;quot;
#(&amp;quot;708&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we&apos;ll fetch last 3 comments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Mechanize can be enchanced to handle relative URLs:
POFTHEDAY&amp;gt; (cl-mechanize:fetch &amp;quot;/message/inbox&amp;quot;
                               *browser*)
; Debugger entered on #&amp;lt;DRAKMA:PARAMETER-ERROR
; &amp;quot;Don&amp;#039;t know how to handle scheme ~S.&amp;quot; {100252AA63}&amp;gt;

;; I found that page /message/inbox does not countain messages
;; and you have to fetch this instead:
POFTHEDAY&amp;gt; (cl-mechanize:fetch &amp;quot;https://www.reddit.com/message/inbox?embedded=true&amp;quot;
                               *browser*)
; Debugger entered on #&amp;lt;TYPE-ERROR expected-type: STRING datum: NIL&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you see, &lt;code&gt;cl-mechanize&lt;/code&gt; failed on fetching this simple page. This library is 10 years old and still has so many bugs :(&lt;/p&gt;
&lt;p&gt;Also, I found very unpleasant to work with &lt;code&gt;cxml-stp&lt;/code&gt;&apos;s API. &lt;code&gt;CL-Mechanize&lt;/code&gt; parses the page&apos;s body into &lt;code&gt;cxml&lt;/code&gt; data structures and it was hard to figure out how to search the nodes I need.&lt;/p&gt;
&lt;p&gt;If you know about some other Common Lisp library that is able to keep cookies and suitable for web scraping, please, let me know.&lt;/p&gt;
</description>
            <pubDate>Fri, 24 Jul 2020 21:08:15 +0300</pubDate>
        </item>
        <item>
            <title>papyrus</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0139-papyrus.html</link>
            <description>&lt;p&gt;In &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/04/0050-literate-lisp.html&quot;&gt;post number 50&lt;/a&gt; I&apos;ve reviewed the &lt;code&gt;literate-lisp&lt;/code&gt; system which allows to write you lisp code in &lt;code&gt;org-mode&lt;/code&gt; files and to load them as usual lisp files.&lt;/p&gt;
&lt;p&gt;Papyrus does a similar trick but for Markdown files. It adds a named readtable to load markdown files as usual lisp code.&lt;/p&gt;
&lt;p&gt;The library itself is less than 20 lines of code!&lt;/p&gt;
&lt;p&gt;Here is how does the hello world look like using a literate programming style and Papyrus:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;markdown&apos;&gt;(defpackage #:hello-world
      (:use :cl :named-readtables))
    (in-package #:hello-world)
    
    (in-readtable :papyrus)

# Hello world with Papyrus

As you probably know, every programmer starts his learning of the
new programming language from the &amp;quot;hello world&amp;quot; program.

Simplest hello world program outputs a text &amp;quot;Hello World!&amp;quot; in console and exit.

Here is how we can output this program in Common Lisp:

```lisp
(defun main ()
    (princ &amp;quot;Hello World!&amp;quot;)
    (terpri))
```&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can load it and run our &lt;code&gt;main&lt;/code&gt; function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (ql:quickload :papyrus)

POFTHEDAY&amp;gt; (load &amp;quot;docs/media/0139/hello.md&amp;quot;)
T

POFTHEDAY&amp;gt; (hello-world::main)
Hello World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you can add markdown files as ASDF system&apos;s dependencies!&lt;/p&gt;
&lt;p&gt;However, there are view drawbacks because of Markdown&apos;s limitations and Papyrus simplicity:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;All files have to start with an indented block of code to set proper read-table.&lt;/li&gt;&lt;li&gt;Emacs does not understand the current package when you are doing &lt;code&gt;C-c   C-c&lt;/code&gt;.&lt;/li&gt;&lt;li&gt;It is impossible to define blocks of lisp code which shouldn&apos;t be   evaluated.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;But &lt;code&gt;literate-lisp&lt;/code&gt; system addresses all these issues.&lt;/p&gt;
</description>
            <pubDate>Thu, 23 Jul 2020 22:22:03 +0300</pubDate>
        </item>
        <item>
            <title>freebsd-sysctl</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0138-freebsd-sysctl.html</link>
            <description>&lt;p&gt;This library works on OSX because of its BSD roots, but fails on Linux with error: &quot;The alien function &apos;sysctlnametomib&apos; is undefined.&quot;&lt;/p&gt;
&lt;p&gt;It provides information about the system.&lt;/p&gt;
&lt;p&gt;Here is a quick example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (freebsd-sysctl:sysctl-by-name &amp;quot;kern.hostname&amp;quot;)
&amp;quot;poftheday&amp;quot;

POFTHEDAY&amp;gt; (freebsd-sysctl:sysctl-by-name &amp;quot;kern.ostype&amp;quot;)
&amp;quot;Darwin&amp;quot;

POFTHEDAY&amp;gt; (freebsd-sysctl:sysctl-by-name &amp;quot;machdep.cpu.core_count&amp;quot;)
6&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using this library and &lt;code&gt;cl-spark&lt;/code&gt;, &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/07/0124-cl-spark.html&quot;&gt;reviewed two weeks ago&lt;/a&gt;, we can build a simple tool to monitor the CPU&apos;s temperature:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (loop with num-probes = 30
                 with probes = ()
                 for current = (freebsd-sysctl:sysctl-by-name
                                &amp;quot;machdep.xcpm.cpu_thermal_level&amp;quot;)
                 do (push current probes)
                    (setf probes
                          (subseq probes 0
                                  (min num-probes
                                       (length probes))))
                    (format t &amp;quot;~A ~A~%~%&amp;quot;
                            (cl-spark:spark
                             (reverse probes)
                             :min 30)
                            current)
                    (sleep 15))

&amp;#x2588;&amp;#x2587;&amp;#x2587;&amp;#x2587;&amp;#x2587;&amp;#x2587;&amp;#x2587;&amp;#x2586;&amp;#x2586;&amp;#x2585;&amp;#x2584;&amp;#x2584;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2584;&amp;#x2584;&amp;#x2584;&amp;#x2584;&amp;#x2584;&amp;#x2584; 53
...
&amp;#x2583;&amp;#x2582;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2582;&amp;#x2582;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2584;&amp;#x2585;&amp;#x2586;&amp;#x2587;&amp;#x2588; 93
...
&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2585;&amp;#x2585;&amp;#x2586;&amp;#x2587;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2587;&amp;#x2586;&amp;#x2585;&amp;#x2584; 66
...
&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2583;&amp;#x2585;&amp;#x2585;&amp;#x2586;&amp;#x2587;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2587;&amp;#x2586;&amp;#x2585;&amp;#x2584;&amp;#x2583;&amp;#x2582;&amp;#x2582;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581;&amp;#x2581; 21&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To find out different keys supported by your system do &lt;code&gt;sysctl -a&lt;/code&gt; in console.&lt;/p&gt;
</description>
            <pubDate>Wed, 22 Jul 2020 21:52:20 +0300</pubDate>
        </item>
        <item>
            <title>thread.comm.rendezvous</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0137-thread.comm.rendezvous.html</link>
            <description>&lt;p&gt;This system provides a simple thread synchronization primitive called &lt;a href=&quot;https://en.wikipedia.org/wiki/Rendezvous_(Plan_9)&quot;&gt;Rendezvous&lt;/a&gt;. It allows exchanging pieces of data between threads.&lt;/p&gt;
&lt;p&gt;Here is how it works. You create a &lt;code&gt;rendezvous&lt;/code&gt; object. Then you might create one or many threads and each of them can either to &quot;call&quot; &lt;code&gt;rendezvous&lt;/code&gt; and pass it some value or to &quot;accept&quot; value and return a result.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Accept&lt;/code&gt; blocks the calling thread until some other thread will not &lt;code&gt;call&lt;/code&gt; and vice-versa. This is similar to a thread-safe blocking queue of size 1:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *r*
             (thread.comm.rendezvous:make-rendezvous))

POFTHEDAY&amp;gt; (bt:make-thread
            (lambda ()
              (log:info &amp;quot;Waiting for value&amp;quot;)
              (let ((value (thread.comm.rendezvous:accept-rendezvous *r*)))
                (log:info &amp;quot;Value received: ~S&amp;quot; value))))

&amp;lt;INFO&amp;gt; [2020-07-21T23:06:56.836061+03:00] Waiting for value

POFTHEDAY&amp;gt; (thread.comm.rendezvous:call-rendezvous
            *r*
            :the-value-to-be-sent-to-the-thread)

&amp;lt;INFO&amp;gt; [2020-07-21T23:07:46.642640+03:00] Value received: :THE-VALUE-TO-BE-SENT-TO-THE-THREAD&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I wasn&apos;t able to imagine a more complex but short illustration of the case where this synchronization primitive can be useful. If you know one, please share your ideas in comments.&lt;/p&gt;
</description>
            <pubDate>Tue, 21 Jul 2020 23:34:42 +0300</pubDate>
        </item>
        <item>
            <title>log4cl-extras</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0136-log4cl-extras.html</link>
            <description>&lt;p&gt;Yesterday I&apos;ve posted about the &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/07/0135-log4cl.html&quot;&gt;log4cl&lt;/a&gt; and promised to tell you about my addons. The library is called &lt;code&gt;log4cl-extras&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The main purpose of &lt;code&gt;log4cl-extras&lt;/code&gt; is to make logging suitable for production. It provides &lt;code&gt;JSON&lt;/code&gt; formatter, a macro to capture context variables and a macro to log unhandled tracebacks.&lt;/p&gt;
&lt;p&gt;Capturing context variables makes each log entry self-sustained. Also, this way you can use do a &quot;request_id&quot; trick to bind many related log messages into a single track.&lt;/p&gt;
&lt;p&gt;To show you how does &quot;request_id&quot; trick works, let me create a simple Clack application which will handle a request, simulate the query to the database and use logging.&lt;/p&gt;
&lt;p&gt;Pay attention how does it use &lt;code&gt;log4cl-extras/context:with-fields&lt;/code&gt; to capture &lt;code&gt;request-id&lt;/code&gt; variable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun get-current-user ()
             &amp;quot;This is a fake function simulating SQL queries to database.&amp;quot;
             (log:debug &amp;quot;SELECT * FROM users WHERE ...&amp;quot;)
             (values &amp;quot;Bob&amp;quot;))

POFTHEDAY&amp;gt; (defun handle-request (env)
             (let* ((headers (getf env :headers))
                    (request-id (or (gethash &amp;quot;x-request-id&amp;quot; headers)
                                    (format nil &amp;quot;~A&amp;quot; (uuid:make-v4-uuid)))))
               (log4cl-extras/context:with-fields (:request-id request-id)
                 (log:debug &amp;quot;Processing request&amp;quot;)
                 (let ((user (get-current-user)))
                   (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                         (list (format nil &amp;quot;Hello ~A!&amp;quot; user)))))))

POFTHEDAY&amp;gt; (defparameter *server*
             (clack:clackup &amp;#039;handle-request
                            :port 8081))
Hunchentoot server is started.
Listening on 127.0.0.1:8081.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can initialize logging and make a few HTTP requests:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (log4cl-extras/config:setup
            &amp;#039;(:level :debug
              :appenders ((this-console :layout :plain))))

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8081/&amp;quot;)
&amp;lt;DEBUG&amp;gt; [2020-07-20T23:23:28.293441+03:00] Processing request
  Fields:
    request-id: 0E0D035A-B24F-4E69-806C-ACACE6C6B08E
&amp;lt;DEBUG&amp;gt; [2020-07-20T23:23:28.295783+03:00] SELECT * FROM users WHERE ...
  Fields:
    request-id: 0E0D035A-B24F-4E69-806C-ACACE6C6B08E
&amp;quot;Hello Bob!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Our app is able to use request id passed as an HTTP header &lt;code&gt;X-Request-ID&lt;/code&gt;. This is useful when you have many microservices and want to have a single trail of all their logs:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8081/&amp;quot;
                    :headers &amp;#039;((&amp;quot;X-Request-ID&amp;quot; . &amp;quot;Custom ID :)))))&amp;quot;)))
&amp;lt;DEBUG&amp;gt; [2020-07-20T23:29:04.123354+03:00] Processing request
  Fields:
    request-id: Custom ID :)))))
&amp;lt;DEBUG&amp;gt; [2020-07-20T23:29:04.123412+03:00] SELECT * FROM users WHERE ...
  Fields:
    request-id: Custom ID :)))))
&amp;quot;Hello Bob!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This plain text log format is convenient when you are debugging the application. But in production you either want to &lt;code&gt;grep&lt;/code&gt; log messages or to feed them to the Elastic Search for further indexing.&lt;/p&gt;
&lt;p&gt;In both cases it is more convenient to write each messages as a single-line JSON object:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (log4cl-extras/config:setup
            &amp;#039;(:level :debug
              :appenders ((this-console :layout :json))))

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8081/&amp;quot;)
{&amp;quot;fields&amp;quot;:{&amp;quot;request-id&amp;quot;:&amp;quot;20A7...&amp;quot;},&amp;quot;level&amp;quot;:&amp;quot;DEBUG&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;Processing request&amp;quot;,&amp;quot;timestamp&amp;quot;:&amp;quot;2020-07-20T23:32:34.566029+03:00&amp;quot;}
{&amp;quot;fields&amp;quot;:{&amp;quot;request-id&amp;quot;:&amp;quot;20A7...&amp;quot;},&amp;quot;level&amp;quot;:&amp;quot;DEBUG&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;SELECT * FROM users WHERE ...&amp;quot;,&amp;quot;timestamp&amp;quot;:&amp;quot;2020-07-20T23:32:34.566167+03:00&amp;quot;}
&amp;quot;Hello Bob!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;log4cl-extras&lt;/code&gt; also contains a macro to capture unhandled errors along with their tracebacks. It is also very useful for production. I&apos;m using this facility to capture errors in Ultralisp.org.&lt;/p&gt;
&lt;p&gt;Read &lt;code&gt;log4cl-extra&lt;/code&gt;&apos;s documentation to learn more:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/40ants/log4cl-extras&quot;&gt;https://github.com/40ants/log4cl-extras&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Mon, 20 Jul 2020 23:39:29 +0300</pubDate>
        </item>
        <item>
            <title>log4cl</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0135-log4cl.html</link>
            <description>&lt;p&gt;This is the mystery why I didn&apos;t review any logging library so far! Probably, because there is a &lt;a href=&quot;https://www.sites.google.com/site/sabraonthehill/comparison-of-lisp-logging-libraries&quot;&gt;great article&lt;/a&gt; exists which compares 8 logging libraries.&lt;/p&gt;
&lt;p&gt;Today I want only mention that my library of choice is &lt;code&gt;log4cl&lt;/code&gt;. Mostly because if it&apos;s great integration with SLIME/SLY which helps when you have a lot&apos;s of &quot;debug&quot; logging in the app, but at some moment want to turn it on only for a function or a package.&lt;/p&gt;
&lt;p&gt;Log4cl has &lt;a href=&quot;https://github.com/sharplispers/log4cl&quot;&gt;great documentation&lt;/a&gt; which demonstrates all its features. Here I&apos;ll provide only a small example of its default logging output and ability to process additional arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (log:config :sane2 :debug)

POFTHEDAY&amp;gt; (defun foo (first-arg second-arg)
             (log:info &amp;quot;Entering into the foo with&amp;quot; first-arg &amp;quot;and&amp;quot; second-arg))

POFTHEDAY&amp;gt; (foo 100500 &amp;quot;Blah&amp;quot;)

 &amp;lt;INFO&amp;gt; [21:04:10] poftheday (foo) -
  Entering into the foo with FIRST-ARG: 100500 and SECOND-ARG: &amp;quot;Blah&amp;quot; 

;; Now I want to process arguments with in format-like style:

POFTHEDAY&amp;gt; (defun foo (first-arg second-arg)
             (log:info &amp;quot;Entering into the (foo ~A ~A)&amp;quot; first-arg second-arg))

POFTHEDAY&amp;gt; (foo 100500 &amp;quot;Blah&amp;quot;)
 &amp;lt;INFO&amp;gt; [21:04:53] poftheday (foo) - Entering into the (foo 100500 Blah)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow I&apos;ll show you addons I&apos;ve made, to make &lt;code&gt;log4cl&lt;/code&gt; even more suitable for production applications.&lt;/p&gt;
</description>
            <pubDate>Sun, 19 Jul 2020 21:07:55 +0300</pubDate>
        </item>
        <item>
            <title>taglib</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0134-taglib.html</link>
            <description>&lt;p&gt;The first post in the #poftheday series was about &lt;code&gt;cl-mpg123&lt;/code&gt; library. It failed on attempt to process metadata of mp3 file. Today we&apos;ll try &lt;code&gt;taglib&lt;/code&gt;. This is the pure CL library to process MP3, MP4, FLAC tags.&lt;/p&gt;
&lt;p&gt;Let&apos;s try it on the file from the zero post!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (audio-streams:open-audio-file
            &amp;quot;docs/media/0000/file.mp3&amp;quot;)
#&amp;lt;ID3:MP3-FILE {10036524E3}&amp;gt;

POFTHEDAY&amp;gt; (abstract-tag:show-tags *)
/Users/art/projects/poftheday/docs/media/0000/file.mp3
1 frame read, MPEG 1, Layer III, CBR, sample rate: 44,100 Hz, bit rate: 320 Kbps, duration: 7:15
    album: Rogue&amp;#039;s Gallery: Pirate Ballads, Sea Songs, and Chanteys
    artist: Baby Gramps
    comment: ((0 eng  NIL))
    compilation: no
    cover: (Size: 9,870)
    genre: Folk
    lyrics:  
    title: Cape Cod Girls
    track: (1 23)
    year: 2006
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a possibility to access specific fields:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (audio-streams:open-audio-file
            &amp;quot;docs/media/0000/file.mp3&amp;quot;)
#&amp;lt;ID3:MP3-FILE {10027E6093}&amp;gt;

POFTHEDAY&amp;gt; (id3:id3-header *)
#&amp;lt;ID3:ID3-HEADER {10027E60D3}&amp;gt;

POFTHEDAY&amp;gt; (id3:v21-tag-header *)
#&amp;lt;ID3:V21-TAG-HEADER {10027E6363}&amp;gt;

POFTHEDAY&amp;gt; (id3:album *)
&amp;quot;Rogue&amp;#039;s Gallery: Pirate Ballad&amp;quot;

POFTHEDAY&amp;gt; (id3:title **)
&amp;quot;Cape Cod Girls&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Seems it works very good!&lt;/p&gt;
</description>
            <pubDate>Sat, 18 Jul 2020 22:42:56 +0300</pubDate>
        </item>
        <item>
            <title>open-location-code</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0133-open-location-code.html</link>
            <description>&lt;p&gt;This is an interesting way to encode coordinates on the planet Earth.&lt;/p&gt;
&lt;p&gt;These codes can be short enough to remember them, and they are pronounceable. What is essential – they supported by Google.&lt;/p&gt;
&lt;p&gt;For example, I have an architectural landmark in nearby Bykovo village - the &lt;a href=&quot;https://ru.wikipedia.org/wiki/Усадьба_Быково&quot;&gt;Vorontcov-Dashkov&apos;s mansion&lt;/a&gt;. Its coordinates are &lt;code&gt;55.608093&lt;/code&gt;, &lt;code&gt;38.048927&lt;/code&gt; or &lt;code&gt;55&#xB0;36&apos;29.1&quot;N 38&#xB0;02&apos;56.1&quot;E&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This building has no address, but we can get an &quot;open location code&quot; for its location on Google Maps:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0133/map.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;J25X+6H&lt;/code&gt; is the shortened open location code for this location.&lt;/p&gt;
&lt;p&gt;You can get the full code using latitude, longitude and one line of Lisp code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:encode
            55.608093
            38.048927)
&amp;quot;9G7WJ25X+6H&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The code &lt;code&gt;9G7WJ25X+6H&lt;/code&gt; is full. It has all information to get back our latitude and longitude:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:decode &amp;quot;9G7WJ25X+6H&amp;quot;)
#&amp;lt;OPEN-LOCATION-CODE:CODE-AREA {1002BF7E13}&amp;gt;
:FULL

POFTHEDAY&amp;gt; (open-location-code:south-west-corner *)
6951/125 (55.608)
304391/8000 (38.048874)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But for short code this will not work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:decode &amp;quot;J25X+6H&amp;quot;)
#&amp;lt;OPEN-LOCATION-CODE:CODE-AREA {10067CAAB3}&amp;gt;
:SHORT

POFTHEDAY&amp;gt; (open-location-code:south-west-corner *)
76/125 (0.608, 304/5%)
391/8000 (0.048875, 391/80%)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To get the coordinates, you need to &quot;recover&quot; the full code first. This is done using some reference point. For example, we can take the nearest village&apos;s coordinates as the reference point:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:recover
            &amp;quot;J25X+6H&amp;quot;
            55.634068
            38.044629)
&amp;quot;9G7WJ25X+6H&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is the same code we&apos;ve received from mansion&apos;s coordinates. You can open the Google Maps and search the code &lt;code&gt;9G7WJ25X+6H&lt;/code&gt; to check it. In real life short codes are used together with the name of the nearest city, like &lt;code&gt;J25X+6H Быково, Московская обл.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;That is for today. For me, open location codes were an exciting discovery. Didn&apos;t hear about them before.&lt;/p&gt;
</description>
            <pubDate>Fri, 17 Jul 2020 23:38:24 +0300</pubDate>
        </item>
        <item>
            <title>cl-irc</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0132-cl-irc.html</link>
            <description>&lt;p&gt;Today we&apos;ll write a simple bot to keep a history of the IRC channel. IRC is a chat protocol that existed before Slack, Telegram, etc.&lt;/p&gt;
&lt;p&gt;For the test I&apos;ve installed a local lisp server on my OSX:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[poftheday:~]% brew install ngircd
Updating Homebrew...
...
==&amp;gt; Caveats
==&amp;gt; ngircd
To have launchd start ngircd now and restart at login:
  brew services start ngircd

[poftheday:~]% /usr/local/sbin/ngircd --nodaemon --passive

[poftheday:~]% /usr/local/sbin/ngircd --nodaemon --passive
[66510:5    0] ngIRCd 26-IDENT+IPv6+IRCPLUS+SSL+SYSLOG+ZLIB-x86_64/apple/darwin19.5.0 starting ...
[66510:6    0] Using configuration file &amp;quot;/usr/local/etc/ngircd.conf&amp;quot; ...
[66510:3    0] Can&amp;#039;t read MOTD file &amp;quot;/usr/local/etc/ngircd.motd&amp;quot;: No such file or directory
[66510:4    0] No administrative information configured but required by RFC!
[66510:6    0] ServerUID must not be root(0), using &amp;quot;nobody&amp;quot; instead.
[66510:3    0] Can&amp;#039;t change group ID to nobody(4294967294): Operation not permitted!
[66510:3    0] Can&amp;#039;t drop supplementary group IDs: Operation not permitted!
[66510:3    0] Can&amp;#039;t change user ID to nobody(4294967294): Operation not permitted!
[66510:6    0] Running as user art(1345292665), group LD\Domain Users(593637566), with PID 66510.
[66510:6    0] Not running with changed root directory.
[66510:6    0] IO subsystem: kqueue (initial maxfd 100, masterfd 3).
[66510:6    0] Now listening on [0::]:6667 (socket 6).
[66510:6    0] Now listening on [0.0.0.0]:6667 (socket 8).
[66510:5    0] Server &amp;quot;irc.example.net&amp;quot; (on &amp;quot;poftheday&amp;quot;) ready.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After that, I&apos;ve installed a command line IRC client &lt;code&gt;ircii&lt;/code&gt; and made two connections to simulate users in the #lisp channel.&lt;/p&gt;
&lt;p&gt;Now it is time to connect our bot to the server and create a thread with the message processing loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter
               *conn*
             (cl-irc:connect :nickname &amp;quot;bot&amp;quot;
                             :server &amp;quot;localhost&amp;quot;))

POFTHEDAY&amp;gt; (defparameter *thread*
             (bt:make-thread (lambda ()
                               (cl-irc:read-message-loop *conn*))
                             :name &amp;quot;IRC&amp;quot;))

POFTHEDAY&amp;gt; (cl-irc:join *conn* &amp;quot;#lisp&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;While messages are processed in the thread we are free to experiment in the &lt;code&gt;REPL&lt;/code&gt;. Let&apos;s add a hook to process messages from the channel:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun on-message (msg)
             (log:info &amp;quot;New message&amp;quot; msg))

POFTHEDAY&amp;gt; (cl-irc:add-hook *conn*
                            &amp;#039;cl-irc:irc-privmsg-message
                            &amp;#039;on-message)

;; Now if some of users will write to the channel,
;; the message will be logged to the screen:

POFTHEDAY&amp;gt; 
; No values
 &amp;lt;INFO&amp;gt; [22:35:43] poftheday (on-message) -
  New message POFTHEDAY::MSG: #&amp;lt;CL-IRC:IRC-PRIVMSG-MESSAGE joanna PRIVMSG {1007692DA3}&amp;gt;
  
UNHANDLED-EVENT:3803916943: PRIVMSG: joanna #lisp &amp;quot;Hello lispers!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can modify the &lt;code&gt;on-message&lt;/code&gt; function to save the last message into the global variable to inspect its structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; *last-msg*
#&amp;lt;CL-IRC:IRC-PRIVMSG-MESSAGE joanna PRIVMSG {1007703213}&amp;gt;

POFTHEDAY&amp;gt; (describe *)
#&amp;lt;CL-IRC:IRC-PRIVMSG-MESSAGE joanna PRIVMSG {1007703213}&amp;gt;
  [standard-object]

Slots with :INSTANCE allocation:
  SOURCE                         = &amp;quot;joanna&amp;quot;
  USER                           = &amp;quot;~art&amp;quot;
  HOST                           = &amp;quot;localhost&amp;quot;
  COMMAND                        = &amp;quot;PRIVMSG&amp;quot;
  ARGUMENTS                      = (&amp;quot;#lisp&amp;quot; &amp;quot;Hello&amp;quot;)
  CONNECTION                     = #&amp;lt;CL-IRC:CONNECTION localhost {1003918FA3}&amp;gt;
  RECEIVED-TIME                  = 3803917081
  RAW-MESSAGE-STRING             = &amp;quot;:joanna!~art@localhost PRIVMSG #lisp :Hello&#xD;&amp;quot;

;; If user sent a direct message,
;; it will have the bot&amp;#039;s username as the first argument:

POFTHEDAY&amp;gt; (describe *last-msg*)
#&amp;lt;CL-IRC:IRC-PRIVMSG-MESSAGE joanna PRIVMSG {1001600943}&amp;gt;
  [standard-object]

Slots with :INSTANCE allocation:
  SOURCE                         = &amp;quot;joanna&amp;quot;
  USER                           = &amp;quot;~art&amp;quot;
  HOST                           = &amp;quot;localhost&amp;quot;
  COMMAND                        = &amp;quot;PRIVMSG&amp;quot;
  ARGUMENTS                      = (&amp;quot;bot&amp;quot; &amp;quot;Hello. It is Joanna.&amp;quot;)
  CONNECTION                     = #&amp;lt;CL-IRC:CONNECTION localhost {1003918FA3}&amp;gt;
  RECEIVED-TIME                  = 3803917270
  RAW-MESSAGE-STRING             = &amp;quot;:joanna!~art@localhost PRIVMSG bot :Hello. It is Joanna.&#xD;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you intend to make a bot which will reply to the messages, you have to choose either &lt;code&gt;message&lt;/code&gt;&apos;s source slot or the first argument as a destination for the response.&lt;/p&gt;
&lt;p&gt;Most probably &lt;a href=&quot;https://twitter.com/SatoshiShinohai/status/1283761536109023232&quot;&gt;the bug&lt;/a&gt; &lt;a href=&quot;https://twitter.com/SatoshiShinohai&quot;&gt;@SatoshiShinohai&lt;/a&gt; complained about on Twitter is caused by the wrong algorithm for choosing the response&apos;s destination.&lt;/p&gt;
&lt;p&gt;Now let&apos;s redefine our &lt;code&gt;on-message&lt;/code&gt; function to format log messages in an accurate way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun on-message (msg)
             (log:info &amp;quot;&amp;lt;~A&amp;gt; ~A&amp;quot;
                       (cl-irc:source msg)
                       (second (cl-irc:arguments msg)))
             ;; To let cl-irc know that we&amp;#039;ve processed the event
             ;; we need to return `t&amp;#039;.
             ;; Otherwise it will output &amp;quot;UNHANDLED-EVENT&amp;quot; messages.
             t)
WARNING: redefining POFTHEDAY::ON-MESSAGE in DEFUN
ON-MESSAGE
 &amp;lt;INFO&amp;gt; [22:55:06] poftheday (on-message) - &amp;lt;joanna&amp;gt; Hello everybody!
 &amp;lt;INFO&amp;gt; [22:55:17] poftheday (on-message) - &amp;lt;art&amp;gt; Hello, Joanna!
 &amp;lt;INFO&amp;gt; [22:55:27] poftheday (on-message) -
  &amp;lt;joanna&amp;gt; What is the best book on Common Lisp for newbee?
 &amp;lt;INFO&amp;gt; [22:55:56] poftheday (on-message) - &amp;lt;art&amp;gt; Try the Practical Common Lisp.
 &amp;lt;INFO&amp;gt; [22:56:04] poftheday (on-message) - &amp;lt;joanna&amp;gt; Thanks!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you want to make the bot which responds to the message, then use &lt;code&gt;cl-irc:privmsg&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; This will send a message to the channel:
POFTHEDAY&amp;gt; (cl-irc:privmsg *conn* &amp;quot;#lisp&amp;quot; &amp;quot;Hello! Bot is in the channel!&amp;quot;)
&amp;quot;PRIVMSG #lisp :Hello! Bot is in the channel!
&amp;quot;

;; and this will send a private message:
POFTHEDAY&amp;gt; (cl-irc:privmsg *conn* &amp;quot;joanna&amp;quot; &amp;quot;Hi Joanna!&amp;quot;)
&amp;quot;PRIVMSG joanna :Hi Joanna!
&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you will download the cl-irc&apos;s sources from &lt;a href=&quot;https://common-lisp.net/project/cl-irc/&quot;&gt;https://common-lisp.net/project/cl-irc/&lt;/a&gt; you&apos;ll find more sofisticated bot in the &lt;code&gt;example&lt;/code&gt; folder.&lt;/p&gt;
&lt;p&gt;One final note, to debug communication between lisp and IRC server set the &lt;code&gt;cl-irc::*debug-p*&lt;/code&gt; variable to true and it will log every message send or received by the bot.&lt;/p&gt;
</description>
            <pubDate>Thu, 16 Jul 2020 23:05:57 +0300</pubDate>
        </item>
        <item>
            <title>piping</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0131-piping.html</link>
            <description>&lt;p&gt;This library in some sense similar to the &lt;code&gt;cl-events&lt;/code&gt;, &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/07/0130-cl-events.html&quot;&gt;reviewed yesterday&lt;/a&gt;. It allows defining pipelines to process messages.&lt;/p&gt;
&lt;p&gt;Each message can be processed sequentially or in parallel. Each node would be an instance of the &lt;code&gt;segment&lt;/code&gt; class. There are two kinds of nodes - intermediate and final.&lt;/p&gt;
&lt;p&gt;Intermediate nodes can filter messages or route them into other pipelines.&lt;/p&gt;
&lt;p&gt;Final nodes are called &lt;code&gt;faucets&lt;/code&gt;. They process the message and stop processing.&lt;/p&gt;
&lt;p&gt;For example here is how we can build a log message processing using &lt;code&gt;piping&lt;/code&gt;. We want to print all &lt;code&gt;ERROR&lt;/code&gt; messages to &lt;code&gt;*error-output*&lt;/code&gt; and to write all messages to the log file.&lt;/p&gt;
&lt;p&gt;To create this pipeline, we need following &lt;code&gt;segments&lt;/code&gt;. Here is &quot;Pipeline&quot; is a chain of &lt;code&gt;segments&lt;/code&gt; to pass the message through:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;Pipeline:
  Print[&amp;quot;full.log&amp;quot;]
  Pipeline: Filter[if ERROR] -&amp;gt; Print[*error-output*]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how we can configure this pipeline in Lisp code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *pipe*
             (make-instance &amp;#039;piping:pipeline))

POFTHEDAY&amp;gt; (defparameter *log-printer*
             (piping:add-segment
               *pipe*
               (make-instance &amp;#039;piping:printer
                              :stream (open &amp;quot;full.log&amp;quot;
                                            :direction :output
                                            :if-exists :append
                                            :if-does-not-exist :create))))

;; This adds a sub-pipe where we&amp;#039;ll filter message
;; and print if it stats with &amp;quot;ERROR&amp;quot;:
POFTHEDAY&amp;gt; (piping:add-segment *pipe* :pipe)

POFTHEDAY&amp;gt; (piping:add-segment *pipe*
            (make-instance &amp;#039;piping:predicate-filter
                           :predicate (lambda (message)
                                        (str:starts-with-p &amp;quot;ERROR: &amp;quot; message)))
            &amp;#039;(1))

POFTHEDAY&amp;gt; (piping:add-segment *pipe*
            (make-instance &amp;#039;piping:printer
                           :stream *error-output*)
            &amp;#039;(1))

;; Now we&amp;#039;ll pass two messages through this pipeline:
POFTHEDAY&amp;gt; (piping:pass *pipe*
             &amp;quot;INFO: Hello world!&amp;quot;)

;; This one will be printed to *error-output*:
POFTHEDAY&amp;gt; (piping:pass *pipe*
             &amp;quot;ERROR: Something bad happened!&amp;quot;)

&amp;quot;ERROR: Something bad happened!&amp;quot; 

;; But in file both messages are present:
POFTHEDAY&amp;gt; (force-output (piping:print-stream *log-printer*))

POFTHEDAY&amp;gt; (princ (alexandria:read-file-into-string &amp;quot;full.log&amp;quot;))

&amp;quot;INFO: Hello world!&amp;quot; 
&amp;quot;ERROR: Something bad happened!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Working on this example, I found two things:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;there is no component to fanout messages into the nested &lt;code&gt;segments&lt;/code&gt; or   sub pipes.&lt;/li&gt;&lt;li&gt;using indices to point to a place where a segment should be added is   very inconvenient.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@Shinmera&lt;/a&gt; uses &lt;code&gt;piping&lt;/code&gt; in his logging library &lt;a href=&quot;https://github.com/Shinmera/verbose&quot;&gt;verbose&lt;/a&gt;. I skimmed through its sources and didn&apos;t find if he has some solution of fanout absence problem.&lt;/p&gt;
&lt;p&gt;Definitely, this library can be made a more convenient if somebody is interested to use it for other purposes.&lt;/p&gt;
</description>
            <pubDate>Wed, 15 Jul 2020 23:26:21 +0300</pubDate>
        </item>
        <item>
            <title>cl-events</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0130-cl-events.html</link>
            <description>&lt;p&gt;This is the library by &lt;a href=&quot;https://twitter.com/dead_trickster&quot;&gt;@dead_trickster&lt;/a&gt;. It implements a pub-sub API and allows to:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;create an event object;&lt;/li&gt;&lt;li&gt;subscribe on it;&lt;/li&gt;&lt;li&gt;fire the event.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;CL-Events&lt;/code&gt; provides a way to add a hook point for your application.&lt;/p&gt;
&lt;p&gt;Here is the simplest example. Here we create a single-threaded event where all callbacks will be called sequentially:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *on-click*
             (make-instance &amp;#039;cl-events:event))

POFTHEDAY&amp;gt; (defun the-callback (message)
             ;; pretend, we need some time to process the callback
             (sleep 1)
             (format t &amp;quot;MSG [~A]: ~A~%&amp;quot;
                     (bt:current-thread)
                     message))

POFTHEDAY&amp;gt; (cl-events:event+ *on-click*
                             &amp;#039;the-callback)

POFTHEDAY&amp;gt; (cl-events:event! *on-click*
                             &amp;quot;Button clicked!&amp;quot;)
MSG [#&amp;lt;THREAD &amp;quot;sly-channel-1-mrepl-remote-1&amp;quot; RUNNING {1003955B33}&amp;gt;]: Button clicked!
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To make them execute in parallel, you only need to replace the type of the event object. Pay attention to the thread&apos;s name in the callback&apos;s output. They are different:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *on-click*
             (make-instance &amp;#039;cl-events:broadcast-event))

POFTHEDAY&amp;gt; (defun the-callback (handler-name message)
             ;; pretend, we need some time to process the callback
             (sleep 1)
             (format t &amp;quot;MSG [~A/~A]: ~A~%&amp;quot;
                     handler-name
                     (bt:current-thread)
                     message))

POFTHEDAY&amp;gt; (cl-events:event+ *on-click*
                             (alexandria:curry &amp;#039;the-callback
                                               &amp;quot;First handler&amp;quot;))

POFTHEDAY&amp;gt; (cl-events:event+ *on-click*
                             (alexandria:curry &amp;#039;the-callback
                                               &amp;quot;Second handler&amp;quot;))

POFTHEDAY&amp;gt; (cl-events:event! *on-click*
                             &amp;quot;Button clicked!&amp;quot;)
NIL
MSG [Second handler/#&amp;lt;THREAD &amp;quot;lparallel&amp;quot; RUNNING {1005A97983}&amp;gt;]: Button clicked!
MSG [First handler/#&amp;lt;THREAD &amp;quot;lparallel&amp;quot; RUNNING {1005A96F93}&amp;gt;]: Button clicked!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, in this case, &lt;code&gt;event!&lt;/code&gt; function returns before all handlers are called.&lt;/p&gt;
&lt;p&gt;In this case, parallel execution is implemented using &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0093-lparallel.html&quot;&gt;lparallel&apos;s thread pool&lt;/a&gt;. There are more executors available and you can implement your own.&lt;/p&gt;
</description>
            <pubDate>Tue, 14 Jul 2020 22:47:14 +0300</pubDate>
        </item>
        <item>
            <title>trivial-with-current-source-form</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0129-trivial-with-current-source-form.html</link>
            <description>&lt;p&gt;This library is a compatibility layer. It helps to provide hints to the Lisp compiler. Hints allow the compiler to show more precise error messages when error happens during the macro-expansion.&lt;/p&gt;
&lt;p&gt;Here is an example I&apos;ve stolen from the library&apos;s documentation. To show you how this works in dynamic, I&apos;ve recorded a GIF image.&lt;/p&gt;
&lt;p&gt;Pay attention, without the hint compiler highlights &quot;even-number-case&quot; top-level form:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0129/with-current-source-form.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;That is it. You just wrap some part of the macro-processing code with &lt;code&gt;with-current-source-form&lt;/code&gt; and say: &quot;Hey, compiler! Here is the s-expr I&apos;m currently processing. If some shit will happen, let the user know.&quot;&lt;/p&gt;
&lt;p&gt;As I said before, this library is a compatibility layer. Only SBCL and Clasp are supported for now. On other implementations, the macro will do nothing.&lt;/p&gt;
</description>
            <pubDate>Mon, 13 Jul 2020 22:17:20 +0300</pubDate>
        </item>
        <item>
            <title>trivial-benchmark</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0128-trivial-benchmark.html</link>
            <description>&lt;p&gt;Some time ago I&apos;ve reviewed the &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0100-the-cost-of-nothing.html&quot;&gt;the-cost-of-nothing&lt;/a&gt; library which allowed you to check the performance of the form execution. &lt;code&gt;Trivial-benchmark&lt;/code&gt; does a similar job but has a few pros and cons.&lt;/p&gt;
&lt;p&gt;The main con is that you have to give it a number of iterations manually, but the pro is that the library provides a way more statistics:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (trivial-benchmark:with-timing (1000000)
             (format nil &amp;quot;Symbol is: ~S&amp;quot; :foo))

-                SAMPLES  TOTAL      MINIMUM   MAXIMUM   MEDIAN    AVERAGE    DEVIATION  
REAL-TIME        1000000  3.78       0         0.169     0         0.000004   0.000207   
RUN-TIME         1000000  3.734      0         0.132     0         0.000004   0.000179   
USER-RUN-TIME    1000000  2.332375   0.000001  0.061505  0.000002  0.000002   0.00011    
SYSTEM-RUN-TIME  1000000  1.398129   0.000001  0.070875  0.000001  0.000001   0.000072   
PAGE-FAULTS      1000000  0          0         0         0         0          0.0        
GC-RUN-TIME      1000000  0.436      0         0.132     0         0.0        0.000168   
BYTES-CONSED     1000000  592388352  0         130976    0         592.38837  4354.098   
EVAL-CALLS       1000000  0          0         0         0         0          0.0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another cool feature is the ability to define more custom metrics.&lt;/p&gt;
&lt;p&gt;Here is a practical example. We&apos;ll measure a number of SQL queries made during form execution:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; These are owr SQL driver simulation:
POFTHEDAY&amp;gt; (defparameter *num-queries* 0)

POFTHEDAY&amp;gt; (defun execute (query)
             &amp;quot;A fake SQL driver&amp;quot;
             (declare (ignorable query))
             (incf *num-queries*))

;; The application code:
POFTHEDAY&amp;gt; (defun the-view ()
             (execute &amp;quot;SELECT some FROM data&amp;quot;)
             (loop repeat 5
                   do (execute &amp;quot;SELECT some FROM other_data&amp;quot;)))

;; Metric definition is very simple. You just provide a code
;; which returns an absolute value:
POFTHEDAY&amp;gt; (trivial-benchmark:define-delta-metric sql-queries
             *num-queries*)

;; Pay attention to the last line of the report:
POFTHEDAY&amp;gt; (trivial-benchmark:with-timing (100)
             (the-view))
-                SAMPLES  TOTAL     MINIMUM   MAXIMUM   MEDIAN    AVERAGE   DEVIATION  
REAL-TIME        100      0         0         0         0         0         0.0        
RUN-TIME         100      0         0         0         0         0         0.0        
USER-RUN-TIME    100      0.000308  0.000001  0.00012   0.000002  0.000003  0.000012   
SYSTEM-RUN-TIME  100      0.000117  0.000001  0.000002  0.000001  0.000001  0.0        
PAGE-FAULTS      100      0         0         0         0         0         0.0        
GC-RUN-TIME      100      0         0         0         0         0         0.0        
BYTES-CONSED     100      98240     0         65536     0         982.4     7258.1045  
EVAL-CALLS       100      0         0         0         0         0         0.0        
SQL-QUERIES      100      600       6         6         6         6         0.0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;trivial-benchmark&lt;/code&gt; is not as accurate as &lt;code&gt;the-cost-of-nothing&lt;/code&gt; because it does not count the overhead, but overhead can be significant because &lt;code&gt;trivial-benchmark&lt;/code&gt; uses generic functions.&lt;/p&gt;
&lt;p&gt;Also when sampling, the &lt;code&gt;trivial-benchmark&lt;/code&gt; executes the form only once. That is why the measurements for a very fast code will be even more inaccurate.&lt;/p&gt;
&lt;p&gt;Another interesting feature is the ability to define benchmark suites to measure performance regression of some parts of your code. I won&apos;t show you an example of such a suite. Just go and read nice documentation, written by @Shinmera:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Shinmera/trivial-benchmark#benchmark-suites&quot;&gt;https://github.com/Shinmera/trivial-benchmark#benchmark-suites&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Sun, 12 Jul 2020 23:11:25 +0300</pubDate>
        </item>
        <item>
            <title>chameleon</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0127-chameleon.html</link>
            <description>&lt;p&gt;Chameleon is a configuration management library. It allows us to define a bunch of options and their values for different profiles. After that, you can switch between profiles.&lt;/p&gt;
&lt;p&gt;It works like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (chameleon:defconfig
             (port 8000 &amp;quot;Port to listen on&amp;quot;)
             (log-level :info &amp;quot;The log level for log4cl&amp;quot;))

POFTHEDAY&amp;gt; (chameleon:defprofile :dev)

POFTHEDAY&amp;gt; (chameleon:defprofile :production
             (port 80)
             (log-level :warn))

POFTHEDAY&amp;gt; (setf (active-profile) :production)
:PRODUCTION
POFTHEDAY&amp;gt; (port)
80

POFTHEDAY&amp;gt; (log-level)
:WARN

POFTHEDAY&amp;gt; (active-profile)
:PRODUCTION

;; Now switching to development mode:
POFTHEDAY&amp;gt; (setf (active-profile) :dev)
:DEV

POFTHEDAY&amp;gt; (port)
8000

POFTHEDAY&amp;gt; (log-level)
:INFO&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I&apos;ve investigated the &lt;code&gt;chameleon&apos;s&lt;/code&gt; code and think it can be made better and simpler using &lt;code&gt;CLOS&lt;/code&gt; instances for profiles instead of hash maps.&lt;/p&gt;
&lt;p&gt;If you know other Lisp systems for configuration management, please, let me know.&lt;/p&gt;
</description>
            <pubDate>Sat, 11 Jul 2020 21:23:05 +0300</pubDate>
        </item>
        <item>
            <title>with-output-to-stream</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0126-with-output-to-stream.html</link>
            <description>&lt;p&gt;This is a &quot;trivial&quot; library by &lt;a href=&quot;https://twitter.com/HexstreamSoft&quot;&gt;@HexstreamSoft&lt;/a&gt;. It simplifies the writing of the functions which would like to accept a stream argument as &lt;code&gt;format&lt;/code&gt; function does.&lt;/p&gt;
&lt;p&gt;CL&apos;s &lt;code&gt;format&lt;/code&gt; function accepts as the first parameter a &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt; or a stream object. In first case it returns a string and in second - outputs to &lt;code&gt;*standard-output*&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When you are writing a custom function with similar semantics, you have to handle all these cases by hand. Here is where &lt;code&gt;with-output-to-stream&lt;/code&gt; helps you:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun log-info (obj &amp;amp;key (stream t))
             (with-output-to-stream:with-output-to-stream (s stream)
               (write-string &amp;quot;INFO &amp;quot; s)
               (write obj :stream s)
               (terpri s)))

;; Here is we return result as a string:
POFTHEDAY&amp;gt; (log-info 100500 :stream nil)
&amp;quot;INFO 100500
&amp;quot;

;; This will output to *standard-output*:
POFTHEDAY&amp;gt; (log-info 100500 :stream t)
INFO 100500
NIL

;; But you can pass any stream as the argument:
POFTHEDAY&amp;gt; (log-info 100500 :stream *error-output*)
INFO 100500
NIL

POFTHEDAY&amp;gt; (with-output-to-string (s)
             (log-info 100500 :stream s)
             (log-info 42 :stream s))
&amp;quot;INFO 100500
INFO 42
&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it for today.&lt;/p&gt;
</description>
            <pubDate>Fri, 10 Jul 2020 20:41:09 +0300</pubDate>
        </item>
        <item>
            <title>lisp-critic</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0125-lisp-critic.html</link>
            <description>&lt;p&gt;A few weeks ago, &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0097-sblint.html&quot;&gt;I&apos;ve reviewed&lt;/a&gt; the &lt;code&gt;sblint&lt;/code&gt; - a tool to check code quality in terms of warnings from the SBCL compiler. &lt;code&gt;Lisp-critic&lt;/code&gt; is another kind of beast. It checks the code quality in terms of common patterns and idioms.&lt;/p&gt;
&lt;p&gt;For example, it outputs warning when there is only one subform inside the &lt;code&gt;progn&lt;/code&gt; or if you are setting global variables in the function definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lisp-critic:critique
            (progn
              (format t &amp;quot;Hello World!&amp;quot;)))
----------------------------------
Why do you think you need a PROGN?
----------------------------------

POFTHEDAY&amp;gt; (lisp-critic:critique
            (defun start-server ()
              (setf *server*
                    (listen-on :port 8080))
              (values)))
----------------------------------------------------
GLOBALS!! Don&amp;#039;t use global variables, i.e., *SERVER*
----------------------------------------------------&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Lisp-critic&lt;/code&gt; operates on patterns. There are &lt;a href=&quot;https://github.com/g000001/lisp-critic/blob/master/lisp-rules.lisp&quot;&gt;109 built-in patterns&lt;/a&gt; and you can define more:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (length (lisp-critic:get-pattern-names))
109

POFTHEDAY&amp;gt; (rutils:take 10
             (lisp-critic:get-pattern-names))
(LISP-CRITIC::?-FOR-PREDICATE
 LISP-CRITIC::ADD-ZERO
 LISP-CRITIC::APPEND-LIST-LIST
 LISP-CRITIC::APPEND-LIST-LOOP
 LISP-CRITIC::APPEND-LIST-RECURSION
 LISP-CRITIC::APPEND-LIST2-LIST
 LISP-CRITIC::APPLY-FOR-FUNCALL
 LISP-CRITIC::CAR-CDR
 LISP-CRITIC::CONCATENATE-LIST
 LISP-CRITIC::COND-&amp;gt;OR)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you can use &lt;code&gt;lisp-critic:critique-file&lt;/code&gt; to analyze all top-level forms in a file.&lt;/p&gt;
&lt;p&gt;It would be nice to:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;add a command-line tool (like sblint) to check all files in the   project;&lt;/li&gt;&lt;li&gt;to add the ability to ignore some checks for some forms. Probably &lt;code&gt;declaim&lt;/code&gt;   could be used for this purpose?&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Probably adding an integration with SLIME or SLY would also be a good idea.&lt;/p&gt;
&lt;p&gt;This way you&apos;ll be able to hit some shortcuts to receive recommendations from Lisp Critic, or it could happen when you are evaluating a top-level form.&lt;/p&gt;
</description>
            <pubDate>Thu, 09 Jul 2020 23:29:31 +0300</pubDate>
        </item>
    </channel>
</rss>