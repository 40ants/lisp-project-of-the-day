<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>trivial-with-current-source-form</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0129-trivial-with-current-source-form.html</link>
            <description>&lt;p&gt;This library is a compatibility layer. It helps to provide hints to the Lisp compiler. Hints allow the compiler to show more precise error messages when error happens during the macro-expansion.&lt;/p&gt;
&lt;p&gt;Here is an example I&apos;ve stolen from the library&apos;s documentation. To show you how this works in dynamic, I&apos;ve recorded a GIF image.&lt;/p&gt;
&lt;p&gt;Pay attention, without the hint compiler highlights &quot;even-number-case&quot; top-level form:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0129/with-current-source-form.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;That is it. You just wrap some part of the macro-processing code with &lt;code&gt;with-current-source-form&lt;/code&gt; and say: &quot;Hey, compiler! Here is the s-expr I&apos;m currently processing. If some shit will happen, let the user know.&quot;&lt;/p&gt;
&lt;p&gt;As I said before, this library is a compatibility layer. Only SBCL and Clasp are supported for now. On other implementations, the macro will do nothing.&lt;/p&gt;
</description>
            <pubDate>Mon, 13 Jul 2020 22:17:20 +0300</pubDate>
        </item>
        <item>
            <title>trivial-benchmark</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0128-trivial-benchmark.html</link>
            <description>&lt;p&gt;Some time ago I&apos;ve reviewed the &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0100-the-cost-of-nothing.html&quot;&gt;the-cost-of-nothing&lt;/a&gt; library which allowed you to check the performance of the form execution. &lt;code&gt;Trivial-benchmark&lt;/code&gt; does a similar job but has a few pros and cons.&lt;/p&gt;
&lt;p&gt;The main con is that you have to give it a number of iterations manually, but the pro is that the library provides a way more statistics:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (trivial-benchmark:with-timing (1000000)
             (format nil &amp;quot;Symbol is: ~S&amp;quot; :foo))

-                SAMPLES  TOTAL      MINIMUM   MAXIMUM   MEDIAN    AVERAGE    DEVIATION  
REAL-TIME        1000000  3.78       0         0.169     0         0.000004   0.000207   
RUN-TIME         1000000  3.734      0         0.132     0         0.000004   0.000179   
USER-RUN-TIME    1000000  2.332375   0.000001  0.061505  0.000002  0.000002   0.00011    
SYSTEM-RUN-TIME  1000000  1.398129   0.000001  0.070875  0.000001  0.000001   0.000072   
PAGE-FAULTS      1000000  0          0         0         0         0          0.0        
GC-RUN-TIME      1000000  0.436      0         0.132     0         0.0        0.000168   
BYTES-CONSED     1000000  592388352  0         130976    0         592.38837  4354.098   
EVAL-CALLS       1000000  0          0         0         0         0          0.0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another cool feature is the ability to define more custom metrics.&lt;/p&gt;
&lt;p&gt;Here is a practical example. We&apos;ll measure a number of SQL queries made during form execution:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; These are owr SQL driver simulation:
POFTHEDAY&amp;gt; (defparameter *num-queries* 0)

POFTHEDAY&amp;gt; (defun execute (query)
             &amp;quot;A fake SQL driver&amp;quot;
             (declare (ignorable query))
             (incf *num-queries*))

;; The application code:
POFTHEDAY&amp;gt; (defun the-view ()
             (execute &amp;quot;SELECT some FROM data&amp;quot;)
             (loop repeat 5
                   do (execute &amp;quot;SELECT some FROM other_data&amp;quot;)))

;; Metric definition is very simple. You just provide a code
;; which returns an absolute value:
POFTHEDAY&amp;gt; (trivial-benchmark:define-delta-metric sql-queries
             *num-queries*)

;; Pay attention to the last line of the report:
POFTHEDAY&amp;gt; (trivial-benchmark:with-timing (100)
             (the-view))
-                SAMPLES  TOTAL     MINIMUM   MAXIMUM   MEDIAN    AVERAGE   DEVIATION  
REAL-TIME        100      0         0         0         0         0         0.0        
RUN-TIME         100      0         0         0         0         0         0.0        
USER-RUN-TIME    100      0.000308  0.000001  0.00012   0.000002  0.000003  0.000012   
SYSTEM-RUN-TIME  100      0.000117  0.000001  0.000002  0.000001  0.000001  0.0        
PAGE-FAULTS      100      0         0         0         0         0         0.0        
GC-RUN-TIME      100      0         0         0         0         0         0.0        
BYTES-CONSED     100      98240     0         65536     0         982.4     7258.1045  
EVAL-CALLS       100      0         0         0         0         0         0.0        
SQL-QUERIES      100      600       6         6         6         6         0.0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;trivial-benchmark&lt;/code&gt; is not as accurate as &lt;code&gt;the-cost-of-nothing&lt;/code&gt; because it does not count the overhead, but overhead can be significant because &lt;code&gt;trivial-benchmark&lt;/code&gt; uses generic functions.&lt;/p&gt;
&lt;p&gt;Also when sampling, the &lt;code&gt;trivial-benchmark&lt;/code&gt; executes the form only once. That is why the measurements for a very fast code will be even more inaccurate.&lt;/p&gt;
&lt;p&gt;Another interesting feature is the ability to define benchmark suites to measure performance regression of some parts of your code. I won&apos;t show you an example of such a suite. Just go and read nice documentation, written by @Shinmera:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Shinmera/trivial-benchmark#benchmark-suites&quot;&gt;https://github.com/Shinmera/trivial-benchmark#benchmark-suites&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Sun, 12 Jul 2020 23:11:25 +0300</pubDate>
        </item>
        <item>
            <title>chameleon</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0127-chameleon.html</link>
            <description>&lt;p&gt;Chameleon is a configuration management library. It allows us to define a bunch of options and their values for different profiles. After that, you can switch between profiles.&lt;/p&gt;
&lt;p&gt;It works like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (chameleon:defconfig
             (port 8000 &amp;quot;Port to listen on&amp;quot;)
             (log-level :info &amp;quot;The log level for log4cl&amp;quot;))

POFTHEDAY&amp;gt; (chameleon:defprofile :dev)

POFTHEDAY&amp;gt; (chameleon:defprofile :production
             (port 80)
             (log-level :warn))

POFTHEDAY&amp;gt; (setf (active-profile) :production)
:PRODUCTION
POFTHEDAY&amp;gt; (port)
80

POFTHEDAY&amp;gt; (log-level)
:WARN

POFTHEDAY&amp;gt; (active-profile)
:PRODUCTION

;; Now switching to development mode:
POFTHEDAY&amp;gt; (setf (active-profile) :dev)
:DEV

POFTHEDAY&amp;gt; (port)
8000

POFTHEDAY&amp;gt; (log-level)
:INFO&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I&apos;ve investigated the &lt;code&gt;chameleon&apos;s&lt;/code&gt; code and think it can be made better and simpler using &lt;code&gt;CLOS&lt;/code&gt; instances for profiles instead of hash maps.&lt;/p&gt;
&lt;p&gt;If you know other Lisp systems for configuration management, please, let me know.&lt;/p&gt;
</description>
            <pubDate>Sat, 11 Jul 2020 21:23:05 +0300</pubDate>
        </item>
        <item>
            <title>with-output-to-stream</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0126-with-output-to-stream.html</link>
            <description>&lt;p&gt;This is a &quot;trivial&quot; library by &lt;a href=&quot;https://twitter.com/HexstreamSoft&quot;&gt;@HexstreamSoft&lt;/a&gt;. It simplifies the writing of the functions which would like to accept a stream argument as &lt;code&gt;format&lt;/code&gt; function does.&lt;/p&gt;
&lt;p&gt;CL&apos;s &lt;code&gt;format&lt;/code&gt; function accepts as the first parameter a &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt; or a stream object. In first case it returns a string and in second - outputs to &lt;code&gt;*standard-output*&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When you are writing a custom function with similar semantics, you have to handle all these cases by hand. Here is where &lt;code&gt;with-output-to-stream&lt;/code&gt; helps you:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun log-info (obj &amp;amp;key (stream t))
             (with-output-to-stream:with-output-to-stream (s stream)
               (write-string &amp;quot;INFO &amp;quot; s)
               (write obj :stream s)
               (terpri s)))

;; Here is we return result as a string:
POFTHEDAY&amp;gt; (log-info 100500 :stream nil)
&amp;quot;INFO 100500
&amp;quot;

;; This will output to *standard-output*:
POFTHEDAY&amp;gt; (log-info 100500 :stream t)
INFO 100500
NIL

;; But you can pass any stream as the argument:
POFTHEDAY&amp;gt; (log-info 100500 :stream *error-output*)
INFO 100500
NIL

POFTHEDAY&amp;gt; (with-output-to-string (s)
             (log-info 100500 :stream s)
             (log-info 42 :stream s))
&amp;quot;INFO 100500
INFO 42
&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it for today.&lt;/p&gt;
</description>
            <pubDate>Fri, 10 Jul 2020 20:41:09 +0300</pubDate>
        </item>
        <item>
            <title>lisp-critic</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0125-lisp-critic.html</link>
            <description>&lt;p&gt;A few weeks ago, &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0097-sblint.html&quot;&gt;I&apos;ve reviewed&lt;/a&gt; the &lt;code&gt;sblint&lt;/code&gt; - a tool to check code quality in terms of warnings from the SBCL compiler. &lt;code&gt;Lisp-critic&lt;/code&gt; is another kind of beast. It checks the code quality in terms of common patterns and idioms.&lt;/p&gt;
&lt;p&gt;For example, it outputs warning when there is only one subform inside the &lt;code&gt;progn&lt;/code&gt; or if you are setting global variables in the function definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lisp-critic:critique
            (progn
              (format t &amp;quot;Hello World!&amp;quot;)))
----------------------------------
Why do you think you need a PROGN?
----------------------------------

POFTHEDAY&amp;gt; (lisp-critic:critique
            (defun start-server ()
              (setf *server*
                    (listen-on :port 8080))
              (values)))
----------------------------------------------------
GLOBALS!! Don&amp;#039;t use global variables, i.e., *SERVER*
----------------------------------------------------&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Lisp-critic&lt;/code&gt; operates on patterns. There are &lt;a href=&quot;https://github.com/g000001/lisp-critic/blob/master/lisp-rules.lisp&quot;&gt;109 built-in patterns&lt;/a&gt; and you can define more:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (length (lisp-critic:get-pattern-names))
109

POFTHEDAY&amp;gt; (rutils:take 10
             (lisp-critic:get-pattern-names))
(LISP-CRITIC::?-FOR-PREDICATE
 LISP-CRITIC::ADD-ZERO
 LISP-CRITIC::APPEND-LIST-LIST
 LISP-CRITIC::APPEND-LIST-LOOP
 LISP-CRITIC::APPEND-LIST-RECURSION
 LISP-CRITIC::APPEND-LIST2-LIST
 LISP-CRITIC::APPLY-FOR-FUNCALL
 LISP-CRITIC::CAR-CDR
 LISP-CRITIC::CONCATENATE-LIST
 LISP-CRITIC::COND-&amp;gt;OR)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you can use &lt;code&gt;lisp-critic:critique-file&lt;/code&gt; to analyze all top-level forms in a file.&lt;/p&gt;
&lt;p&gt;It would be nice to:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;add a command-line tool (like sblint) to check all files in the   project;&lt;/li&gt;&lt;li&gt;to add the ability to ignore some checks for some forms. Probably &lt;code&gt;declaim&lt;/code&gt;   could be used for this purpose?&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Probably adding an integration with SLIME or SLY would also be a good idea.&lt;/p&gt;
&lt;p&gt;This way you&apos;ll be able to hit some shortcuts to receive recommendations from Lisp Critic, or it could happen when you are evaluating a top-level form.&lt;/p&gt;
</description>
            <pubDate>Thu, 09 Jul 2020 23:29:31 +0300</pubDate>
        </item>
        <item>
            <title>cl-spark</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0124-cl-spark.html</link>
            <description>&lt;p&gt;This small utility has nothing common with &lt;a href=&quot;https://spark.apache.org/&quot;&gt;Apache Spark&lt;/a&gt; and big data processing. However, it relates to data plotting.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cl-spark&lt;/code&gt; allows you to visualize data in the console like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(1 0 1 0))
&amp;quot;&amp;#x2588;&amp;#x2581;&amp;#x2588;&amp;#x2581;&amp;quot;

POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(1 1 2 3 5 8))
&amp;quot;&amp;#x2581;&amp;#x2581;&amp;#x2582;&amp;#x2583;&amp;#x2585;&amp;#x2588;&amp;quot;


POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(0 30 55 80 33 150))
&amp;quot;&amp;#x2581;&amp;#x2582;&amp;#x2583;&amp;#x2584;&amp;#x2582;&amp;#x2588;&amp;quot;

POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(0 30 55 80 33 150)
                           :min -100)
&amp;quot;&amp;#x2583;&amp;#x2584;&amp;#x2585;&amp;#x2586;&amp;#x2584;&amp;#x2588;&amp;quot;
POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(0 30 55 80 33 150)
                           :max 50)
&amp;quot;&amp;#x2581;&amp;#x2585;&amp;#x2588;&amp;#x2588;&amp;#x2585;&amp;#x2588;&amp;quot;
POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(0 30 55 80 33 150)
                           :min 30
                           :max 80)
&amp;quot;&amp;#x2581;&amp;#x2581;&amp;#x2584;&amp;#x2588;&amp;#x2581;&amp;#x2588;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-spark:spark
            &amp;#039;(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14)
            :key (lambda (x)
                   (sin (* x pi 1/4))))
&amp;quot;&amp;#x2584;&amp;#x2586;&amp;#x2588;&amp;#x2586;&amp;#x2584;&amp;#x2582;&amp;#x2581;&amp;#x2582;&amp;#x2584;&amp;#x2586;&amp;#x2588;&amp;#x2586;&amp;#x2584;&amp;#x2582;&amp;#x2581;&amp;quot;


POFTHEDAY&amp;gt; (cl-spark:vspark
            &amp;#039;(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14)
            :key (lambda (x)
                   (sin (* x pi 1/4)))
            :size 20)
&amp;quot;
-1.0     0.0     1.0
&amp;#x2EB;--------+---------&amp;#x2E7;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2589;
&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2589;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2589;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2589;
&amp;#x258F;
&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It&apos;s repository has a lot more examples. Check it out:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tkych/cl-spark&quot;&gt;https://github.com/tkych/cl-spark&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Wed, 08 Jul 2020 20:57:12 +0300</pubDate>
        </item>
        <item>
            <title>cl-coveralls</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0123-cl-coveralls.html</link>
            <description>&lt;p&gt;I hope, you are writing unit tests for your program. And if you do, then it is really helpful to know which code is covered by tests and which does not.&lt;/p&gt;
&lt;p&gt;Did you know that some CL implementation has tools for measuring code coverage?&lt;/p&gt;
&lt;p&gt;For example, SBCL has a package &lt;a href=&quot;http://www.sbcl.org/manual/#sb_002dcover&quot;&gt;sb-cover&lt;/a&gt;. To create a coverage report you need to turn instrumentation on, recompile the program, run tests and generate the report.&lt;/p&gt;
&lt;p&gt;This is the code from SBCL&apos;s manual:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(declaim (optimize sb-cover:store-coverage-data))

;;; Load some code, ensuring that it&amp;#039;s recompiled
;;; with correct optimization policy.
(asdf:oos &amp;#039;asdf:load-op :cl-ppcre-test :force t)

;;; Run the test suite.
(cl-ppcre-test:test)

;;; Produce a coverage report
(sb-cover:report &amp;quot;/tmp/report/&amp;quot;)

;;; Turn off instrumentation
(declaim (optimize (sb-cover:store-coverage-data 0)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here are few screenshots of HTML pages I&apos;ve got running &lt;code&gt;sb-cover&lt;/code&gt; against Ultralisp&apos;s code:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0123/file-list.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0123/covered-code.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;But today we are talking about cl-coveralls. It helps to build coverage measuring into your CI pipeline. I decided that it is a great moment to add make it check Ultralisp&apos;s code.&lt;/p&gt;
&lt;p&gt;What do you need to collect coverage data of Common Lisp project? Well, you need:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;to set up a CI pipeline on Travis or CircleCI.&lt;/li&gt;&lt;li&gt;register at &lt;a href=&quot;https://coveralls.io/&quot;&gt;https://coveralls.io/&lt;/a&gt; and enable it for your GitHub   repository.&lt;/li&gt;&lt;li&gt;set two environment variables in the CI&apos;s config.&lt;/li&gt;&lt;li&gt;wrap code with a call to coveralls:with-coveralls &lt;a href=&quot;https://github.com/ultralisp/ultralisp/commit/1162659cceb038d3285679c07c5c1440e58e779f#diff-1d37e48f9ceff6d8030570cd36286a61R42&quot;&gt;like that&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Here is &lt;a href=&quot;https://github.com/ultralisp/ultralisp/commit/1162659cceb038d3285679c07c5c1440e58e779f&quot;&gt;the diff, required to enable code coverage&lt;/a&gt; measurement for Ultralisp&apos;s tests. And now Coveralls will track if code coverage was improved with each pull-request.&lt;/p&gt;
</description>
            <pubDate>Tue, 07 Jul 2020 22:29:09 +0300</pubDate>
        </item>
        <item>
            <title>path-parse</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0122-path-parse.html</link>
            <description>&lt;p&gt;This is a small utility library by Fernando Borretti. The only function it has is &lt;code&gt;PATH&lt;/code&gt; variable parsing. But it does it really well.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Path-parse&lt;/code&gt; works on Windows and Unix (OSX):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (path-parse:path)

(#P&amp;quot;/Users/art/.roswell/bin/&amp;quot;
 #P&amp;quot;/Users/art/.bin/&amp;quot;
 #P&amp;quot;/Users/art/.dotfiles/bin/&amp;quot;
 #P&amp;quot;/usr/local/bin/&amp;quot;
 #P&amp;quot;/usr/bin/&amp;quot;
 #P&amp;quot;/bin/&amp;quot;
 #P&amp;quot;/usr/sbin/&amp;quot;
 #P&amp;quot;/sbin/&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it for today. Tomorrow I&apos;ll try to find something more interesting!&lt;/p&gt;
</description>
            <pubDate>Mon, 06 Jul 2020 21:06:02 +0300</pubDate>
        </item>
        <item>
            <title>cl-skip-list</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0121-cl-skip-list.html</link>
            <description>&lt;p&gt;I found this library a few weeks ago. It implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Skip_list&quot;&gt;Skip List&lt;/a&gt; data structure. Which is a lock-free and has &lt;code&gt;O(log n)&lt;/code&gt; for lookup, insert and delete operations.&lt;/p&gt;
&lt;p&gt;I wondered if this library will have a better performance in situation when you have to access a dictionary from multiple threads?&lt;/p&gt;
&lt;p&gt;Here is a simple benchmark. We ll create 10 threads and do 10 millions lookup of a value in the dictionary filled by 6600 symbols from the keywords package.&lt;/p&gt;
&lt;p&gt;I&apos;m testing on SBCL 2.0.2 with &lt;code&gt;(declaim (optimize (debug 1) (speed 3)))&lt;/code&gt; options running on the Macbook with 12 cores.&lt;/p&gt;
&lt;p&gt;Let&apos;s run this benchmark using a standard Common Lisp hash table and a lock:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((hash (make-hash-table))
                 (lock (bt:make-lock))
                 (num-operations 10000000)
                 (num-threads 10))
             (do-external-symbols (s :keyword)
               (setf (gethash s hash)
                     (symbol-name s)))
             (setf (gethash :foo hash)
                   &amp;quot;FOO&amp;quot;)
             ;; Now it is time to define a worker function
             (flet ((worker ()
                      (loop with result = nil
                            repeat num-operations
                            do (bt:with-lock-held (lock)
                                 (setf result
                                       (gethash :foo hash)))
                            finally (return result))))
               ;; We&amp;#039;ll create N workers and measure a total time required to finish them all
               (let* ((started-at (get-internal-real-time))
                      (workers (loop repeat num-threads
                                     collect (bt:make-thread #&amp;#039;worker))))
                 (loop for worker in workers
                       do (bt:join-thread worker))
                 ;; Calculate the total time
                 (/ (- (get-internal-real-time) started-at)
                    internal-time-units-per-second))))
2399/100 (23.99)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And now a lock free version using cl-skip-list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((hash (cl-skip-list:make-skip-list :key-equal #&amp;#039;eql))
                 (num-operations 10000000)
                 (num-threads 10))
             (do-external-symbols (s :keyword)
               (cl-skip-list:skip-list-add hash
                                           s
                                           (symbol-name s)))
             (unless (cl-skip-list:skip-list-lookup hash :foo)
               (cl-skip-list:skip-list-add hash
                                           :foo
                                           &amp;quot;FOO&amp;quot;))
             ;; Now it is time to define a worker function
             (flet ((worker ()
                      (loop with result = nil
                            repeat num-operations
                            do (setf result
                                     (cl-skip-list:skip-list-lookup hash :foo))
                            finally (return result))))
               ;; We&amp;#039;ll create N workers and measure a total time required to finish them all
               (let* ((started-at (get-internal-real-time))
                      (workers (loop repeat num-threads
                                     collect (bt:make-thread #&amp;#039;worker))))
                 (loop for worker in workers
                       do (bt:join-thread worker))
                 ;; Calculate the total time
                 (/ (- (get-internal-real-time) started-at)
                    internal-time-units-per-second))))
45799/1000 (45.799)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you see, the version with a lock is twice faster: 46 seconds against 24.&lt;/p&gt;
&lt;p&gt;Are there any reasons to use a lock-free data structure if it does not get you any speed gains?&lt;/p&gt;
</description>
            <pubDate>Sun, 05 Jul 2020 12:39:11 +0300</pubDate>
        </item>
        <item>
            <title>make-hash</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0120-make-hash.html</link>
            <description>&lt;p&gt;This is the most comprehensive library for making hash tables I&apos;ve already seen! And it has wonderful documentation with lots of examples!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make-hash&lt;/code&gt; allows to create hash tables in multiple ways, from different kinds of data structures and even using functions for data transformation. For example, you can create a hash by reading rows from the database.&lt;/p&gt;
&lt;p&gt;I&apos;ll show you only a few examples I especially liked.&lt;/p&gt;
&lt;p&gt;First one is creation hash from a sequence while counting each item. Using this, we can easily count how many times each character is used in a text:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (make-hash:make-hash
            :init-format :keybag
            :initial-contents &amp;quot;Alice loves Bob&amp;quot;)
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 11 {1008943083}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-hash-table *)
#{
  #\A 1
  #\l 2
  #\i 1
  #\c 1
  #\e 2
  #\  2
  #\o 2
  #\v 1
  #\s 1
  #\B 1
  #\b 1
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the next example, we&apos;ll make a smaller hash table from another one while selecting data by keys:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((full-data
                   (make-hash:make-hash
                    :initial-contents
                    &amp;#039;(:foo 1
                      :bar 2
                      :bazz 3
                      :blah 4
                      :minor 5))))
             (make-hash:make-hash
              :init-format :keys
              :init-data full-data
              :initial-contents &amp;#039;(:bar :minor)))
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 2 {10060F6123}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-hash-table *)
#{
   :BAR 2
   :MINOR 5
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And here is how we can build a hash from a data returned by a function. We only need a closure which will return rows of data as values and will return nil at the end.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun make-rows-iterator ()
             ;; This list will allow us to simulate
             ;; the data storage:
             (let ((rows &amp;#039;((bob 42)
                           (alice 25)
                           (mike 30)
                           (julia 27))))
               (lambda ()
                 (let ((row (car rows)))
                   (setf rows
                         (cdr rows))
                   (values (first row) ;; This is a key
                           (second row))))))

POFTHEDAY&amp;gt; (make-hash:make-hash
            :init-format :function
            :initial-contents (make-rows-iterator))
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 4 {10086FF8E3}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-hash-table *)
#{
  BOB 42
  ALICE 25
  MIKE 30
  JULIA 27
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;make-hash&lt;/code&gt; also provides a configurable reader macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(install-hash-reader ())  ; default settings and options
#{:a 1 :b 2 :c 3 :d 4}   
       

(install-hash-reader &amp;#039;(:init-format :pairs)
  :use-dispatch t
  :open-char #\[ :close-char #\])
#[&amp;#039;(:a . 1) &amp;#039;(:b . 2) &amp;#039;(:c . 3) &amp;#039;(:d . 4)] 
       

(install-hash-reader &amp;#039;(:init-format :lists)
  :use-dispatch nil
  :open-char #\{ :close-char #\})
{&amp;#039;(:a 1) &amp;#039;(:b 2) &amp;#039;(:c 3) &amp;#039;(:d 4)}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You will find more examples and instructions on how to define your own initialization formats in the library&apos;s documentation:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/genovese/make-hash&quot;&gt;https://github.com/genovese/make-hash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let&apos;s thank the #poftheday challenge for the chance to discover such cool Common Lisp library!&lt;/p&gt;
</description>
            <pubDate>Sat, 04 Jul 2020 23:15:08 +0300</pubDate>
        </item>
        <item>
            <title>bourbaki</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0119-bourbaki.html</link>
            <description>&lt;p&gt;This is the system for verifying formal mathematical proofs. As I didn&apos;t use math since the high school and lack time to dive into the lengthy documentation :(&lt;/p&gt;
&lt;p&gt;Here is the code snippet from the example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Declare the wff type
(symkind &amp;quot;WFF&amp;quot;)

;; The implication symbol
(prim wff &amp;quot;-&amp;gt;&amp;quot; (wff ![x y]))

;; the axioms
(ax &amp;quot;ax1&amp;quot; (wff ![A B])
  (ass [-&amp;gt; A -&amp;gt; B A]))
(ax &amp;quot;ax2&amp;quot; (wff ![A B C])
  (ass [-&amp;gt; -&amp;gt; A -&amp;gt; B C -&amp;gt; -&amp;gt; A B -&amp;gt; A C]))

;; the rule of inference (modus ponens)
(ax &amp;quot;ax-mp&amp;quot; (wff ![A B])
  (hypo [A] [-&amp;gt; A B])
  (ass [B]))

;; theorem: identity law for &amp;#039;-&amp;gt;&amp;#039;
;; compare with id1 in set.mm
(th &amp;quot;id&amp;quot; (wff &amp;quot;A&amp;quot;)
  (ass [-&amp;gt; A A])
  (proof
    [ax1 A [-&amp;gt; A A]]
    [ax2 A [-&amp;gt; A A] A]
    [ax-mp [-&amp;gt; A -&amp;gt; -&amp;gt; A A A]
           [-&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]]
    [ax1 A A]
    [ax-mp [-&amp;gt; A -&amp;gt; A A] [-&amp;gt; A A]]))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you eval it in the &lt;code&gt;REPL&lt;/code&gt;, then you can verify it and output some information:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;BOURBAKI-USER&amp;gt; (print-theorem !id)
Theorem id:
Variables: A
Distinct variable conditions: 
Hypotheses: 
Assertion: [-&amp;gt; A A]
Proof:
ax1 [A][-&amp;gt; A A]
ax2 [A][-&amp;gt; A A][A]
ax-mp [-&amp;gt; A -&amp;gt; -&amp;gt; A A A][-&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]
ax1 [A][A]
ax-mp [-&amp;gt; A -&amp;gt; A A][-&amp;gt; A A]

BOURBAKI-USER&amp;gt; (show-proof !id)
Proof for id:
ax1 =&amp;gt; [-&amp;gt; A -&amp;gt; -&amp;gt; A A A]
ax2 =&amp;gt; [-&amp;gt; -&amp;gt; A -&amp;gt; -&amp;gt; A A A -&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]
ax-mp =&amp;gt; [-&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]
ax1 =&amp;gt; [-&amp;gt; A -&amp;gt; A A]
ax-mp =&amp;gt; [-&amp;gt; A A]

BOURBAKI-USER&amp;gt; (verify !id)
Theorem: &amp;quot;ax1&amp;quot;
Theorem: &amp;quot;ax2&amp;quot;
Theorem: &amp;quot;ax-mp&amp;quot;
Theorem: &amp;quot;id&amp;quot;
T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Bourbaki has a very good documentation. If you are interested in math libraries and don&apos;t know how to spend this weekend - enjoy it:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.quicklisp.org/beta/UNOFFICIAL/docs/bourbaki/doc/bourbaki-3.7.pdf&quot;&gt;https://www.quicklisp.org/beta/UNOFFICIAL/docs/bourbaki/doc/bourbaki-3.7.pdf&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Fri, 03 Jul 2020 21:52:13 +0300</pubDate>
        </item>
        <item>
            <title>cl-tui</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0118-cl-tui.html</link>
            <description>&lt;p&gt;This system is an experimental user interface library for the console. It uses &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0061-cl-charms.html&quot;&gt;cl-charms&lt;/a&gt; under the hood, to call &lt;code&gt;ncurses&lt;/code&gt;. The library is not in Quicklisp yet but is installable from &lt;a href=&quot;https://ultralisp.org&quot;&gt;https://ultralisp.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It contains a few examples. I&apos;ve modified one to implement a simple chat-like interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;text&apos;&gt;&amp;#x250C;&amp;#x2500;&amp;#x2500;Online&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2510;
&amp;#x2502;Bob               &amp;#x2502;
&amp;#x2502;Alice             &amp;#x2502;
&amp;#x2502;Peter             &amp;#x2502;
&amp;#x2502;Lisper 313373     &amp;#x2502;23:08:46 Enter some text.
&amp;#x2502;                  &amp;#x2502;23:08:46 Esc to quit
&amp;#x2502;                  &amp;#x2502;23:08:52 Hello Lisp World!
&amp;#x2502;                  &amp;#x2502;23:09:05 This is a simple chat using
&amp;#x2502;                  &amp;#x2502;23:09:16 cl-tui and charms.
&amp;#x2514;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2518;&amp;gt; Input box&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;cl-tui&lt;/code&gt; allows defining frames which can be stacked together. And you can write text inside the frame. Hope, there will be more primitives for other GUI elements like buttons text inputs, forms etc.&lt;/p&gt;
&lt;p&gt;Here are pieces of the example. First, I defined a &quot;roster&quot; and a function to render it inside a frame. This function also draws a border around:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defvar *roster* &amp;#039;(&amp;quot;Bob&amp;quot;
                   &amp;quot;Alice&amp;quot;
                   &amp;quot;Peter&amp;quot;
                   &amp;quot;Lisper 313373&amp;quot;))

(defun draw-roster (&amp;amp;key frame)
  (draw-box frame)
  (put-text frame 0 3 &amp;quot;Online&amp;quot;)
  
  (loop for name in *roster*
        for row upfrom 1
        do (put-text frame row 1 name)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next part is the code defining the application&apos;s layout. It is constructed from nested frames of different types. There is a frame for our roster, a frame to display chat log and to get user&apos;s input:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(define-frame main (container-frame :split-type :horizontal) :on :root)

(define-frame roster (simple-frame :render #&amp;#039;draw-roster) :on main :w 20)

(define-frame chat (container-frame :split-type :vertical) :on main)

(define-frame log (log-frame) :on chat)

;; Edit-frame implements a single-line text editor.
;; It will misbehave if its height is not 1.
(define-frame input (edit-frame :prompt &amp;quot;&amp;gt; &amp;quot;) :on chat :h 1)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We also need two functions to add users input into the chat window and to process keystrokes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defun finish-input ()
  ;; Get text from edit-frame
  (let ((text (get-text &amp;#039;input)))
    ;; Append it to the log-frame
    (append-line &amp;#039;log text)
    ;; And clear the text in edit-frame
    (clear-text &amp;#039;input)))


(defun start ()
  (with-screen ()
    (append-line &amp;#039;log &amp;quot;Enter some text.&amp;quot;)
    (append-line &amp;#039;log &amp;quot;Esc to quit&amp;quot;)
    (loop
      (refresh)
      (let ((key (read-key)))
        (case key
          ;; Esc and Newline are handled here
          (#\Esc (return))
          (#\Newline (finish-input))
          (:key-up (cl-tui:scroll-log &amp;#039;log 1))
          (:key-down (cl-tui:scroll-log &amp;#039;log -1))
          ;; Everything else is sent to the edit-frame.
          (t (handle-key &amp;#039;input key)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is all the app.&lt;/p&gt;
&lt;p&gt;Checkout &lt;a href=&quot;https://github.com/naryl/cl-tui&quot;&gt;the repository&lt;/a&gt;. There you&apos;ll find more examples!&lt;/p&gt;
&lt;p&gt;For those, who are interested in using &lt;code&gt;ncurses&lt;/code&gt;, here are reviews of the two lower-level libraries:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0059-cl-ncurses.html&quot;&gt;cl-ncurses&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0061-cl-charms.html&quot;&gt;cl-charms&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
            <pubDate>Thu, 02 Jul 2020 23:21:18 +0300</pubDate>
        </item>
        <item>
            <title>clack-pretend</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0117-clack-pretend.html</link>
            <description>&lt;p&gt;This is the last middleware in our Clack/Lack series. What does it do? It helps during website development remembering last requests you did from the browser and allowing to replay them from the REPL.&lt;/p&gt;
&lt;p&gt;Clack-pretend interposes itself into a Lack middlewares chain. To define the app you need to use a special builder macro and to specify at which point requests and responses should be captured:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (clack-pretend:pretend-builder (:insert 2)
               :accesslog
               :session
               (lambda (env)
                 (let* ((path (getf env :path-info))
                        (query (getf env :query-string))
                        (message (format nil &amp;quot;Path: ~A, query: ~A&amp;quot;
                                         path query)))
                   (format t &amp;quot;Processing request:~%  ~A~%&amp;quot;
                           message)
                   &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                     (&amp;quot;Hello world!&amp;quot;))))))
*APP*
POFTHEDAY&amp;gt; (defparameter *server*
             (clack:clackup *app*
                            :port 8000))
Hunchentoot server is started.
Listening on 127.0.0.1:8000.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now I&apos;ll make a request using &lt;code&gt;curl&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[poftheday] curl -v &amp;#039;http://localhost:8000/some/route?foo=Bar&amp;#039;
&amp;gt; GET /some/route?foo=Bar HTTP/1.1
&amp;gt; Host: localhost:8000
&amp;gt; User-Agent: curl/7.54.0
&amp;gt; Accept: */*
&amp;gt; 
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Date: Wed, 01 Jul 2020 19:23:12 GMT
&amp;lt; Server: Hunchentoot 1.2.38
&amp;lt; Transfer-Encoding: chunked
&amp;lt; Content-Type: text/plain
&amp;lt; Set-Cookie: lack.session=0d629e3a1d2681d99c40f7b2086ec97d53e2b884; path=/; expires=Sat, 31 Dec 2140 14:45:27 GMT&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And we can look up what was the last request:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack-pretend:last-input)
(:LACK.SESSION.OPTIONS
 (:ID &amp;quot;0d629e3a1d2681d99c40f7b2086ec97d53e2b884&amp;quot;
  :NEW-SESSION T :CHANGE-ID NIL :EXPIRE NIL)
 :LACK.SESSION #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 0 {1005EB8A03}&amp;gt;
 :REQUEST-METHOD :GET
 :SCRIPT-NAME &amp;quot;&amp;quot;
 :PATH-INFO &amp;quot;/some/route&amp;quot;
 :SERVER-NAME &amp;quot;localhost&amp;quot;
 :SERVER-PORT 8000
 :SERVER-PROTOCOL :HTTP/1.1
 :REQUEST-URI &amp;quot;/some/route?foo=Bar&amp;quot;
 :URL-SCHEME &amp;quot;http&amp;quot;
 :REMOTE-ADDR &amp;quot;127.0.0.1&amp;quot;
 :REMOTE-PORT 53671
 :QUERY-STRING &amp;quot;foo=Bar&amp;quot;
 :RAW-BODY #&amp;lt;FLEXI-STREAMS:FLEXI-IO-STREAM {1005EB6FD3}&amp;gt;
 :CONTENT-LENGTH NIL
 :CONTENT-TYPE NIL
 :CLACK.STREAMING T
 :CLACK.IO #&amp;lt;CLACK.HANDLER.HUNCHENTOOT::CLIENT {1005EB7043}&amp;gt;
 :HEADERS #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 3 {1005EB72C3}&amp;gt;
 :QUERY-PARAMETERS ((&amp;quot;foo&amp;quot; . &amp;quot;Bar&amp;quot;)))

POFTHEDAY&amp;gt; (rutils:hash-table-to-alist
            (getf * :headers))
((&amp;quot;host&amp;quot; . &amp;quot;localhost:8000&amp;quot;)
 (&amp;quot;user-agent&amp;quot; . &amp;quot;curl/7.54.0&amp;quot;)
 (&amp;quot;accept&amp;quot; . &amp;quot;*/*&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now it is time to replay the request from the REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack-pretend:run-pretend)
Processing request:
  Path: /some/route, query: foo=Bar
(200 (:CONTENT-TYPE &amp;quot;text/plain&amp;quot;) (&amp;quot;Hello world!&amp;quot;))

;; You can override path to check, it with the same
;; headers and session:
POFTHEDAY&amp;gt; (clack-pretend:run-pretend
            :path-info &amp;quot;/other/path&amp;quot;)
Processing request:
  Path: /other/path, query: foo=Bar
(200 (:CONTENT-TYPE &amp;quot;text/plain&amp;quot;) (&amp;quot;Hello world!&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Seems, &lt;code&gt;clack-pretend&lt;/code&gt; is a great addition for web development with Clack.&lt;/p&gt;
&lt;p&gt;It will be interesting to improve it to store not only the last N successful requests but also to store requests resulting unhandled error. This way you&apos;ll be able to replay errors your users experience in production!&lt;/p&gt;
</description>
            <pubDate>Wed, 01 Jul 2020 22:32:39 +0300</pubDate>
        </item>
        <item>
            <title>clack-static-asset-middleware</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0115-clack-static-asset-middleware.html</link>
            <description>&lt;p&gt;This middleware in some sense like a builtin &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0110-lack-middleware-static.html&quot;&gt;lack-middleware-static&lt;/a&gt;, reviewed last week.&lt;/p&gt;
&lt;p&gt;The difference is that this middleware is more suitable for production because implements an infinite cache TTL for static assets.&lt;/p&gt;
&lt;p&gt;An infinite cache TTL trick is useful when you want to speed up your website loading. Here is how it works.&lt;/p&gt;
&lt;p&gt;Your server returns &lt;code&gt;Cache-Control&lt;/code&gt; HTTP header and set static files TTL to some large value like a year to make it cached for a long long period of time.&lt;/p&gt;
&lt;p&gt;But how to expire this cache if you will need to update CSS or JavaScript on your site?&lt;/p&gt;
&lt;p&gt;The only way is to change the URL. This is what &lt;code&gt;lack-middleware-static&lt;/code&gt; does for you. It calculates MD5 hash from the file&apos;s content and makes it a part of the URL.&lt;/p&gt;
&lt;p&gt;When the content of the static file is changed, its URL changed as well. Browser notices that change and reloads the content.&lt;/p&gt;
&lt;p&gt;Middleware provides a special tag for &lt;a href=&quot;https://github.com/mmontone/djula&quot;&gt;Djula&lt;/a&gt; template language. Setting up templates for djula is out of thescope of this post and we&apos;ll use &lt;code&gt;busted-uri-for-path&lt;/code&gt; instead, to create a path to a file including a cache hash.&lt;/p&gt;
&lt;p&gt;First, we need to start our server and configure the middleware. Pay attention to the &lt;code&gt;probe-file&lt;/code&gt; call. Root should be an absolute pathname. With relative pathname, you&apos;ll get a wrong result :(&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (funcall
             clack-static-asset-middleware:*clack-static-asset-middleware*
             (lambda (env)
               (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil
                                   &amp;quot;Access this file: ~A&amp;quot;
                                   (clack-static-asset-middleware:busted-uri-for-path

                                    &amp;quot;site.css&amp;quot;)))))
             :path &amp;quot;static/&amp;quot;
             :root (probe-file &amp;quot;static-files/&amp;quot;))
            :port 9004)
Hunchentoot server is started.
Listening on 127.0.0.1:9004.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can access our index page to get the static&apos;s URL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:9004/&amp;quot;)
&amp;quot;Access this file: /static/site_ebb4fccbf8e0590b0fcf44c3748af88d.css&amp;quot;
200&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pay attention to the file&apos;s suffix. It is an md5 hash from file&apos;s content. This sum is calculated when you start the application. If you&apos;ll change the file, during the next deploy another md5 hash will be generated and browser will reload its content.&lt;/p&gt;
&lt;p&gt;If we&apos;ll access this file, the server will respond with &lt;code&gt;Cache-Control&lt;/code&gt; header and set the TTL to 1 year:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:9004/static/site_ebb4fccbf8e0590b0fcf44c3748af88d.css&amp;quot;)
&amp;quot;body {font-size: 10px;}&amp;quot;
200 (8 bits, #xC8, #o310, #b11001000)
#&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 8 {1001E58473}&amp;gt;
#&amp;lt;QURI.URI.HTTP:URI-HTTP http://localhost:9004/static/site_ebb4fccbf8e0590b0fcf44c3748af88d.css&amp;gt;
#&amp;lt;SB-SYS:FD-STREAM for &amp;quot;socket 127.0.0.1:53729, peer: 127.0.0.1:9004&amp;quot; {1001E37873}&amp;gt;

POFTHEDAY&amp;gt; (rutils:hash-table-to-alist #v56:2)
((&amp;quot;date&amp;quot; . &amp;quot;Tue, 30 Jun 2020 19:39:55 GMT&amp;quot;)
 (&amp;quot;server&amp;quot; . &amp;quot;Hunchentoot 1.3.0&amp;quot;)
 (&amp;quot;accept-ranges&amp;quot; . &amp;quot;bytes&amp;quot;)
 (&amp;quot;last-modified&amp;quot; . &amp;quot;Tue, 30 Jun 2020 19:15:56 GMT&amp;quot;)
 (&amp;quot;vary&amp;quot; . &amp;quot;Accept-Encoding&amp;quot;)
 (&amp;quot;cache-control&amp;quot; . &amp;quot;public, max-age=31556926&amp;quot;)
 (&amp;quot;content-length&amp;quot; . &amp;quot;23&amp;quot;)
 (&amp;quot;content-type&amp;quot; . &amp;quot;text/css; charset=utf-8&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow we&apos;ll review the last Clack&apos;s middleware. I found only 3 of them on the Quicklisp. If you know about other middlewares, let me know and we&apos;ll continue our journey to the world of web development with Clack!&lt;/p&gt;
</description>
            <pubDate>Tue, 30 Jun 2020 22:57:55 +0300</pubDate>
        </item>
        <item>
            <title>clack-errors</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0114-clack-errors.html</link>
            <description>&lt;p&gt;This is the Clack middleware which adds a nicely rendered error page for your website. It pretends to be a clone of the RoR&apos;s &lt;a href=&quot;https://github.com/BetterErrors/better_errors&quot;&gt;better_errors&lt;/a&gt; library but has only a limited number of features.&lt;/p&gt;
&lt;p&gt;Clack-errors is able to show a backtrace and content of the &lt;code&gt;env&lt;/code&gt; variable. But it does not allow you to inspect the variables of stack frames and does not show HTTP headers.&lt;/p&gt;
&lt;p&gt;It has a demo application which can be loaded as &lt;code&gt;:clack-errors-demo&lt;/code&gt; ASDF system.&lt;/p&gt;
&lt;p&gt;If you&apos;ll do a &lt;code&gt;(clack-errors-demo:start)&lt;/code&gt; it will start a webserver on the 8000 port.&lt;/p&gt;
&lt;p&gt;Access the &lt;a href=&quot;http://localhost:8001/error&quot;&gt;http://localhost:8001/error&lt;/a&gt; URL to see the page like this:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0114/clack-errors.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;You can customize the behaviour of the middleware by two options: &lt;code&gt;:debug&lt;/code&gt; and &lt;code&gt;:prod-render&lt;/code&gt;. &lt;code&gt;:debug&lt;/code&gt; is &lt;code&gt;t&lt;/code&gt; by default and if you set it to the &lt;code&gt;nil&lt;/code&gt;, middleware will not show backtrace. It will call &lt;code&gt;:prod-render&lt;/code&gt; function instead.&lt;/p&gt;
&lt;p&gt;Also, you might override some internal variables like &lt;code&gt;+dev-template+&lt;/code&gt;, &lt;code&gt;*dev-css-path*&lt;/code&gt;, etc. But it is better to send a pull-request which will allow redefining dev renderer.&lt;/p&gt;
&lt;p&gt;Personally, I&apos;m don&apos;t see the need in such middleware in the Common Lisp web application, because you have much better backtrace inspection tool in the SLIME or other IDE.&lt;/p&gt;
</description>
            <pubDate>Mon, 29 Jun 2020 21:21:47 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-csrf</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0113-lack-middleware-csrf.html</link>
            <description>&lt;p&gt;This lack middleware provides some level of security for your webapp, preventing a &lt;a href=&quot;https://owasp.org/www-community/attacks/csrf&quot;&gt;CSRF attacks&lt;/a&gt;. It has a function &lt;code&gt;csrf-html-tag&lt;/code&gt; which returns a hidden &lt;code&gt;input&lt;/code&gt; element to embed into a form.&lt;/p&gt;
&lt;p&gt;The input stores a special token. Middleware saves this token into the current session and ensures the user sends this token in the following requests. If he doesn&apos;t, a 400 status code will be returned.&lt;/p&gt;
&lt;p&gt;Let&apos;s take our yesterday&apos;s app and make it more secure!&lt;/p&gt;
&lt;p&gt;First, we need to rewrite our main application to make it render a login form with CSRF token. Pay attention to how does it call a &lt;code&gt;csrf-html-tag&lt;/code&gt; function at the end.&lt;/p&gt;
&lt;p&gt;If you are going to develop an application with a lots of forms, then it is good idea to define a macro which will apply CSRF protection automatically.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun main (env)
             (let* ((session (getf env :lack.session))
                    (login (gethash :login session)))
               (cond
                 (login
                  (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                        (list (format nil &amp;quot;Welcome, ~A!&amp;quot;
                                      login))))
                 (t
                  (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                        (list (format nil &amp;quot;
&amp;lt;form method=\&amp;quot;POST\&amp;quot; action=\&amp;quot;/login\&amp;quot;&amp;gt;
  &amp;lt;input type=\&amp;quot;text\&amp;quot; name=\&amp;quot;login\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  &amp;lt;input type=\&amp;quot;password\&amp;quot; name=\&amp;quot;password\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  ~A
&amp;lt;/form&amp;gt;
&amp;quot;
                          (lack.middleware.csrf:csrf-html-tag session))))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;All other apps remain the same, we only need to build the whole app including the &lt;code&gt;csrf&lt;/code&gt; middleware.&lt;/p&gt;
&lt;p&gt;This middleware should go after the &lt;code&gt;:session&lt;/code&gt; middleware, because it depends on it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             :session
             :csrf
             (:mount &amp;quot;/login&amp;quot; &amp;#039;login)
             (:mount &amp;quot;/logout&amp;quot; &amp;#039;logout)
             &amp;#039;main)
            :port 8091)
Hunchentoot server is started.
Listening on 127.0.0.1:8091.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is how our form is rendered. Note a &quot;hidden&quot; input at the end of the form:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8091/&amp;quot;)
&amp;quot;
&amp;lt;form method=\&amp;quot;POST\&amp;quot; action=\&amp;quot;/login\&amp;quot;&amp;gt;
  &amp;lt;input type=\&amp;quot;text\&amp;quot; name=\&amp;quot;login\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  &amp;lt;input type=\&amp;quot;password\&amp;quot; name=\&amp;quot;password\&amp;quot;&amp;gt;&amp;lt;/input&amp;gt;
  &amp;lt;input type=\&amp;quot;hidden\&amp;quot; name=\&amp;quot;_csrf_token\&amp;quot; value=\&amp;quot;8de1c8a47\&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If we try to do a &lt;code&gt;POST&lt;/code&gt; request without the token, we&apos;ll receive a 400 error:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (handler-case
               (dex:post &amp;quot;http://localhost:8091/login&amp;quot;
                         :content &amp;#039;((&amp;quot;login&amp;quot; . &amp;quot;bob&amp;quot;)
                                    (&amp;quot;password&amp;quot; . &amp;quot;$ecret&amp;quot;))
                         :headers &amp;#039;((:cookie . &amp;quot;lack.session=75bccc&amp;quot;)))
             (dexador:http-request-failed (c)
               (values (dexador:response-status c)
                       (dexador:response-body c))))
400
&amp;quot;Bad Request: invalid CSRF token&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Using the code we&apos;ll be able to log in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:post &amp;quot;http://localhost:8091/login&amp;quot;
                     :content &amp;#039;((&amp;quot;login&amp;quot; . &amp;quot;bob&amp;quot;)
                                (&amp;quot;password&amp;quot; . &amp;quot;$ecret&amp;quot;)
                                (&amp;quot;_csrf_token&amp;quot; . &amp;quot;8de1c8a47&amp;quot;))
                     :headers &amp;#039;((:cookie . &amp;quot;lack.session=75bccc&amp;quot;)))
&amp;quot;Dear Bob, you welcome!&amp;quot;
200&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The middleware also has a few settings.&lt;/p&gt;
&lt;p&gt;You can set &lt;code&gt;:session-key&lt;/code&gt; to a value other than &lt;code&gt;_csrf_token&lt;/code&gt;. But this changes only a token&apos;s key inside the session. Form field&apos;s name remains the &lt;code&gt;_csrf_token&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Other option is &lt;code&gt;:one-time&lt;/code&gt;. Set it to true if you want to remove a token from the session after the first successful &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;PUT&lt;/code&gt;, &lt;code&gt;DELETE&lt;/code&gt; or &lt;code&gt;PATCH&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;And finally, you can define your own handler for the error page and pass it as &quot;:block-app&quot;. It should be a usual Clack app.&lt;/p&gt;
</description>
            <pubDate>Sun, 28 Jun 2020 22:31:02 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-session</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0112-lack-middleware-session.html</link>
            <description>&lt;p&gt;This middleware makes your app stateful and allows to associate some information with the current user.&lt;/p&gt;
&lt;p&gt;There are two abstractions behind Lack sessions - state and store.&lt;/p&gt;
&lt;p&gt;State object defines how to keep track of a session. Lack includes only one type of state class. It keeps state id in the browser&apos;s cookies.&lt;/p&gt;
&lt;p&gt;Store object defines where to store data, associated with a state. There are three store classes in the Lack. The default stores data in memory, using a hash table. There are also &lt;code&gt;dbi&lt;/code&gt; and &lt;code&gt;redis&lt;/code&gt; stores.&lt;/p&gt;
&lt;p&gt;Now let&apos;s create an app that allows a user to login in and logout.&lt;/p&gt;
&lt;p&gt;First, we need an app for logging it checks the password as we did in yesterday&apos;s &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0111-lack-middleware-auth-basic.html&quot;&gt;post on basic auth&lt;/a&gt;. If the password is correct, we&apos;ll put a user&apos;s login into a session&apos;s hash:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun login (env)
             (let* ((params (getf env :body-parameters))
                    (login (alexandria:assoc-value
                            params
                            &amp;quot;login&amp;quot; :test #&amp;#039;string=))
                    (password (alexandria:assoc-value
                               params
                               &amp;quot;password&amp;quot; :test #&amp;#039;string=))
                    (session (getf env
                                   :lack.session)))
               (cond
                 ((and (string= login
                                &amp;quot;bob&amp;quot;)
                       (string= password
                                &amp;quot;$ecret&amp;quot;))
                  (setf (gethash :login
                                 session)
                        login)
                  &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                    (&amp;quot;Dear Bob, you welcome!&amp;quot;)))
                 (t
                  &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                    (&amp;quot;Wrong password!&amp;quot;))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, we need a function to logout. It set&apos;s a special flag to let middleware know that all session data should be wiped from the store:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun logout (env)
             (setf (getf (getf env :lack.session.options)
                         :expire)
                   t)
             &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
               (&amp;quot;Now you are logged our&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The main app will use data from the session and will show a welcome message if the user is authenticated:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun main (env)
             (let* ((session (getf env :lack.session))
                    (login (gethash :login session)))
               (cond
                 (login
                  (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                        (list (format nil &amp;quot;Welcome, ~A!&amp;quot;
                                      login))))
                 (t
                  &amp;#039;(403 (:content-type &amp;quot;text/plain&amp;quot;)
                        (&amp;quot;Access denied&amp;quot;))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally, we need to combine these apps using &lt;code&gt;mount&lt;/code&gt; middleware (it was &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0109-lack-middleware-mount.html&quot;&gt;reviewed a few days ago&lt;/a&gt;) and slap the &lt;code&gt;session&lt;/code&gt; middleware on it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             :session
             (:mount &amp;quot;/login&amp;quot; &amp;#039;login)
             (:mount &amp;quot;/logout&amp;quot; &amp;#039;logout)
             &amp;#039;main)
            :port 8089)
Hunchentoot server is started.
Listening on 127.0.0.1:8089.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s try to log in:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8090/&amp;quot;))
&amp;quot;Access denied&amp;quot;

POFTHEDAY&amp;gt; (multiple-value-bind (response code headers)
               (dex:post &amp;quot;http://localhost:8090/login&amp;quot;
                         :content &amp;#039;((&amp;quot;login&amp;quot; . &amp;quot;bob&amp;quot;)
                                    (&amp;quot;password&amp;quot; . &amp;quot;$ecret&amp;quot;)))
             (values response code
                     (rutils:hash-table-to-alist headers)))
&amp;quot;Dear Bob, you welcome!&amp;quot;
200
((&amp;quot;date&amp;quot; . &amp;quot;Sat, 27 Jun 2020 20:47:13 GMT&amp;quot;)
 (&amp;quot;server&amp;quot; . &amp;quot;Hunchentoot 1.2.38&amp;quot;)
 (&amp;quot;transfer-encoding&amp;quot; . &amp;quot;chunked&amp;quot;)
 (&amp;quot;content-type&amp;quot; . &amp;quot;text/plain&amp;quot;)
 (&amp;quot;set-cookie&amp;quot;
  &amp;quot;lack.session=b10c66; path=/; expires=Fri, 23 Dec 2140 17:24:51 GMT&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The server returned the &quot;set-cookie&quot; header. Usually, the browser will pass this cookie content during the following requests. We&apos;ll emulate this behavior to make a request to the main app:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((headers &amp;#039;((:cookie . &amp;quot;lack.session=b10c66&amp;quot;))))
             (values (dex:get &amp;quot;http://localhost:8090/&amp;quot;
                              :headers headers)))
&amp;quot;Welcome, bob!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And finally, we&apos;ll check how does log out will work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((headers &amp;#039;((:cookie . &amp;quot;lack.session=b10c66&amp;quot;))))
             (values (dex:post &amp;quot;http://localhost:8090/logout&amp;quot;
                               :headers headers)))
&amp;quot;Now you are logged out&amp;quot;

POFTHEDAY&amp;gt; (let ((headers &amp;#039;((:cookie . &amp;quot;lack.session=b10c66&amp;quot;))))
             (dex:get &amp;quot;http://localhost:8090/&amp;quot;
                              :headers headers))
&amp;quot;Access denied&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;See!? We&apos;ve built a simple web application using Lack micro-framework! Add something like Spinneret to render HTML and &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/03/0021-lass.html&quot;&gt;Lass&lt;/a&gt; + &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0071-parenscript.html&quot;&gt;Parenscript&lt;/a&gt; to render CSS and JS and we&apos;ll have a full-fledged webapp!&lt;/p&gt;
</description>
            <pubDate>Sat, 27 Jun 2020 23:59:57 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-auth-basic</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0111-lack-middleware-auth-basic.html</link>
            <description>&lt;p&gt;This Lack middleware is also undocumented, but it is short enough to understand from sources how to configure it.&lt;/p&gt;
&lt;p&gt;When configuring this middleware, you should pass it a function which accepts username and password and returns a &lt;code&gt;t&lt;/code&gt; if the password is correct. Also, this function may return a user object as a second value. Returned user or original username from the HTTP header will be added to the environment plist as &lt;code&gt;:remote-user&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is an example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil
                                   &amp;quot;Hello ~A!&amp;quot;
                                   (getf env :remote-user))))))

POFTHEDAY&amp;gt; (defun auth (user pass)
             (when (and (string= user &amp;quot;bob&amp;quot;)
                        (string= pass &amp;quot;$ecret&amp;quot;))
               (values t
                       &amp;quot;Bob The Admin&amp;quot;)))

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:auth-basic :authenticator #&amp;#039;auth)
             *app*)
            :port 8080)
Hunchentoot server is started.
Listening on 127.0.0.1:8080.

POFTHEDAY&amp;gt; (handler-case (dex:get &amp;quot;http://localhost:8080/foo/bar&amp;quot;)
             (error (condition)
               (values (dex:response-status condition)
                       (dex:response-body condition))))
401 (9 bits, #x191)
&amp;quot;Authorization required&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8080/foo/bar&amp;quot;
                    :basic-auth &amp;#039;(&amp;quot;bob&amp;quot; . &amp;quot;$ecret&amp;quot;))
&amp;quot;Hello Bob The Admin!&amp;quot;
200&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it. Very simple, isn&apos;t it?&lt;/p&gt;
&lt;p&gt;But please, don&apos;t hardcode passwords in the sources as I did :)&lt;/p&gt;
</description>
            <pubDate>Fri, 26 Jun 2020 20:53:29 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-static</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0110-lack-middleware-static.html</link>
            <description>&lt;p&gt;This middleware can be used to serve files from a directory. However, I don&apos;t recommend using it for production because it should be inefficient because a few lambdas are created on each request.&lt;/p&gt;
&lt;p&gt;The middleware should be parametrized with two arguments: &lt;code&gt;path&lt;/code&gt; and &lt;code&gt;root&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;path&lt;/code&gt; is a prefix from the URL. The &lt;code&gt;root&lt;/code&gt; is the root directory on the local filesystem. For example, if &lt;code&gt;root&lt;/code&gt; is &lt;code&gt;/tmp/files/&lt;/code&gt; and &lt;code&gt;path&lt;/code&gt; is &lt;code&gt;/static/&lt;/code&gt; then for URL &lt;code&gt;http://my-site.com/static/some/file.txt&lt;/code&gt; Lack will return content of the &lt;code&gt;/tmp/files/some/file.txt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Here is a small example, showing how does it work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (lambda (env)
               &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                 (&amp;quot;A main app&amp;#039;s response&amp;quot;))))

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:static
              ;; This is a path of URL
              ;; to serve static files
              :path &amp;quot;/static/&amp;quot;
              ;; from this directory
              ;; on the filesystem
              :root #P&amp;quot;./static-files/&amp;quot;)
             *app*)
            :port 8082)
Hunchentoot server is started.
Listening on 127.0.0.1:8082.

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8082/static/the-file.txt&amp;quot;))
&amp;quot;My static file&amp;quot;

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8082/static/missing.txt&amp;quot;))
; Debugger entered on #&amp;lt;DEXADOR.ERROR:HTTP-REQUEST-NOT-FOUND {100B944133}&amp;gt;

POFTHEDAY&amp;gt; (values (dex:get &amp;quot;http://localhost:8082/other/path&amp;quot;))
&amp;quot;A main app&amp;#039;s response&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you can pass a function as a &lt;code&gt;path&lt;/code&gt; argument. This way some sort of filtering may be done. The function should return another path and you probably will need to remove a prefix from it.&lt;/p&gt;
&lt;p&gt;For example, if we want to serve only a &lt;code&gt;css&lt;/code&gt; files from the &lt;code&gt;static-files&lt;/code&gt; directory:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (alexandria:write-string-into-file
            &amp;quot;Some secret README&amp;quot;
            #P&amp;quot;static-files/README.txt&amp;quot;)

POFTHEDAY&amp;gt; (alexandria:write-string-into-file
            &amp;quot;Just CSS file&amp;quot;
            #P&amp;quot;static-files/the.css&amp;quot;)

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:static
              ;; This is a function to filter filename
              ;; of the served static files:
              :path (lambda (original-path)
                      ;; When this function returns nil,
                      ;; the request is passed to the main application.
                      (when (and (str:ends-with-p &amp;quot;.css&amp;quot;
                                                  original-path)
                                 (str:starts-with-p &amp;quot;/static/&amp;quot;
                                                    original-path))
                        ;; you need to rewrite the path manually:
                        (subseq original-path 7)))
              ;; from this directory
              ;; on the filesystem
              :root #P&amp;quot;./static-files/&amp;quot;)
             *app*)
            :port 8085)
Hunchentoot server is started.
Listening on 127.0.0.1:8085.

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8085/static/the.css&amp;quot;)
&amp;quot;Just CSS file&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8085/static/README.txt&amp;quot;)
&amp;quot;A main app&amp;#039;s response&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is no any way to return 404 or 403 error in this case. This should be done on the main app&apos;s level.&lt;/p&gt;
&lt;p&gt;That is it for today. Tomorrow we&apos;ll how to protect your app with basic auth!&lt;/p&gt;
</description>
            <pubDate>Thu, 25 Jun 2020 21:15:21 +0300</pubDate>
        </item>
        <item>
            <title>lack-middleware-mount</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0109-lack-middleware-mount.html</link>
            <description>&lt;p&gt;We continue to review Lack&apos;s middlewares and this one gives you the ability to route requests to different apps depending on the path.&lt;/p&gt;
&lt;p&gt;Here is a quick example. We want to plug a &lt;code&gt;blog&lt;/code&gt; and &lt;code&gt;admin&lt;/code&gt; into our main app:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *main-app*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil &amp;quot;~A~%This is main app!&amp;quot;
                                   (getf env :path-info))))))

POFTHEDAY&amp;gt; (defparameter *blog*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil &amp;quot;~A~%The Blog.&amp;quot;
                                   (getf env :path-info))))))

POFTHEDAY&amp;gt; (defparameter *admin*
             (lambda (env)
               (list 200 &amp;#039;(:content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil &amp;quot;~A~%Administration interface.&amp;quot;
                                   (getf env :path-info))))))

POFTHEDAY&amp;gt; (clack:clackup
            (lack:builder
             (:mount &amp;quot;/blog&amp;quot; *blog*)
             (:mount &amp;quot;/admin&amp;quot; *admin*)
             *main-app*)
            :port 8044)
Hunchentoot server is started.
Listening on 127.0.0.1:8044.

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8044/some/page&amp;quot;)
&amp;quot;/some/page
This is main app!&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8044/blog/post-1&amp;quot;)
&amp;quot;/post-1
The Blog.&amp;quot;

POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:8044/admin/blog/posts?id=1&amp;quot;)
&amp;quot;/blog/posts
Administration interface.&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pay attention to paths, returned as the first line of each response. It is relative to the mount point. This middleware rewrites the path so that an app can be mounted with any prefix.&lt;/p&gt;
&lt;p&gt;That is it for today. Tomorrow we&apos;ll see how we can serve static with Lack.&lt;/p&gt;
</description>
            <pubDate>Wed, 24 Jun 2020 22:50:22 +0300</pubDate>
        </item>
    </channel>
</rss>