<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>jose</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0080-jose.html</link>
            <description>&lt;p&gt;JOSE is an implementation of &lt;a href=&quot;https://datatracker.ietf.org/wg/jose/documents/&quot;&gt;Javascript Object Signing and Encryption&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This &lt;a href=&quot;https://twitter.com/nitro_idiot&quot;&gt;@nitro_idiot&apos;s&lt;/a&gt; library implements a &lt;a href=&quot;https://tools.ietf.org/html/rfc7515&quot;&gt;JSON Web Signature&lt;/a&gt; and allows to encode, decode and inspect JWT tokens.&lt;/p&gt;
&lt;p&gt;JOSE can be useful to implement signed token exchange between microservices.&lt;/p&gt;
&lt;p&gt;I found a &lt;a href=&quot;https://medium.facilelogin.com/jwt-jws-and-jwe-for-not-so-dummies-b63310d201a3&quot;&gt;great article on what JWT, JWS and JWE are&lt;/a&gt;. Read it you want more about them. To demonstrate, how does token inspection work, I took a JWT token from the article and parsed it with Common Lisp JOSE:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (jose/jwt:inspect-token
            &amp;quot;eyJhbGciOiJSUzI1NiIsImtpZCI6Ijc4YjRjZjIzNjU2ZGMzOTUzNjRmMWI2YzAyOTA3NjkxZjJjZGZmZTEifQ.eyJpc3MiOiJhY2NvdW50cy5nb29nbGUuY29tIiwic3ViIjoiMTEwNTAyMjUxMTU4OTIwMTQ3NzMyIiwiYXpwIjoiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiZW1haWwiOiJwcmFiYXRoQHdzbzIuY29tIiwiYXRfaGFzaCI6InpmODZ2TnVsc0xCOGdGYXFSd2R6WWciLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXVkIjoiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiaGQiOiJ3c28yLmNvbSIsImlhdCI6MTQwMTkwODI3MSwiZXhwIjoxNDAxOTEyMTcxfQ.TVKv-pdyvk2gW8sGsCbsnkqsrS0T-H00xnY6ETkIfgIxfotvFn5IwKm3xyBMpy0FFe0Rb5Ht8AEJV6PdWyxz8rMgX2HROWqSo_RfEfUpBb4iOsq4W28KftW5H0IA44VmNZ6zU4YTqPSt4TPhyFC9fP2D_Hg7JQozpQRUfbWTJI&amp;quot;)

((&amp;quot;exp&amp;quot; . 1401912171) (&amp;quot;iat&amp;quot; . 1401908271) (&amp;quot;hd&amp;quot; . &amp;quot;wso2.com&amp;quot;)
 (&amp;quot;aud&amp;quot;
  . &amp;quot;825249835659-te8qgl701kgonnomnp4sqv7erhu1211s.apps.googleusercontent.com&amp;quot;)
 (&amp;quot;email_verified&amp;quot; . T) (&amp;quot;at_hash&amp;quot; . &amp;quot;zf86vNulsLB8gFaqRwdzYg&amp;quot;)
 (&amp;quot;email&amp;quot; . &amp;quot;prabath@wso2.com&amp;quot;)
 (&amp;quot;azp&amp;quot;
  . &amp;quot;825249835659-te8qgl701kgonnomnp4sqv7erhu1211s.apps.googleusercontent.com&amp;quot;)
 (&amp;quot;sub&amp;quot; . &amp;quot;110502251158920147732&amp;quot;) (&amp;quot;iss&amp;quot; . &amp;quot;accounts.google.com&amp;quot;))

((&amp;quot;alg&amp;quot; . &amp;quot;RS256&amp;quot;) (&amp;quot;kid&amp;quot; . &amp;quot;78b4cf23656dc395364f1b6c02907691f2cdffe1&amp;quot;))

#(77 82 175 250 151 114 190 77 160 91 203 6 176 38 236 158 74 172 173 45 19 248
  125 52 198 118 58 17 57 8 126 2 49 126 139 111 22 126 72 192 169 183 199 32
  76 167 45 5 21 237 17 111 145 237 240 1 9 87 163 221 91 44 115 242 179 32 95
  97 209 57 106 146 163 244 95 17 245 41 5 190 34 58 202 184 91 111 10 126 213
  185 31 66 0 227 133 102 53 158 179 83 134 19 168 244 173 225 51 225 200 80
  189 124 253 131 252 120 59 37 10 51 165 4 84 125 181 147 36)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Inspect returns payload, headers and the signature.&lt;/p&gt;
&lt;p&gt;There are also two methods &lt;code&gt;encode&lt;/code&gt; and &lt;code&gt;decode&lt;/code&gt;. Here is how we can use them to issue and verify JWT token:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter
               *secret* (ironclad:ascii-string-to-byte-array
                         &amp;quot;I Love Common Lisp!&amp;quot;))

POFTHEDAY&amp;gt; (defparameter
               *token*
             (jose:encode :hs256 *secret*
                          &amp;#039;((&amp;quot;user&amp;quot;  . &amp;quot;Bob&amp;quot;)
                            (&amp;quot;email&amp;quot; . &amp;quot;bob@gmail.com&amp;quot;))))

;; Now this token can be sent to the authenticated
;; user so that user can pass it back during API calls:
POFTHEDAY&amp;gt; *token*
&amp;quot;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiQm9iIiwiZW1haWwiOiJib2JAZ21haWwuY29tIn0.NLgg5RxlKDNqw1cqFU0_HysIu-zO7JBYUQN2IZF6c6w&amp;quot;

;; And when we&amp;#039;ll receive such API call,
;; we can know who this user is.
POFTHEDAY&amp;gt; (jose:decode :hs256 *secret*
                        *token*)
((&amp;quot;user&amp;quot; . &amp;quot;Bob&amp;quot;) (&amp;quot;email&amp;quot; . &amp;quot;bob@gmail.com&amp;quot;))
((&amp;quot;alg&amp;quot; . &amp;quot;HS256&amp;quot;) (&amp;quot;typ&amp;quot; . &amp;quot;JWT&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A cool feature of JWT token is that it is signed and you can trust the payload&apos;s content. Let&apos;s pretend, that Bob is the &quot;evil hacker&quot; who wants to get access to another account.&lt;/p&gt;
&lt;p&gt;To do this, Bob will modify payload and use header and sign from the original token:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defun replace-payload (token new-payload)
             (rutils:with (((original-header rutils:_ original-sign)
                            (str:split &amp;quot;.&amp;quot; token))
                           (json-payload
                            (jonathan:to-json new-payload :from :alist))
                           (new-encoded-payload
                            (jose/base64:base64url-encode json-payload)))
               (str:join &amp;quot;.&amp;quot;
                         (list original-header
                               new-encoded-payload
                               original-sign))))

POFTHEDAY&amp;gt; (defparameter *new-token*
             (replace-payload *token*
                              &amp;#039;((&amp;quot;user&amp;quot;  . &amp;quot;Alice&amp;quot;)
                                (&amp;quot;email&amp;quot; . &amp;quot;alice@wonderland.in&amp;quot;))))

;; Now we&amp;#039;ll try to decode token on the server-side
;; and receive error from JOSE:
POFTHEDAY&amp;gt; (jose:decode :hs256 *secret*
                        *new-token*)
; Debugger entered on #&amp;lt;JOSE/ERRORS:JWS-VERIFICATION-ERROR {1005C37033}&amp;gt;
[1] POFTHEDAY&amp;gt; 
; Evaluation aborted on #&amp;lt;JOSE/ERRORS:JWS-VERIFICATION-ERROR {1005C37033}&amp;gt;

;; But we still can inspect bad token because
;; it&amp;#039;s content is not encrypted:
POFTHEDAY&amp;gt; (jose:inspect-token *new-token*)

((&amp;quot;email&amp;quot; . &amp;quot;alice@wonderland.in&amp;quot;) (&amp;quot;user&amp;quot; . &amp;quot;Alice&amp;quot;))

((&amp;quot;alg&amp;quot; . &amp;quot;HS256&amp;quot;) (&amp;quot;typ&amp;quot; . &amp;quot;JWT&amp;quot;))

#(52 184 32 229 28 101 40 51 106 195 87 42 21 77 63 31 43 8 187 236 206 236 144
  88 81 3 118 33 145 122 115 172)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BTW, as you can see, tokens are not encoded, they are signed. Because of that, you should pass them only over encrypted channels.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-collider</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0079-cl-collider.html</link>
            <description>&lt;p&gt;This library is an interface to a very interesting algorithmic audio synthesizer - &lt;a href=&quot;https://supercollider.github.io/&quot;&gt;SuperCollider&lt;/a&gt;. SuperCollider itself has a builtin programming language, but &lt;code&gt;cl-collider&lt;/code&gt; makes it possible to write music in lisp interactively.&lt;/p&gt;
&lt;p&gt;Here is how a simple program in sclang looks like:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; C&apos;&gt;// 60Hz Gabber Rave 1995
Server.default.boot;

(
SynthDef(\gabberkick, {
    var snd, freq, high, lfo;
    freq = \freq.kr(440) * (Env.perc(0.001, 0.08, curve: -1).ar * 48 * \bend.kr(1)).midiratio;
    snd = Saw.ar(freq);
    snd = (snd * 100).tanh + ((snd.sign - snd) * -8.dbamp);
    high = HPF.ar(snd, 300);
    lfo = SinOsc.ar(8, [0, 0.5pi]).range(0, 0.01);
    high = high.dup(2) + (DelayC.ar(high, 0.01, lfo) * -2.dbamp);
    snd = LPF.ar(snd, 100).dup(2) + high;
    snd = RLPF.ar(snd, 7000, 2);
    snd = BPeakEQ.ar(snd, \ffreq.kr(3000) * XLine.kr(1, 0.8, 0.3), 0.5, 15);
    snd = snd * Env.asr(0.001, 1, 0.05).ar(2, \gate.kr(1));
    Out.ar(\out.kr(0), snd * \amp.kr(0.1));
}).add;

SynthDef(\hoover, {
    var snd, freq, bw, delay, decay;
    freq = \freq.kr(440);
    freq = freq * Env([-5, 6, 0], [0.1, 1.7], [\lin, -4]).kr.midiratio;
    bw = 1.035;
    snd = { DelayN.ar(Saw.ar(freq * ExpRand(bw, 1 / bw)) + Saw.ar(freq * 0.5 * ExpRand(bw, 1 / bw)), 0.01, Rand(0, 0.01)) }.dup(20);
    snd = (Splay.ar(snd) * 3).atan;
    snd = snd * Env.asr(0.01, 1.0, 1.0).kr(0, \gate.kr(1));
    snd = FreeVerb2.ar(snd[0], snd[1], 0.3, 0.9);
    snd = snd * Env.asr(0, 1.0, 4, 6).kr(2, \gate.kr(1));
    Out.ar(\out.kr(0), snd * \amp.kr(0.1));
}).add;
)

(
var durations;
durations = [1, 1, 1, 1, 3/4, 1/4, 1/2, 3/4, 1/4, 1/2];
Ppar([
    Pbind(*[
        instrument: \gabberkick,
        amp: -23.dbamp,
        freq: 60,
        legato: 0.8,
        ffreq: Pseq((0..(durations.size * 4 - 1)).normalize, inf).linexp(0, 1, 100, 4000),
        dur: Pseq(durations, inf),
        bend: Pfuncn({ |x| if(x &amp;lt; (1/2), 0.4, 1) }, inf) &amp;lt;&amp;gt; Pkey(\dur),
    ]),
    Pbind(*[
        instrument: \hoover,
        amp: -20.dbamp,
        midinote: 74,
        dur: durations.sum * 2,
        sustain: 7,
    ])
]).play(TempoClock(210 / 60));
)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I wasn&apos;t able to translate it into the Lisp form, because &lt;code&gt;cl-collider&lt;/code&gt; does not have documentation and diving into it will require too much time. However, there is a working code example from its README, which you can try in the REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:in-readtable :sc)
POFTHEDAY&amp;gt; (setf sc:*s* (sc:make-external-server
                         &amp;quot;localhost&amp;quot; :port 48800))
POFTHEDAY&amp;gt; (use-package :sc)

POFTHEDAY&amp;gt; (defsynth saw-synth ((note 60) (dur 4.0))
             (let* ((env (env-gen.kr (env [0 .2 0]
                                          [(* dur .2) (* dur .8)])
                                     :act :free))
                    (freq (midicps note))
                    (sig (lpf.ar (saw.ar freq env)
                                 (* freq 2))))
               (out.ar 0 [sig sig])))

POFTHEDAY&amp;gt; (defun make-melody (time n &amp;amp;optional (offset 0))
             (when (&amp;gt; n 0)
               (at time (synth &amp;#039;saw-synth
                               :note (+ offset (alexandria:random-elt
                                                &amp;#039;(62 65 69 72)))))
               (let ((next-time (+ time (alexandria:random-elt
                                         &amp;#039;(0 1 2 1.5)))))
                 (callback next-time #&amp;#039;make-melody
                           next-time (- n 1) offset))))

POFTHEDAY&amp;gt; (make-melody (quant 4) 16)
POFTHEDAY&amp;gt; (make-melody (+ 4 (quant 4)) 16 12)

;; This will stop the music
POFTHEDAY&amp;gt; (sc:stop)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is a demo, showing how does live coding works with &lt;code&gt;cl-collider&lt;/code&gt;:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=pZyuHjztARY&quot;&gt;https://www.youtube.com/watch?v=pZyuHjztARY&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To try &lt;code&gt;cl-collider&lt;/code&gt;, you&apos;ll need to install a SuperCollider. On OSX it is as simple as doing:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; bash&apos;&gt;brew cask install supercollider&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
            <title>trivial-ssh</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0078-trivial-ssh.html</link>
            <description>&lt;p&gt;This system is a simple wrapper around cl-libssh2 which is binding to the libssh2. Trivial SSH provides a few macros to safely establish a connection, open and close streams.&lt;/p&gt;
&lt;p&gt;In the next example we&apos;ll connect to the host and run two commands to get its hostname and OS description:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; Make this before Quickloading the system:
;; brew upgrade libssh2

POFTHEDAY&amp;gt; (flet ((read-lines (s)
                    (loop for line = (read-line s nil nil)
                          while line
                          collect line)))

             (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot; (ssh:agent &amp;quot;root&amp;quot;))
               (values
                (ssh:with-command (conn iostream &amp;quot;hostname -f&amp;quot;)
                                  (read-lines iostream))
                (ssh:with-command (conn iostream &amp;quot;lsb_release --id --release --codename&amp;quot;)
                                  (read-lines iostream)))))
(&amp;quot;my-lovely-host.inter.net&amp;quot;)
(&amp;quot;Distributor ID:	Ubuntu&amp;quot;
 &amp;quot;Release:	18.04&amp;quot;
 &amp;quot;Codename:	bionic&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, there is are commands to upload and download files using SCP protocol. Here is how we can copy the bootstrap file to the host and execute it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot; (ssh:agent &amp;quot;root&amp;quot;))
               (ssh:upload-file conn &amp;quot;install.sh&amp;quot; &amp;quot;/tmp/install.sh&amp;quot;)
               (ssh:with-command (conn stream &amp;quot;chmod +x /tmp/install.sh&amp;quot;))
                 (ssh:with-command (conn stream &amp;quot;/tmp/install.sh&amp;quot;)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The cool part of &lt;code&gt;with-command&lt;/code&gt; macro is that you have a communication stream and can read output during the command execution. Here we are installing Emacs on the remote host and can observe the process:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0078/install-emacs.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Here is the code from this sample:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (flet ((-&amp;gt; (from to)
                    (loop for line = (read-line from nil nil)
                       while line
                       do (write-string line to)
                          (terpri))))
             (ssh:with-connection (conn &amp;quot;134.209.21.115&amp;quot;
                                        (ssh:agent &amp;quot;root&amp;quot;))
               (ssh:with-command
                   (conn stream &amp;quot;apt-get update &amp;amp;&amp;amp;
                                apt-get install -y emacs-nox&amp;quot;)
                   (-&amp;gt; stream *standard-output*))))&lt;/code&gt;&lt;/pre&gt;&lt;h2&gt;Update&lt;/h2&gt;&lt;p&gt;Found that &lt;code&gt;cl-libssh2&lt;/code&gt; does not support agent forwarding. Because of that, I&apos;m not able to call &lt;code&gt;git pull&lt;/code&gt; on the remote machine.&lt;/p&gt;
&lt;p&gt;I tried to patch &lt;code&gt;cl-libssh2&lt;/code&gt; to support the latest &lt;code&gt;libssh2&lt;/code&gt; where agent forwarding was supported in August 2019, but this patch does not work yet.&lt;/p&gt;
&lt;p&gt;If somebody is interested to help me with that, he might try this pull-request:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/alxchk/cl-libssh2/pull/7&quot;&gt;https://github.com/alxchk/cl-libssh2/pull/7&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
            <title>named-readtables</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0077-named-readtables.html</link>
            <description>&lt;p&gt;This system is highly recommended if you are writing a code which modifies a &lt;code&gt;*readtable*&lt;/code&gt; because it allows to define and switch between readtables as you do with Lisp packages.&lt;/p&gt;
&lt;p&gt;If you are not familiar with what &lt;code&gt;*readtable*&lt;/code&gt; is, then read this article:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://lisper.in/reader-macros&quot;&gt;https://lisper.in/reader-macros&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;but pay attention, that the article manipulates with &lt;code&gt;*readtable*&lt;/code&gt; instead of using &lt;code&gt;named-readtables&lt;/code&gt;. This is bad. Use &lt;code&gt;named-readtables&lt;/code&gt; instead.&lt;/p&gt;
&lt;p&gt;First, let&apos;s see how to use &lt;code&gt;named-readtables&lt;/code&gt; to switch between read-tables. As an example, we&apos;ll see how to use &lt;code&gt;cl-interpol&lt;/code&gt; and &lt;code&gt;rutils&lt;/code&gt; readtables.&lt;/p&gt;
&lt;p&gt;This is how you can lookup which tables are available:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ql:quickload &amp;#039;(:cl-interpol :rutils))

POFTHEDAY&amp;gt; (named-readtables:list-all-named-readtables)
(#&amp;lt;NAMED-READTABLE :COMMON-LISP {1000024B73}&amp;gt;
 #&amp;lt;NAMED-READTABLE :CURRENT {1000025663}&amp;gt;
 #&amp;lt;NAMED-READTABLE RUTILS.READTABLE:RUTILS-READTABLE {1004A960E3}&amp;gt;
 #&amp;lt;NAMED-READTABLE RUTILS.READTABLE:STANDARD-READTABLE {1004A96133}&amp;gt;
 #&amp;lt;NAMED-READTABLE :INTERPOL-SYNTAX {1001D19853}&amp;gt;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now let&apos;s see how does switching work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; First I&amp;#039;ll switch to the interpol&amp;#039;s syntax:
POFTHEDAY&amp;gt; (named-readtables:in-readtable :interpol-syntax)

POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #?&amp;quot;Hello ${username}!&amp;quot;)
&amp;quot;Hello Bob!&amp;quot;

;; Rutils readtable is not active, and we can&amp;#039;t
;; use it&amp;#039;s syntax for hashes:
POFTHEDAY&amp;gt; #h(:foo &amp;quot;bar&amp;quot;)
; Debugger entered on #&amp;lt;SB-INT:SIMPLE-READER-ERROR
; &amp;quot;no dispatch function defined for ~S&amp;quot; {10068D4C63}&amp;gt;

;; We have to activate  it first
POFTHEDAY&amp;gt; (named-readtables:in-readtable
            rutils:rutils-readtable)

POFTHEDAY&amp;gt; #h(:foo &amp;quot;bar&amp;quot;)
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 1 {10068B9013}&amp;gt;

;; But now we are unable to use iterpol&amp;#039;s syntax:
POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #?&amp;quot;Hello ${username}!&amp;quot;)
; Debugger entered on #&amp;lt;SB-INT:SIMPLE-READER-ERROR
; &amp;quot;no dispatch function defined for ~S&amp;quot; {1006AE93F3}&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But what if we want to use both readtables from &lt;code&gt;cl-interpol&lt;/code&gt; and from &lt;code&gt;rutils&lt;/code&gt;?&lt;/p&gt;
&lt;p&gt;It is possible if we merge them together and create a new readtable:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:defreadtable
               :poftheday
             (:merge
              rutils:rutils-readtable
              :interpol-syntax))

POFTHEDAY&amp;gt; (named-readtables:in-readtable
            :poftheday)

POFTHEDAY&amp;gt; (let ((username &amp;quot;Bob&amp;quot;))
             #h(:greeting #?&amp;quot;Hello ${username}!&amp;quot;))
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 1 {1003054C23}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-ht *)
#{
  :GREETING &amp;quot;Hello Bob!&amp;quot;
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we&apos;ll define a literal syntax for lambda from &lt;code&gt;rutils&lt;/code&gt; as a separate named read-table:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; &apos;&gt;POFTHEDAY&amp;gt; (defmacro trivial-positional-lambda (body)
             `(lambda (&amp;amp;optional % %%)
                (declare (ignorable %) (ignorable %%))
                ,body))

POFTHEDAY&amp;gt; (defun |^-reader| (stream char)
             (declare (ignore char))
             (let ((sexp (read stream t nil t)))
               `(trivial-positional-lambda
                 ,(if (and (listp sexp) (listp (car sexp)))
                      (cons &amp;#039;progn sexp)
                      sexp))))

POFTHEDAY&amp;gt; (named-readtables:defreadtable
               :lambda
             (:merge :standard)
             (:macro-char #\^ #&amp;#039;|^-reader|))

;; Now we can switch to the new readtable
;; and use new syntax for lambdas:
POFTHEDAY&amp;gt; (named-readtables:in-readtable :lambda)

POFTHEDAY&amp;gt; ^(+ % %%)
#&amp;lt;FUNCTION (LAMBDA (&amp;amp;OPTIONAL % %%)) {2252593B}&amp;gt;

POFTHEDAY&amp;gt; (funcall *
                    2
                    3)
5&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Named readtables has yet another useful feature - it integrates with SLIME. When you have a &lt;code&gt;(in-readtable)&lt;/code&gt; call after you package definition, SLIME will know what &lt;code&gt;readtable&lt;/code&gt; to use when you hit &lt;code&gt;Ctrl-C Ctrl-C&lt;/code&gt; on defuns.&lt;/p&gt;
&lt;p&gt;That is what &lt;code&gt;in-readtable&lt;/code&gt; expands to:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:in-readtable :interpol-syntax)

;; It expands to:
(eval-when (:compile-toplevel
            :load-toplevel
            :execute)
  (setf *readtable*
        (named-readtables:ensure-readtable
         &amp;#039;:interpol-syntax))
  (when (find-package :swank)
    (named-readtables::%frob-swank-readtable-alist
     *package*
     *readtable*)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This &lt;code&gt;%frob-swank-readtable-alist&lt;/code&gt; modifies &lt;code&gt;swank:*readtable-alist*&lt;/code&gt; to make it know what readtable should be used for the package. But a comment to this code says it is a &lt;code&gt;KLUDGE&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Interesting, how this will or should work in the LispWorks?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-change-case</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0076-cl-change-case.html</link>
            <description>&lt;p&gt;This cool library is able to transform strings from one time of delimiters to others.&lt;/p&gt;
&lt;p&gt;Previously I&apos;ve used &lt;a href=&quot;http://quickdocs.org/kebab/&quot;&gt;kebab&lt;/a&gt;, but &lt;code&gt;cl-change-case&lt;/code&gt; is much more featureful:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-change-case:path-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo/bar/bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:path-case &amp;quot;foo-bar_bazz&amp;quot;)
&amp;quot;foo/bar/bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:path-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo/bar/bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:sentence-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;Foo bar bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:snake-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo_bar_bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:camel-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;fooBarBazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:no-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;foo bar bazz&amp;quot;
POFTHEDAY&amp;gt; (cl-change-case:header-case &amp;quot;foo-bar-bazz&amp;quot;)
&amp;quot;Foo-Bar-Bazz&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When this can be useful? In cases when you interop with other systems, but want to use &lt;code&gt;:this-style-of-symbols&lt;/code&gt; in Lisp. For example, you might generate identifiers for JavaScript or Python.&lt;/p&gt;
&lt;p&gt;Another case is when you want to output labels for UI. Here I have a function which will render an HTML table describing a &lt;code&gt;CLOS&lt;/code&gt; object:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ((created-at :initarg :created-at)
              (name :initarg :name)
              (num-posts :initarg :num-posts)))

POFTHEDAY&amp;gt; (defun render (object)
             (let* ((class-name (type-of object))
                    (class (find-class class-name))
                    (slots (closer-mop:class-slots class)))
               (cl-who:with-html-output-to-string (*standard-output* nil :indent t)
                 (:table
                  (loop for slot in slots
                        for slot-name = (closer-mop:slot-definition-name slot)
                        for label = (cl-change-case:sentence-case (symbol-name slot-name))
                        for value = (rutils:fmt &amp;quot;~A&amp;quot;
                                                (slot-value object slot-name))
                        do (cl-who:htm
                            (:tr
                             (:th (cl-who:esc label))
                             (:td (cl-who:esc value)))))))))

POFTHEDAY&amp;gt; (render (make-instance &amp;#039;user
                                  :name &amp;quot;Bob&amp;quot;
                                  :created-at &amp;quot;2020-05-22&amp;quot;
                                  :num-posts 42))
&amp;quot;
&amp;lt;table&amp;gt;
&amp;lt;tr&amp;gt;
  &amp;lt;th&amp;gt;Created at&amp;lt;/th&amp;gt;
  &amp;lt;td&amp;gt;2020-05-22&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
  &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
  &amp;lt;td&amp;gt;Bob&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
  &amp;lt;th&amp;gt;Num posts&amp;lt;/th&amp;gt;
  &amp;lt;td&amp;gt;42&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
            <title>cl-who</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0075-cl-who.html</link>
            <description>&lt;p&gt;Today we continue to investigate &lt;code&gt;poftheday&lt;/code&gt;&apos;s &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0063-asdf-viz.html&quot;&gt;dependencies&lt;/a&gt; and will look at the well known &lt;code&gt;cl-who&lt;/code&gt; library. &lt;code&gt;CL-Who&lt;/code&gt; is a library Edmund Weitz and provides a DSL for HTML generation.&lt;/p&gt;
&lt;p&gt;For those who are not familiar with &lt;code&gt;cl-who&lt;/code&gt;, here is a quick example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-who:with-html-output-to-string (s)
             (:body
              (:p &amp;quot;Hello world!&amp;quot;)))
&amp;quot;&amp;lt;body&amp;gt;&amp;lt;p&amp;gt;Hello world!&amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you want to insert a variable, you have to use a local macro &lt;code&gt;esc&lt;/code&gt;. There is also another macro - &lt;code&gt;str&lt;/code&gt;, and it very easy to misuse it. That is one of the reasons why I don&apos;t like &lt;code&gt;cl-who&lt;/code&gt; and prefer &lt;code&gt;spinneret&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Let&apos;s pretend we want to output a username in the comment list on our page. The correct way to do so will be:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defclass user ()
             ((name :initarg :name
                    :reader get-name)))

POFTHEDAY&amp;gt; (let ((user (make-instance
                        &amp;#039;user
                        :name &amp;quot;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;&amp;quot;))
                 (comment-text &amp;quot;Hello from Bob!&amp;quot;))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:div :class &amp;quot;comment&amp;quot;
                     (:div :class &amp;quot;username&amp;quot;
                           (cl-who:esc (get-name user)))
                     (:div :class &amp;quot;text&amp;quot;
                           (cl-who:esc comment-text)))))
&amp;quot;
&amp;lt;div class=&amp;#039;comment&amp;#039;&amp;gt;
  &amp;lt;div class=&amp;#039;username&amp;#039;&amp;gt;Bob &amp;amp;lt;script&amp;amp;gt;alert(&amp;amp;#039;You are hacked&amp;amp;#039;)&amp;amp;lt;/script&amp;amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;#039;text&amp;#039;&amp;gt;Hello from Bob!
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As I said, this was a correct way, but it is very easy to misuse &lt;code&gt;cl-who&lt;/code&gt; and make your beautiful site open for &lt;a href=&quot;https://en.wikipedia.org/wiki/Cross-site_scripting&quot;&gt;XSS attacks&lt;/a&gt;. You only have to use &lt;code&gt;str&lt;/code&gt; instead of &lt;code&gt;esc&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((user (make-instance
                        &amp;#039;user
                        :name &amp;quot;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;&amp;quot;))
                 (comment-text &amp;quot;Hello from Bob!&amp;quot;))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:div :class &amp;quot;comment&amp;quot;
                     (:div :class &amp;quot;username&amp;quot;
                           (cl-who:str (get-name user)))
                     (:div :class &amp;quot;text&amp;quot;
                           (cl-who:str comment-text)))))
&amp;quot;
&amp;lt;div class=&amp;#039;comment&amp;#039;&amp;gt;
  &amp;lt;div class=&amp;#039;username&amp;#039;&amp;gt;Bob &amp;lt;script&amp;gt;alert(&amp;#039;You are hacked&amp;#039;)&amp;lt;/script&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;div class=&amp;#039;text&amp;#039;&amp;gt;Hello from Bob!
  &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here &lt;code&gt;script&lt;/code&gt; tag that was not escaped. This way, any code an evil user will enter as his name will be executed in other users browsers.&lt;/p&gt;
&lt;p&gt;Another inconvenience of &lt;code&gt;cl-who&lt;/code&gt; is that you have to use &lt;code&gt;htm&lt;/code&gt; macro if want to mix &lt;code&gt;HTML&lt;/code&gt; pieces with lisp forms. For example, if you want to output a list of items, this will not work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; &apos;&gt;POFTHEDAY&amp;gt; (let ((list (list 1 2 3 4 5)))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:ul
                (loop for item in list
                      do (:li (cl-who:esc
                               (format nil &amp;quot;Item number ~A&amp;quot;
                                       item)))))))
; in: LET ((LIST (LIST 1 2 3 4 5)))
;     (:LI (CL-WHO:ESC (FORMAT NIL &amp;quot;Item number ~A&amp;quot; POFTHEDAY::ITEM)))
; 
; caught STYLE-WARNING:
;   undefined function: :LI
; 
; compilation unit finished
;   Undefined function:
;     :LI
;   caught 1 STYLE-WARNING condition&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You have to wrap &lt;code&gt;:li&lt;/code&gt; form with a &lt;code&gt;htm&lt;/code&gt; macro, like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((list (list 1 2 3 4 5)))
             (cl-who:with-html-output-to-string (s nil :indent t)
               (:ul
                (loop for item in list
                      do (cl-who:htm
                          (:li 
                           (cl-who:esc
                            (format nil &amp;quot;Item number ~A&amp;quot;
                                    item))))))))
&amp;quot;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Item number 1
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 2
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 3
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 4
&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;Item number 5
&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The Common Lisp Project of the Day&apos;s blog uses &lt;code&gt;cl-who&lt;/code&gt; only because this is a dependency of the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/03/0018-cl-bootstrap.html&quot;&gt;cl-bootstrap&lt;/a&gt;. Personally, I prefer &lt;code&gt;spinneret&lt;/code&gt; and probably will rewrite #poftheday site to use it.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>lquery</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0074-lquery.html</link>
            <description>&lt;p&gt;Yesterday I&apos;ve &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0073-clss.html&quot;&gt;reviewed a library&lt;/a&gt; to apply CSS3 selectors to the HTML nodes, produced by &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;Plump&lt;/a&gt;. And this allowed making our Twitter crawler more concise.&lt;/p&gt;
&lt;p&gt;lQuery will take it to the next stage because it makes possible to describe a whole HTML processing pipeline in a very declarative way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:$ (initialize (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))
             &amp;quot;.tweet-text&amp;quot;
             (render-text)
             (map (alexandria:curry
                   #&amp;#039;str:shorten 40))
             (lt 5))
#(&amp;quot;Hi, I&amp;#039;m a #gamedev. My latest project...&amp;quot;
  &amp;quot;Aw thank you, here&amp;#039;s the whole story ...&amp;quot;
  &amp;quot;&amp;#x96E8;&amp;#x6797;pic.twitter.com/BFwcd0AWSE&amp;quot;
  &amp;quot;&amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q&amp;quot;
  &amp;quot;The logic of Splatoon.pic.twitter.com...&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Each &quot;call&quot; here is a special function which is applied either to a set of &lt;code&gt;HTML&lt;/code&gt; nodes or to a single node in a set.&lt;/p&gt;
&lt;p&gt;All &lt;code&gt;lquery&lt;/code&gt; functions are defined in the &lt;code&gt;lquery-funcs&lt;/code&gt; package and documented &lt;a href=&quot;https://shinmera.github.io/lquery/#PACKAGE%20LQUERY-FUNCS&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;You can add your own functions for data processing, using &lt;a href=&quot;https://shinmera.github.io/lquery/#MACRO-FUNCTION%20LQUERY%3ADEFINE-LQUERY-FUNCTION&quot;&gt;define-lquery-function&lt;/a&gt; and &lt;a href=&quot;https://shinmera.github.io/lquery/#MACRO-FUNCTION%20LQUERY%3ADEFINE-LQUERY-LIST-FUNCTION&quot;&gt;define-lquery-list-function&lt;/a&gt;. This can be useful if some operation is frequent. For example, let&apos;s write a function to make strings shorter!&lt;/p&gt;
&lt;p&gt;First, we need to define lQuery function. It will process one node at a time:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:define-lquery-function shorten (text max-length)
             (check-type text string)
             (check-type max-length (integer 0 65535))
             (str:shorten max-length text))

LQUERY-FUNCS::SHORTEN&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can use it to make our web crawler even more beautiful!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (lquery:$ (initialize (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))
             &amp;quot;.tweet-text&amp;quot;
             (render-text)
             (shorten 40)
             (lt 5))
#(&amp;quot;Hi, I&amp;#039;m a #gamedev. My latest project...&amp;quot;
  &amp;quot;Aw thank you, here&amp;#039;s the whole story ...&amp;quot;
  &amp;quot;&amp;#x96E8;&amp;#x6797;pic.twitter.com/BFwcd0AWSE&amp;quot;
  &amp;quot;&amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q&amp;quot;
  &amp;quot;The logic of Splatoon.pic.twitter.com...&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are other &lt;code&gt;define-*&lt;/code&gt; macros in &lt;code&gt;lquery&lt;/code&gt; as well. Read its documentation to learn more about how to extend it. It would be nice if &lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@shinmera&lt;/a&gt; add more examples on how to extend &lt;code&gt;lquery&lt;/code&gt;!&lt;/p&gt;
</description>
        </item>
        <item>
            <title>clss</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0073-clss.html</link>
            <description>&lt;p&gt;Today we continue to review web crawling tools from &lt;a href=&quot;https://twitter.com/shinmera&quot;&gt;@shinmera&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This review will be short because I&apos;ll reuse code from the &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;previous post&lt;/a&gt; and improve it by replacing four lines with only one.&lt;/p&gt;
&lt;p&gt;A system CLSS allows you to use CSS3 selectors when working with HTML nodes produced by &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html&quot;&gt;Plump&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Here is how we can improve our simple Twitter crawler:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *raw-html*
             (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))

POFTHEDAY&amp;gt; (defvar *html* (plump:parse *raw-html*))

           ;; Now I&amp;#039;ll replaced these lines
           ;; with one clss:select call:
           ;;
           ;; (remove-if-not (lambda (div)
           ;;                  (str:containsp &amp;quot;tweet-text&amp;quot;
           ;;                                 (plump:attribute div &amp;quot;class&amp;quot;)))
           ;;                (plump:get-elements-by-tag-name *html* &amp;quot;p&amp;quot;))
POFTHEDAY&amp;gt; (defparameter *posts*
             (clss:select &amp;quot;.tweet-text&amp;quot; *html*))

POFTHEDAY&amp;gt; (type-of *posts*)
(VECTOR T 40)

POFTHEDAY&amp;gt; (loop repeat 5
                 for post across *posts*
                 for full-text = (plump:render-text post)
                 for short-text = (str:shorten 40 full-text)
                 do (format t &amp;quot;- ~A~2%&amp;quot; short-text))
- Hi, I&amp;#039;m a #gamedev. My latest project...

- &amp;#x3044;&amp;#x3089;&amp;#x3063;&amp;#x3057;&amp;#x3083;&amp;#x3044;&amp;#x307E;&amp;#x305B;&amp;#xFF5E;&amp;#xFF01;pic.twitter.com/wwaWDD6B3Q

- The logic of Splatoon.pic.twitter.com...

- The AI is extremely rough still, but ...

- pic.twitter.com/Cpvqytce5G&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As a bonus, I want to show you that &lt;code&gt;CLSS&lt;/code&gt; supports even pseudoclasses:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (plump:parse &amp;quot;
&amp;lt;ul&amp;gt;
  &amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Second item&amp;lt;/li&amp;gt;
  &amp;lt;li&amp;gt;Third item&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;quot;)
#&amp;lt;PLUMP-DOM:ROOT {10031A93A3}&amp;gt;

POFTHEDAY&amp;gt; (clss:select &amp;quot;li:first-child&amp;quot;
                        *)
#(#&amp;lt;PLUMP-DOM:ELEMENT li {100322C883}&amp;gt;)

POFTHEDAY&amp;gt; (plump:serialize * nil)
&amp;quot;&amp;lt;li&amp;gt;First item&amp;lt;/li&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Sadly, the documentation says only that it supports almost all CSS3 selectors, but don&apos;t enumerate them. However, we can learn this from sources:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (rutils:hash-table-keys
            clss::*pseudo-selectors*)
(&amp;quot;ROOT&amp;quot; &amp;quot;NTH-CHILD&amp;quot; &amp;quot;NTH-LAST-CHILD&amp;quot; &amp;quot;NTH-OF-TYPE&amp;quot; &amp;quot;NTH-LAST-OF-TYPE&amp;quot;
 &amp;quot;FIRST-CHILD&amp;quot; &amp;quot;LAST-CHILD&amp;quot; &amp;quot;FIRST-OF-TYPE&amp;quot; &amp;quot;LAST-OF-TYPE&amp;quot; &amp;quot;ONLY-CHILD&amp;quot;
 &amp;quot;ONLY-OF-TYPE&amp;quot; &amp;quot;EMPTY&amp;quot; &amp;quot;LINK&amp;quot; &amp;quot;VISITED&amp;quot; &amp;quot;ACTIVE&amp;quot; &amp;quot;HOVER&amp;quot; &amp;quot;FOCUS&amp;quot; &amp;quot;TARGET&amp;quot;
 &amp;quot;LANG&amp;quot; &amp;quot;ENABLED&amp;quot; &amp;quot;DISABLED&amp;quot; &amp;quot;CHECKED&amp;quot; &amp;quot;FIRST-LINE&amp;quot; &amp;quot;FIRST-LETTER&amp;quot; &amp;quot;BEFORE&amp;quot;
 &amp;quot;AFTER&amp;quot; &amp;quot;WARNING&amp;quot; &amp;quot;NOT&amp;quot; &amp;quot;FIRST-ONLY&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is a &lt;code&gt;clss:define-pseudo-selector&lt;/code&gt; macro which allows defining a custom pseudo-selector.&lt;/p&gt;
&lt;p&gt;Yesterday we&apos;ll learn about a more sophisticated tool for web scraping - lQuery.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>plump</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0072-plump.html</link>
            <description>&lt;p&gt;Yesterday &lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@Shinmera&lt;/a&gt; mentioned Plump in the &lt;a href=&quot;https://twitter.com/XH004&quot;&gt;@XH004&lt;/a&gt;&apos;s &lt;a href=&quot;https://twitter.com/XH004/status/1261861964818440192&quot;&gt;thread&lt;/a&gt; about performance optimization of it&apos;s new HTML parser. And I decided to review it.&lt;/p&gt;
&lt;p&gt;Plump is able to parse, modify and serialize an HTML back.&lt;/p&gt;
&lt;p&gt;Let&apos;s write a crawler to grab @shinmera&apos;s posts from Twitter!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *raw-html*
              (dex:get &amp;quot;https://twitter.com/shinmera&amp;quot;))

POFTHEDAY&amp;gt; (defvar *html* (plump:parse *raw-html*))

;; We need all divs with class &amp;quot;tweet-text&amp;quot;
POFTHEDAY&amp;gt; (defvar *posts*
             (remove-if-not (lambda (div)
                              (str:containsp &amp;quot;tweet-text&amp;quot;
                                             (plump:attribute div &amp;quot;class&amp;quot;)))
                            (plump:get-elements-by-tag-name *html* &amp;quot;p&amp;quot;)))

POFTHEDAY&amp;gt; (loop for post in (rutils:take 5 *posts*)
                 for full-text = (plump:render-text post)
                 for short-text = (str:shorten 40 full-text)
                 do (format t &amp;quot;- ~A~2%&amp;quot; short-text))
- 1478 Lighting sketch #onesies https:/...

- Trust Level: Swiss A fridge with cool...

- The arch.pic.twitter.com/gMamJfZ1r4

- &amp;#x3089;&amp;#x304F;&amp;#x304C;&amp;#x304D;&amp;#x3070;&amp;#x304B;&amp;#x308A;&amp;#x30A2;&amp;#x30C3;&amp;#x30D7;&amp;#x3057;&amp;#x3066;&amp;#x3044;&amp;#x305F;&amp;#x3084;&amp;#x3064;&amp;#x3001;&amp;#x4ECA;&amp;#x5EA6;&amp;#x306F;&amp;#x52D5;&amp;#x304D;&amp;#x307E;&amp;#x3059;&amp;#x3002;&amp;#x9031;&amp;#x672B;&amp;#x306B;&amp;#x30D7;&amp;#x30ED;&amp;#x30AF;&amp;#x30EA;&amp;#x30A8;&amp;#x30A4;&amp;#x30C8;&amp;#x3067;&amp;#x63CF;...

- Shit&amp;#039;s broken. Will be back in a few ...&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This library has more utils for HTML parsing. Read the documentation to learn more.&lt;/p&gt;
&lt;p&gt;If you are going to write crawlers  in Common lisp, I recommend you to use Plump together with another @shimera&apos;s library - &lt;a href=&quot;https://shinmera.github.io/CLSS/&quot;&gt;clss&lt;/a&gt; but we&apos;ll play with it tomorrow :)&lt;/p&gt;
</description>
        </item>
        <item>
            <title>parenscript</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0071-parenscript.html</link>
            <description>&lt;p&gt;Parenscript is the CL&apos;s answer to the &lt;a href=&quot;https://clojurescript.org/&quot;&gt;ClojureScript&lt;/a&gt;. It makes possible to write client-side code in Lisp and compile it to the Javascript for running in the Browser.&lt;/p&gt;
&lt;p&gt;I used Parenscript in one application, based on Electron and Weblocks.&lt;/p&gt;
&lt;p&gt;Here is a &lt;a href=&quot;https://github.com/40ants/hacrm/blob/464e931fb7eac7f2b8b0d3f5465ba9c255ec1d2b/src/widgets/contacts-list.lisp#L148-L184&quot;&gt;piece of real code&lt;/a&gt; which uses Parenscript to define a client-side code. This code allows switching between different contacts using shortcuts. It uses &lt;code&gt;jQuery&lt;/code&gt; to access &lt;code&gt;DOM&lt;/code&gt; elements:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(weblocks-parenscript:make-dependency
 (let ((numbers-are-visible nil))
   
   ;; With this code we give user ability to press Alt+1, Alt+2,...
   ;; to select one of first 10 contacts in the list.
   (setf (@ document onkeydown)
         (lambda (e)
           (let ((code (@ e &amp;quot;keyCode&amp;quot;))
                 (numbers (j-query &amp;quot;.contact-list__contact-number&amp;quot;)))
             ((@ console log) &amp;quot;Key down with code:&amp;quot; code)
             
             (cond
               ((= code 18)
                ((@ numbers show))
                (setf numbers-are-visible t))
               ((and (&amp;gt;= 57 code 48))
                ;; If user presed 0, then we&amp;#039;l consider it a 10.
                (when (= code 48)
                  (setf code (+ code 10)))
                
                (let ((contact-number (- code 48)))
                  ((@ console log)
                   &amp;quot;Selecting contact&amp;quot; contact-number)
                  ;; jQuery(&amp;quot;#contact-0 a&amp;quot;).click()
                  ((@ (j-query (+ &amp;quot;#contact-&amp;quot; contact-number &amp;quot; a&amp;quot;))
                      click))))))))
   
   (setf (@ document onkeyup)
         (lambda (e)
           (let ((code (@ e &amp;quot;keyCode&amp;quot;))
                 (numbers (j-query &amp;quot;.contact-list__contact-number&amp;quot;)))
             ((@ console log) &amp;quot;Key up with code:&amp;quot; code)
             
             (cond
               ((= code 18)
                ((@ numbers hide))
                (setf numbers-are-visible nil)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are two ways of using Parenscript:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;You can manually compile a &lt;code&gt;s-exp&lt;/code&gt; into Javascript.&lt;/li&gt;&lt;li&gt;You can use it as an ASDF extension to compile some components   automatically. But this will require the use of additional system   &lt;a href=&quot;https://github.com/gonzojive/paren-files&quot;&gt;paren-files&lt;/a&gt;. We&apos;ll review it later.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Let&apos;s investigate the first way by defining a simple JS function which sums two numbers and shows the result in Web Inspector&apos;s console:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (import &amp;#039;(parenscript:ps
                     parenscript:@))

POFTHEDAY&amp;gt; (ps
             (+ 1 2))
&amp;quot;1 + 2;&amp;quot;

POFTHEDAY&amp;gt; (ps
             (defun foo (a b)
               (+ a b)))
&amp;quot;function foo(a, b) {
    return a + b;
};&amp;quot;

POFTHEDAY&amp;gt; (ps
             (defun foo (a b)
               ((@ console log)
                 (+ a b))))
&amp;quot;function foo(a, b) {
    __PS_MV_REG = [];
    return console.log(a + b);
};&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you might notice, instead of dot notation, Parenscript uses a &lt;code&gt;@&lt;/code&gt; macro.&lt;/p&gt;
&lt;p&gt;Parenscript supports a subset of &lt;code&gt;loop&lt;/code&gt; macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps
             (loop :with collection =  &amp;#039;(1 2 3)
                   :for i :in collection
                   :do ((@ console log)
                       i)))
&amp;quot;(function () {
    var collection = [1, 2, 3];
    var _js8 = collection.length;
    for (var _js7 = 0; _js7 &amp;lt; _js8; _js7 += 1) {
        var i = collection[_js7];
        console.log(i);
    };
})();&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And also it allows you to write custom macroses which will expand into the Javascript Code!&lt;/p&gt;
&lt;p&gt;There are few ways to define macroses for Parenscript here is one of them. We&apos;ll define a macro in Common Lisp code and then will call this macro from Parenscript:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps:defpsmacro awhen (test &amp;amp;body body)
             `(let ((it ,test))
                (when it
                  ,@body)))

POFTHEDAY&amp;gt; (ps
             (let ((some-var 100500))
               (awhen (= some-var 42)
                 ((@ console log)
                  &amp;quot;Some var is&amp;quot; it))))
&amp;quot;(function () {
    var someVar = 100500;
    var it = someVar === 42;
    __PS_MV_REG = [];
    return it ? console.log(&amp;#039;Some var is&amp;#039;, it) : null;
})();&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Rewriting macro for Parenscript is not a fan. Why you should do this if macro already exists for Common Lisp?&lt;/p&gt;
&lt;p&gt;You shouldn&apos;t!&lt;/p&gt;
&lt;p&gt;Import existing Lisp macro into the Parenscript!&lt;/p&gt;
&lt;p&gt;In the next example, I&apos;ll show you how to reuse anaphoric &lt;code&gt;if&lt;/code&gt; from &lt;code&gt;rutils&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; First, let&amp;#039;s eval our form in Common Lisp
POFTHEDAY&amp;gt; (rutils:aif (= 1 2)
              (list :status :ok
                    :result rutils:it)
              (list :status :fail
                    :result rutils:it))
(:STATUS :FAIL :RESULT NIL)

;; By default it will not work:
POFTHEDAY&amp;gt; (ps
             (rutils:aif (= 1 2)
                (list :status :ok
                      :result it)
                (list :status :fail
                      :result it)))
&amp;quot;aif(1 === 2,
     [&amp;#039;status&amp;#039;, &amp;#039;ok&amp;#039;, &amp;#039;result&amp;#039;, it],
     [&amp;#039;status&amp;#039;, &amp;#039;fail&amp;#039;, &amp;#039;result&amp;#039;, it]);&amp;quot;

;; But we can import the macro:

POFTHEDAY&amp;gt; (ps:import-macros-from-lisp
            &amp;#039;rutils:aif)

POFTHEDAY&amp;gt; (ps
             (rutils:aif (= 1 2)
                (list :status :ok
                      :result it)
                (list :status :fail
                      :result it)))
&amp;quot;(function () {
    var it = 1 === 2;
    return it ? [&amp;#039;status&amp;#039;, &amp;#039;ok&amp;#039;, &amp;#039;result&amp;#039;, it]
              : [&amp;#039;status&amp;#039;, &amp;#039;fail&amp;#039;, &amp;#039;result&amp;#039;, it];
})();&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also built-in support for HTML rendering. Parenscript supports &lt;a href=&quot;https://github.com/franzinc/aserve/blob/master/doc/htmlgen.md&quot;&gt;Allegro HTMLGen DSL&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps
             (defun render-link (user)
               (ps:ps-html
                ((:a :href (+ &amp;quot;https://foo.bar/&amp;quot;
                               (get-nickname user)))
                 (get-name user)))))
&amp;quot;function renderLink(user) {
    __PS_MV_REG = [];
    return [&amp;#039;&amp;lt;a href=\\\&amp;quot;&amp;#039;,
            &amp;#039;https://foo.bar/&amp;#039; + getNickname(user),
            &amp;#039;\\\&amp;quot;&amp;gt;&amp;#039;,
             getName(user),
            &amp;#039;&amp;lt;/a&amp;gt;&amp;#039;].join(&amp;#039;&amp;#039;);
};&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And &lt;a href=&quot;https://edicl.github.io/cl-who/&quot;&gt;CL-WHO&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (ps
             (defun render-link (user)
               (ps:who-ps-html
                (:a :href (+ &amp;quot;https://foo.bar/&amp;quot;
                              (get-nickname user))
                 (get-name user)))))
&amp;quot;function renderLink(user) {
    __PS_MV_REG = [];
    return [&amp;#039;&amp;lt;a href=\\\&amp;quot;&amp;#039;,
            &amp;#039;https://foo.bar/&amp;#039; + getNickname(user),
            &amp;#039;\\\&amp;quot;&amp;gt;&amp;#039;,
             getName(user),
            &amp;#039;&amp;lt;/a&amp;gt;&amp;#039;].join(&amp;#039;&amp;#039;);
};&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;With Parenscript you can create client-side applications or code for running on Node.js. All of this, using Common Lisp power. Isn&apos;t it cool?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>split-sequence</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0070-split-sequence.html</link>
            <description>&lt;p&gt;This is the utility library with a single purpose – to split, dissect, cut, cleave and partition sequences.&lt;/p&gt;
&lt;p&gt;In the simplest form it is:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (split-sequence:split-sequence
            #\Space
            &amp;quot;Bob loves Alice!&amp;quot;)
(&amp;quot;Bob&amp;quot; &amp;quot;loves&amp;quot; &amp;quot;Alice!&amp;quot;)
16&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It is also is able to split only N times, split from the and to remove empty subsequences:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0))
(#(1 2 3 4) #(5 6 7) #(8 9) #())

POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0)
            :remove-empty-subseqs t)
(#(1 2 3 4) #(5 6 7) #(8 9))

POFTHEDAY&amp;gt; (split-sequence:split-sequence
            0
            #(1 2 3 4 0 5 6 7 0 8 9 0)
            :remove-empty-subseqs t
            :from-end t
            :count 1)
(#(8 9))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There are also &lt;code&gt;split-sequence-if&lt;/code&gt; and &lt;code&gt;split-sequence-if-not&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defstruct word text)
POFTHEDAY&amp;gt; (defstruct white-space)

POFTHEDAY&amp;gt; (defmethod print-object ((obj word) stream)
             (format stream &amp;quot;&amp;lt;WORD ~A&amp;gt;&amp;quot; (word-text obj)))

POFTHEDAY&amp;gt; (defmethod print-object ((obj white-space) stream)
             (format stream &amp;quot;&amp;lt;SPACE&amp;gt;&amp;quot;))

POFTHEDAY&amp;gt; (defparameter *tokens*
             (list (make-word :text &amp;quot;Bob&amp;quot;)
                   (make-white-space)
                   (make-word :text &amp;quot;loves&amp;quot;)
                   (make-white-space)
                   (make-word :text &amp;quot;Alice&amp;quot;)))
(&amp;lt;WORD Bob&amp;gt; &amp;lt;SPACE&amp;gt; &amp;lt;WORD loves&amp;gt; &amp;lt;SPACE&amp;gt; &amp;lt;WORD Alice&amp;gt;)

POFTHEDAY&amp;gt; (split-sequence:split-sequence-if
            (lambda (item)
              (typep item &amp;#039;white-space))
              *tokens*)
((&amp;lt;WORD Bob&amp;gt;) (&amp;lt;WORD loves&amp;gt;) (&amp;lt;WORD Alice&amp;gt;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;By the way, a library &lt;code&gt;cl-utilities&lt;/code&gt;, reviewed &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0068-cl-utilities.html&quot;&gt;two days ago&lt;/a&gt;, and &lt;code&gt;rutils&lt;/code&gt;, reviewed at &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0065-rutils.html&quot;&gt;the start of the week&lt;/a&gt;, are also include these splitting functions, but code is different. Probably this is because &lt;code&gt;split-sequence&lt;/code&gt; evolved since it was copied into  &lt;code&gt;cl-utilities&lt;/code&gt; and &lt;code&gt;rutils&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This simple &lt;a href=&quot;https://ultralisp.org/search/?query=symbol%3Asplit-sequence-if&quot;&gt;search query&lt;/a&gt; on Ultralisp.org shows that this functionality is also available in some other Common Lisp libraries.&lt;/p&gt;
&lt;h2&gt;Update 1&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/fwoaroof/status/1261736998412271616&quot;&gt;@fwoaroof&lt;/a&gt; gave me a &lt;a href=&quot;https://github.com/fiddlerwoaroof/fwoar.lisputils/blob/master/string-utils/split.lisp&quot;&gt;link to the split function&lt;/a&gt;, optimized to work with very long (&gt; 1G) strings.&lt;/p&gt;
&lt;h2&gt;Update 2&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/stevelosh&quot;&gt;@stevelosh&lt;/a&gt; &lt;a href=&quot;https://twitter.com/stevelosh/status/1261749896656424967&quot;&gt;sent me a code&lt;/a&gt; which uses &lt;code&gt;split-sequence&lt;/code&gt; to make an iterator:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun spliterator (delimiter sequence &amp;amp;key (test #&amp;#039;eql) (key #&amp;#039;identity))
  (let ((start 0)
        (length (length sequence)))
    (lambda ()
      (if (= start length)
          (values nil nil)
          (multiple-value-bind (next end)
              (split-sequence:split-sequence delimiter sequence
                                             :count 1 :start start
                                             :key key :test test)
            (setf start end)
            (values (first next) t))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Thank you, Steve!&lt;/p&gt;
</description>
        </item>
        <item>
            <title>osicat</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0069-osicat.html</link>
            <description>&lt;p&gt;This is a library, created by &lt;a href=&quot;https://twitter.com/nsiivola&quot;&gt;@nsiivola&lt;/a&gt;. It is well suited if you need to call &lt;a href=&quot;https://en.wikipedia.org/wiki/POSIX&quot;&gt;POSIX&lt;/a&gt; API. &lt;code&gt;Osicat&lt;/code&gt; has outdated documentation but it is has docstring and the code is well structured.&lt;/p&gt;
&lt;p&gt;Using &lt;code&gt;osicat&lt;/code&gt;, you can work with files and make other system calls.&lt;/p&gt;
&lt;p&gt;Here is an example of how you can get information about files:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (osicat:file-kind &amp;quot;/tmp&amp;quot;)
:SYMBOLIC-LINK

POFTHEDAY&amp;gt; (osicat:read-link &amp;quot;/tmp&amp;quot;)
#P&amp;quot;private/tmp&amp;quot;

POFTHEDAY&amp;gt; (osicat:file-permissions &amp;quot;/tmp&amp;quot;)
(:USER-READ :USER-WRITE :USER-EXEC :GROUP-READ
 :GROUP-WRITE :GROUP-EXEC :OTHER-READ
 :OTHER-WRITE :OTHER-EXEC :STICKY)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I&apos;ve never used &lt;code&gt;osicat&lt;/code&gt; before. When preparing this review, I noticed it has functions to make such system calls like &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;close&lt;/code&gt; and I wondered if it will be faster to implement such a handy operation like reading lines from a file using these calls instead of streams.&lt;/p&gt;
&lt;p&gt;So, let&apos;s compare the performance of the native Common Lisp streams and raw POSIX calls when we want to read all lines of the large log file.&lt;/p&gt;
&lt;p&gt;I have a 26M log file &lt;code&gt;/var/log/install.log&lt;/code&gt; on my disk.&lt;/p&gt;
&lt;p&gt;As a baseline, we&apos;ll take the performance of the &lt;code&gt;uiop:read-file-lines&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (time
            (length
             (uiop:read-file-lines *filename*)))
Evaluation took:
  0.610 seconds of real time
  0.610132 seconds of total run time (0.549502 user, 0.060630 system)
  [ Run times consist of 0.119 seconds GC time, and 0.492 seconds non-GC time. ]
  100.00% CPU
  1,346,441,256 processor cycles
  300,767,776 bytes consed
  
76560 ;; This is the number of lines&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how we can open a file and read a piece into the buffer, using POSIX system calls:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *filename* &amp;quot;/var/log/install.log&amp;quot;)

POFTHEDAY&amp;gt; (defparameter *fd* (osicat-posix:open *filename*
                                                 osicat-posix::o-rdonly))

POFTHEDAY&amp;gt; (cffi:with-foreign-pointer-as-string ((buf buf-size) 1024)
             (osicat-posix:read *fd* buf buf-size))
&amp;quot;Feb 25 09:58:02 localhost opendirectoryd[231]: opendirectoryd (build 692.000) launched - installer mode
Feb 25 09:58:02 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Initialize trigger support
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] Failed to open file &amp;lt;private&amp;gt; [2: No such file or directory]
Feb 25 09:58:03 localhost opendirectoryd[231]: [default] created endpoint for mach service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Registered RPC over XPC &amp;#039;reset_cache&amp;#039; for service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Registered RPC over XPC &amp;#039;reset_online&amp;#039; for service &amp;#039;com.apple.private.opendirectoryd.rpc&amp;#039;
Feb 25 09:58:03 localhost opendirectoryd[231]: [session] Re&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But we want to read a string, separated by newlines. In this scenario, code will be more complex:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun read-lines (filename &amp;amp;key (separator #\Newline))
  (declare (optimize (speed 3) (debug 0) (safety 0))
  
  (let ((fd (osicat-posix:open filename
                               osicat-posix::o-rdonly))
        (current-string &amp;quot;&amp;quot;)
        (separator (char-code separator)))
    (uiop:while-collecting (collect-string)
      (unwind-protect
           (cffi:with-foreign-pointer (buf 1024 buf-size)
             (flet ((collect-lines (num-bytes)
                      (loop with begin of-type fixnum = 0
                            for offset of-type fixnum from 0 below num-bytes
                            for char = (cffi:mem-ref buf :unsigned-char offset)
                            
                            when (= char separator)
                              do (let ((part (cffi:foreign-string-to-lisp
                                              buf
                                              :offset begin
                                              :count (- offset begin))))
                                   (setf begin (1+ offset))
                                   
                                   (cond ((zerop (length current-string))
                                          (collect-string part))
                                         (t
                                          (collect-string
                                           (concatenate &amp;#039;string part))
                                          (setf current-string &amp;quot;&amp;quot;))))
                            finally (unless (= offset num-bytes)
                                      (setf current-string
                                            (concatenate &amp;#039;string
                                                         current-string
                                                         (cffi:foreign-string-to-lisp
                                                          buf
                                                          :offset begin
                                                          :count (- offset begin))))))))
               (loop for num-bytes of-type fixnum = (osicat-posix:read fd buf buf-size)
                     while (not (zerop num-bytes))
                     do (collect-lines num-bytes)
                     finally (when (not (zerop (length current-string)))
                               (collect-string current-string))))))
        (osicat-posix:close fd))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I tried to put proper type declarations, and performance is 2.3 times faster than &lt;code&gt;uiop:read-file-lines&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (time (length (read-lines *filename*)))
Evaluation took:
  0.233 seconds of real time
  0.232355 seconds of total run time (0.203830 user, 0.028525 system)
  [ Run times consist of 0.036 seconds GC time, and 0.197 seconds non-GC time. ]
  99.57% CPU
  514,348,582 processor cycles
  87,868,848 bytes consed
  
76560&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now the sad part of this story. If we compare performance with such interpreted language as Python, then Python will be 4.5 times faster than my optimized function :(&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; python&apos;&gt;In [1]: def read_lines(filename):
   ...:     l = []
   ...:     with open(filename) as f:
   ...:         for line in f:
   ...:             l.append(line)
   ...:     return l

In [2]: def count_lines(filename):
   ...:     return len(read_lines(filename))

In [3]: %timeit count_lines(&amp;quot;/var/log/install.log&amp;quot;)
55.5 ms &amp;#xB1; 3.94 ms per loop (mean &amp;#xB1; std. dev. of 7 runs, 10 loops each)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;CFFI uses &lt;a href=&quot;https://github.com/cl-babel/babel&quot;&gt;Babel&lt;/a&gt; to convert bytes to string but makes few unnecessary calls.&lt;/p&gt;
&lt;p&gt;I tried to extract UTF-8 decoder from the &lt;a href=&quot;https://github.com/cl-babel/babel&quot;&gt;Babel&lt;/a&gt; into a single function, but it&apos;s internals too complex, to finish this task in one evening.&lt;/p&gt;
&lt;p&gt;If somebody knows fast Common Lisp implementation of the UTF-8 decoder, let me know and I&apos;ll update my article with new code. Probably &lt;code&gt;trivial-utf-8:utf-8-bytes-to-string&lt;/code&gt; will do the job if I&apos;ll modify it to read bytes from the alien pointer?&lt;/p&gt;
&lt;h2&gt;Update 1&lt;/h2&gt;&lt;p&gt;I&apos;ve runned the code under a SBCL&apos;s statistical profiler and build this flamegraph:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0069/read-lines-flamegraph.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;It shows that:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;50% of time wasted in my function read-line&lt;/li&gt;&lt;li&gt;10% is utf-8  decoding&lt;/li&gt;&lt;li&gt;40% – in a &quot;read&quot; syscall.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;This is strange, because when I remove all code which converts utf-8 and just reads whole file piece by piece it takes 25-30ms only.&lt;/p&gt;
&lt;p&gt;This can be improved if I&apos;ll use 10kb buffer instead of 1kb. In this case reading will take 7ms.&lt;/p&gt;
&lt;p&gt;Also, I found that the most consing occur in the &lt;code&gt;cffi:foreign-string-to-lisp&lt;/code&gt; call.&lt;/p&gt;
&lt;h2&gt;Update 2&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://twitter.com/luismbo&quot;&gt;@luismbo&lt;/a&gt; &lt;a href=&quot;https://twitter.com/luismbo/status/1261738185203298306&quot;&gt;found&lt;/a&gt; that CPython uses a &lt;a href=&quot;https://github.com/python/cpython/blob/a1d12bb1197d9335fcb62aad7fb0df56098197ac/Objects/unicodeobject.c#L4549&quot;&gt;shortcut trick&lt;/a&gt; to not decode string if it consists of ASCII characters. That is why it can be more performant than my Common Lisp &lt;code&gt;read-lines&lt;/code&gt; function.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-utilities</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0068-cl-utilities.html</link>
            <description>&lt;p&gt;This is a yet another utilities library. It is used by only a single &lt;code&gt;poftheday&lt;/code&gt;&apos;s dependency - &lt;code&gt;xml-emitter&lt;/code&gt;, &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0064-xml-emitter.html&quot;&gt;reviewed&lt;/a&gt; on 10 May.&lt;/p&gt;
&lt;p&gt;Amount of tools in this toolbox is not very large and mostly covered by more popular libs.&lt;/p&gt;
&lt;p&gt;For example, it has a macro for item collection. For example, this macro can be useful to collect hash key value pairs into an alist. But this facility is also available from UIOP:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (cl-utilities:collecting
               (maphash
                (lambda (key value)
                  (cl-utilities:collect
                      (cons key value)))
                the-hash)))
((:FOO . &amp;quot;bar&amp;quot;) (:BLAH . &amp;quot;minor&amp;quot;))

;; Here is the similar code using UIOP
POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (uiop:while-collecting (collect)
               (maphash
                (lambda (key value)
                  (collect (cons key value)))
                the-hash)))
((:FOO . &amp;quot;bar&amp;quot;) (:BLAH . &amp;quot;minor&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But UIOP is more powerful allows you to collect many types of items simultaneously. For example, we might want to collect keys and values into the separate lists:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((the-hash #h(:foo &amp;quot;bar&amp;quot;
                              :blah &amp;quot;minor&amp;quot;)))
             (uiop:while-collecting (collect-key collect-value)
               (maphash
                (lambda (key value)
                  (collect-key key)
                  (collect-value value))
                the-hash)))
(:FOO :BLAH)
(&amp;quot;bar&amp;quot; &amp;quot;minor&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;An interesting feature is a function &lt;code&gt;read-delimited&lt;/code&gt;. It can be useful to read chars from the stream into a limited buffer:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (with-input-from-string (stream &amp;quot;The string
with multiple
lines.&amp;quot;)
             (let ((buffer (str:repeat 10 &amp;quot; &amp;quot;)))
               (loop for num-chars = (cl-utilities:read-delimited
                                      buffer
                                      stream)
                     while (not (zerop num-chars))
                     do (format t &amp;quot;~A chars were read~%&amp;quot;
                                num-chars)
                        (format t &amp;quot;Buffer: ~A~2%&amp;quot;
                                (str:substring 0 num-chars
                                               buffer)))))
10 chars were read
Buffer: The string

10 chars were read
Buffer: with multi

2 chars were read
Buffer: le

6 chars were read
Buffer: lines.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Probably this facility is also covered by more popular utility library?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>parse-declarations</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0067-parse-declarations.html</link>
            <description>&lt;p&gt;This library provides advanced facilities to work with declaration forms and can be useful for writing macroses.&lt;/p&gt;
&lt;p&gt;I wasn&apos;t able to imagine a good enough example, but luckily, this library has &lt;a href=&quot;https://common-lisp.net/project/parse-declarations/manual/html_node/Examples.html#Examples&quot;&gt;great documentation&lt;/a&gt; and I stole this example from it.&lt;/p&gt;
&lt;p&gt;It is an analogue of the standard &lt;code&gt;let*&lt;/code&gt; form which expands into multiple &lt;code&gt;let&lt;/code&gt; forms. Maybe you know, &lt;code&gt;let*&lt;/code&gt; can have declarations inside. But to process them correctly, you need to place a declaration related to each variable into its own &lt;code&gt;let&lt;/code&gt; form.&lt;/p&gt;
&lt;p&gt;Here is how this can be done with &lt;code&gt;parse-declarations&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; System and package names are different:
POFTHEDAY&amp;gt; (ql:quickload :parse-declarations-1.0)

POFTHEDAY&amp;gt; (import &amp;#039;(tcr.parse-declarations-1.0::parse-body
                     tcr.parse-declarations-1.0:filter-declaration-env
                     tcr.parse-declarations-1.0:build-declarations
                     tcr.parse-declarations-1.0:check-declaration-env
                     tcr.parse-declarations-1.0:parse-declarations))

POFTHEDAY&amp;gt; (defmacro custom-let* (bindings &amp;amp;body body &amp;amp;environment macro-env)
    (flet ((normalize-binding (binding)
             (cond ((symbolp binding)    `(,binding nil))
                   ((null (cdr binding)) `(,(car binding) nil))
                   (t binding))))
      (multiple-value-bind (real-body decls) (parse-body body :documentation nil)
        (let ((decl-env (parse-declarations decls macro-env)))
          (check-declaration-env decl-env :unknown-allowed nil :warn-only t)
          (labels ((generate-nested-lets (bindings &amp;amp;optional used-binding-names)
                     (if (null bindings)
                         `(locally
                              ,@(build-declarations &amp;#039;declare
                                  (filter-declaration-env decl-env :include :free)
                                  (filter-declaration-env decl-env :include :bound
                                                          :not-affecting used-binding-names))
                            ,@real-body)
                         (destructuring-bind ((var value) . more-bindings) bindings
                           `(let ((,var ,value))
                              ,@(build-declarations &amp;#039;declare
                                  (filter-declaration-env decl-env :affecting `(,var)))
                              ,(generate-nested-lets more-bindings (cons var used-binding-names)))))))
            (generate-nested-lets (mapcar #&amp;#039;normalize-binding bindings)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pay attention that &lt;code&gt;parse-body&lt;/code&gt; function is intentionally is not exported to not conflict with &lt;code&gt;alexandria:parse-body&lt;/code&gt;. Author considered that many lispers do import all alexandria&apos;s symbols into their packages.&lt;/p&gt;
&lt;p&gt;By the way, Alexandria implements only a simple version of the &lt;code&gt;parse-body&lt;/code&gt; function and does not support all advanced features of &lt;code&gt;parse-declarations&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;But let&apos;s see how our macro will expand!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (custom-let* ((a 1)
                         (b (* a 0.01)))
             (declare (type fixnum a)
                      (type single-float b))
             (list a b))

;; It expands to -&amp;gt;
(let ((a 1))
  (declare (type fixnum a))
  (let ((b (* a 0.01)))
    (declare (type single-float b))
    (locally (list a b))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you can see, our single declaration form was torn apart and each part placed into the correct place inside nested &lt;code&gt;lets&lt;/code&gt;. Great!&lt;/p&gt;
&lt;h2&gt;How does it work&lt;/h2&gt;&lt;p&gt;There are three phases:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;parse-declarations&lt;/code&gt; parses whole body passed to the &lt;code&gt;custom-let*&lt;/code&gt; and   extracts forms related to type declarations. It stores them in a   special &lt;code&gt;env&lt;/code&gt; object.&lt;/li&gt;&lt;li&gt;&lt;code&gt;filter-declaration-env&lt;/code&gt; allows us to select only declarations related   to the needed variable.&lt;/li&gt;&lt;li&gt;&lt;code&gt;build-declarations&lt;/code&gt; transforms one or many &lt;code&gt;env&lt;/code&gt; objects into the lists   of symbols so that they can be used for the macro-expansion.&lt;/li&gt;&lt;/ul&gt;
</description>
        </item>
        <item>
            <title>str</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0066-str.html</link>
            <description>&lt;p&gt;This is a single purpose utility library. Before switching to the &lt;code&gt;str&lt;/code&gt;, I used &lt;code&gt;cl-strings&lt;/code&gt;, but &lt;code&gt;str&lt;/code&gt; library is more consistent.&lt;/p&gt;
&lt;p&gt;I like that unlike standard functions, &lt;code&gt;str&lt;/code&gt; is able to work with chars and strings as delimiter:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (str:split #\Space
                      &amp;quot;Foo bar bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)

POFTHEDAY&amp;gt; (str:split &amp;quot; &amp;quot;
                      &amp;quot;Foo bar bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)

;; Also it is able to skip empty strings:
POFTHEDAY&amp;gt; (str:split &amp;quot; &amp;quot;
                      &amp;quot;Foo   bar   bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;&amp;quot; &amp;quot;&amp;quot; &amp;quot;bazz&amp;quot;)

POFTHEDAY&amp;gt; (str:split-omit-nulls &amp;quot; &amp;quot;
                      &amp;quot;Foo   bar   bazz&amp;quot;)
(&amp;quot;Foo&amp;quot; &amp;quot;bar&amp;quot; &amp;quot;bazz&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Parameter ordering can seem a little strange at first glance, but they&apos;ve made this way to make it easier to &lt;code&gt;curry&lt;/code&gt; functions.&lt;/p&gt;
&lt;p&gt;For example, if we have a multiline text and want to put ellipsis at the end of string longer than X, we might do:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (defvar *text* &amp;quot;
This line is much longer than we need.
This one is also too long.

I can&amp;#039;t belive!
&amp;quot;&amp;quot;&amp;quot;)

POFTHEDAY&amp;gt; (str:unlines
            (mapcar (alexandria:curry #&amp;#039;str:shorten 20)
                    (str:lines *text*)))
&amp;quot;
This line is much...
This one is also ...

I can&amp;#039;t belive!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;BTW &lt;code&gt;str&lt;/code&gt; has very &lt;a href=&quot;https://vindarel.github.io/cl-str/&quot;&gt;cool documentation&lt;/a&gt;. I&apos;d like to have such docs for other CL libraries.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>rutils</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0065-rutils.html</link>
            <description>&lt;p&gt;Rutils translated as Radical Utilities. It is a collection of many useful utilities. Some of the utilities can be found in other libraries, for example, arrow macro or short notation for lambdas.&lt;/p&gt;
&lt;p&gt;There is an interesting &lt;a href=&quot;https://github.com/vseloved/rutils/blob/master/docs/ann-rutils.md&quot;&gt;document&lt;/a&gt; which describes why &lt;code&gt;rutils&lt;/code&gt; is so radical. In short - it provides a reader macro for hash tables and short aliases for many common lisp operators and generic accessors. &lt;/p&gt;
&lt;p&gt;Previously I didn&apos;t dig into the &lt;code&gt;rutils&lt;/code&gt; documentation and used only a few functions to work with lists. But now I found a &lt;a href=&quot;https://github.com/vseloved/rutils/blob/master/docs/tutorial.md&quot;&gt;great tutorial&lt;/a&gt; covering most &lt;code&gt;rutils&lt;/code&gt; features. I recommend you to spend few evenings reading it and trying different code samples.&lt;/p&gt;
&lt;p&gt;Here is a small example which demonstrates how hash table syntax and generic accessors work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (named-readtables:in-readtable rutils:rutils-readtable)

POFTHEDAY&amp;gt; (import &amp;#039;rutils:?)

POFTHEDAY&amp;gt; (let ((obj #h(:foo &amp;#039;(1 2 3))))
             (? obj :foo 1))
2

;; It also works with curly braces:
POFTHEDAY&amp;gt; (let ((obj #{:foo &amp;#039;(1 2 3)}))
             (? obj :foo 1))
2&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here a question mark is an abbreviation for &lt;code&gt;rutils:generic-elt&lt;/code&gt; generic and you can define a custom method to access different kinds of containers.&lt;/p&gt;
&lt;p&gt;I definitely will try to use more of &lt;code&gt;rutils&lt;/code&gt; in my code now.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>xml-emitter</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0064-xml-emitter.html</link>
            <description>&lt;p&gt;This library can be used to generate XML. You can use it for outputting any XML, but I use its builtin helpers to generate RSS feed.&lt;/p&gt;
&lt;p&gt;Here is how to generate RSS feed in Common Lisp:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (with-output-to-string (s)
             (xml-emitter:with-rss2 (s :encoding &amp;quot;utf-8&amp;quot;)
               (xml-emitter:rss-channel-header &amp;quot;Common Lisp Project of the Day&amp;quot; 
                                               &amp;quot;https://poftheday.org&amp;quot;)
               (xml-emitter:rss-item &amp;quot;First post&amp;quot;
                                     :description &amp;quot;Hello World&amp;quot;
                                     :category &amp;quot;lisp&amp;quot;)))

&amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;utf-8\&amp;quot;?&amp;gt;
&amp;lt;rss version=\&amp;quot;2.0\&amp;quot;&amp;gt;
    &amp;lt;channel&amp;gt;
        &amp;lt;title&amp;gt;Common Lisp Project of the Day&amp;lt;/title&amp;gt;
        &amp;lt;link&amp;gt;https://poftheday.org&amp;lt;/link&amp;gt;
        &amp;lt;generator&amp;gt;xml-emitter&amp;lt;/generator&amp;gt;
        &amp;lt;language&amp;gt;en-us&amp;lt;/language&amp;gt;
        &amp;lt;item&amp;gt;
            &amp;lt;title&amp;gt;First post&amp;lt;/title&amp;gt;
            &amp;lt;description&amp;gt;Hello World&amp;lt;/description&amp;gt;
            &amp;lt;category&amp;gt;lisp&amp;lt;/category&amp;gt;
        &amp;lt;/item&amp;gt;
    &amp;lt;/channel&amp;gt;
&amp;lt;/rss&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Of cause, you easily can generate any XML as well:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (with-output-to-string (s)
             (xml-emitter:with-xml-output (s)
               (xml-emitter:with-tag (&amp;quot;address-book&amp;quot;)
                 (xml-emitter:with-tag (&amp;quot;contact&amp;quot;)
                   (xml-emitter:emit-simple-tags
                    :name &amp;quot;Bob&amp;quot;
                    :email &amp;quot;bob@perkins.com&amp;quot;
                    :note &amp;quot;My friend.&amp;quot;))
                 (xml-emitter:with-tag (&amp;quot;contact&amp;quot;)
                   (xml-emitter:emit-simple-tags
                    :name &amp;quot;Mary&amp;quot;
                    :twitter &amp;quot;https://twitter.com/mary&amp;quot;)))))

&amp;quot;&amp;lt;?xml version=\&amp;quot;1.0\&amp;quot; encoding=\&amp;quot;ISO-8859-1\&amp;quot;?&amp;gt;
&amp;lt;address-book&amp;gt;
    &amp;lt;contact&amp;gt;
        &amp;lt;name&amp;gt;Bob&amp;lt;/name&amp;gt;
        &amp;lt;email&amp;gt;bob@perkins.com&amp;lt;/email&amp;gt;
        &amp;lt;note&amp;gt;My friend.&amp;lt;/note&amp;gt;
    &amp;lt;/contact&amp;gt;
    &amp;lt;contact&amp;gt;
        &amp;lt;name&amp;gt;Mary&amp;lt;/name&amp;gt;
        &amp;lt;twitter&amp;gt;https://twitter.com/mary&amp;lt;/twitter&amp;gt;
    &amp;lt;/contact&amp;gt;
&amp;lt;/address-book&amp;gt;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Please, note that support for &lt;a href=&quot;https://www.w3schools.com/xml/xml_namespaces.asp&quot;&gt;XML namespaces&lt;/a&gt; is very limited. You can only specify a namespace for some tags. Namespace prefixes are not supported.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>asdf-viz</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0063-asdf-viz.html</link>
            <description>&lt;p&gt;Today I decided it will be more interesting to investigate Lisp systems which I already have as dependencies of my projects. That is why I&apos;ve remembered about &lt;code&gt;asdf-viz&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ASDF-VIZ&lt;/code&gt; is able to render a graph of ASDF systems. It can be installed as Unix scripts using &lt;a href=&quot;https://github.com/roswell/roswell&quot;&gt;Roswell&lt;/a&gt; or used from the REPL.&lt;/p&gt;
&lt;p&gt;Also, you&apos;ll need a &lt;a href=&quot;https://www.graphviz.org/&quot;&gt;Graphviz&lt;/a&gt; program installed.&lt;/p&gt;
&lt;p&gt;Now we&apos;ll render a graph of all dependencies of the &lt;code&gt;poftheday&lt;/code&gt; system:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (setf cl-dot:*dot-path* &amp;quot;/usr/local/bin/dot&amp;quot;)

POFTHEDAY&amp;gt; (asdf-viz:visualize-asdf-hierarchy
            &amp;quot;docs/media/0063/systems.png&amp;quot;
            (list (asdf:find-system :poftheday)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is the result:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0063/systems.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Interestingly, &lt;code&gt;asdf-viz&lt;/code&gt; not only can draw a system&apos;s dependencies but also class hierarchies and call graphs.&lt;/p&gt;
&lt;p&gt;Here is a small example, how to render a class hierarchy:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;POFTHEDAY&amp;gt; (asdf-viz.class-hierarchy:visualize-class-hierarchy
            &amp;quot;docs/media/0063/classes.png&amp;quot;
            (list &amp;#039;cl-org-mode::node))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And this is the resulting graph:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0063/classes.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;I think it might be useful to integrate &lt;code&gt;asdf-viz&lt;/code&gt; into IDE.&lt;/p&gt;
&lt;p&gt;Probably Emacs might show graphs in a separate buffer? Or LispWorks IDE is able to do this?&lt;/p&gt;
&lt;p&gt;P.S. – next system will be chosen from the dependencies of the &lt;code&gt;poftheday&lt;/code&gt; system.&lt;/p&gt;
</description>
        </item>
        <item>
            <title>magic-ed</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0062-magic-ed.html</link>
            <description>&lt;p&gt;This strange library replaces standard &lt;code&gt;cl:ed&lt;/code&gt; function with a new one, which executes editor specified in the &lt;code&gt;EDITOR&lt;/code&gt; environment variable.&lt;/p&gt;
&lt;p&gt;It does not work from SLY, so I had to run a raw REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;* sb-ext:*ed-functions*
 NIL
 * (cl:ed &amp;quot;qlfile&amp;quot;)

 debugger invoked on a SB-INT:EXTENSION-FAILURE in thread
 #&amp;lt;THREAD &amp;quot;main thread&amp;quot; RUNNING {1000518083}&amp;gt;:
   Don&amp;#039;t know how to ED qlfile
 See also:
   The SBCL Manual, Variable *ED-FUNCTIONS*

 Type HELP for debugger help, or (SB-EXT:EXIT) to exit from SBCL.

 restarts (invokable by number or by possibly-abbreviated name):
   0: [ABORT] Exit debugger, returning to top level.

 (ED &amp;quot;qlfile&amp;quot;)
 0] ^D
 * (ql:quickload :magic-ed)
 To load &amp;quot;magic-ed&amp;quot;:
   Load 1 ASDF system:
     magic-ed
 ; Loading &amp;quot;magic-ed&amp;quot;

 (:MAGIC-ED)
 * sb-ext:*ed-functions*
 (MAGIC-ED:ED-EDITOR)
 * (cl:ed &amp;quot;qlfile&amp;quot;)
 T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, this library provides a function &lt;code&gt;magic-ed&lt;/code&gt; which is able to return file&apos;s content and evaluate the lisp code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;* (magic-ed:magic-ed &amp;quot;/tmp/foo&amp;quot; :output :string)
 ...
 HERE Vim WAS STARTED AND I EDITED THE FILE
 ...
 &amp;quot;(format t \&amp;quot;Blah~%\&amp;quot;)
 &amp;quot;
 *&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Can somebody tell me when this could be useful if you can just use Emacs and SLIME?&lt;/p&gt;
</description>
        </item>
        <item>
            <title>cl-charms</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/05/0061-cl-charms.html</link>
            <description>&lt;p&gt;Two days ago I &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/05/0059-cl-ncurses.html&quot;&gt;reviewed the cl-ncurses&lt;/a&gt;. &lt;code&gt;CL-Charms&lt;/code&gt; is also a binding to &lt;code&gt;ncurses&lt;/code&gt;, but uses more universal and portable &lt;a href=&quot;https://common-lisp.net/project/cffi/manual/html_node/&quot;&gt;CFFI&lt;/a&gt; instead of &lt;a href=&quot;http://quickdocs.org/uffi/&quot;&gt;UFFI&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;By the way, LEM (Common Lisp Emacs) uses &lt;code&gt;cl-charms&lt;/code&gt; for it&apos;s console backend.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CL-Charms&lt;/code&gt; provides a high-level API besides a low level. I&apos;ve ported my previous &lt;code&gt;echo&lt;/code&gt; program to it:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;(defun main (&amp;amp;rest argv)
  (declare (ignorable argv))
  (with-curses ()
    (enable-raw-input)
    (enable-extra-keys *standard-window*)
    (disable-echoing)

    (write-string-at-cursor *standard-window*
                            &amp;quot;Type any character to see it in bold:
&amp;quot;)

    (let ((ch (get-char *standard-window*)))

      (cond
        ((eql ch (code-char 265))
         (write-string-at-cursor *standard-window*
                                 &amp;quot;F1 Key pressed&amp;quot;))
        (t
         (write-string-at-cursor *standard-window*
                                 &amp;quot;The pressed key is &amp;quot;)

         (cl-charms/low-level:attron cl-charms/low-level:a_bold)
         (write-string-at-cursor *standard-window*
                                 (format nil &amp;quot;~A~%&amp;quot; ch))
         (cl-charms/low-level:attroff cl-charms/low-level:a_bold)))
      

      (get-char *standard-window*))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Interesting that &lt;code&gt;cl-charms/low-level&lt;/code&gt; package can be used as a drop-in replacement for &lt;code&gt;cl-ncurses&lt;/code&gt; and my second example worked without any changes except a change &lt;a href=&quot;https://github.com/40ants/lisp-project-of-the-day/blob/master/test/0061/window.ros#L11-L12&quot;&gt;in the use clause&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;A few words about portability&lt;/h2&gt;&lt;h3&gt;CL-NCURSES&lt;/h3&gt;&lt;p&gt;I must admit, that working with such kind of bindings can be problematic. For example, I haven&apos;t any problems using neither &lt;code&gt;cl-ncurses&lt;/code&gt; nor &lt;code&gt;cl-charms&lt;/code&gt; on OSX, but there was a problem with starting an example program on Ubuntu Bionic.&lt;/p&gt;
&lt;p&gt;On Ubuntu &lt;code&gt;cl-ncurses&lt;/code&gt; is unable to find &lt;code&gt;libncurses.so&lt;/code&gt; and you have to load it manually like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;;; These paths are harcoded in the cl-ncurses:
(defvar *ncurses-search-paths*
  #-win32&amp;#039;(&amp;quot;/usr/local/lib64/&amp;quot; &amp;quot;/usr/local/lib/&amp;quot; &amp;quot;/lib64/&amp;quot; &amp;quot;/lib/&amp;quot; &amp;quot;/usr/lib64/&amp;quot; &amp;quot;/usr/lib/&amp;quot;)
  #+win32&amp;#039;(&amp;quot;/users/jacob/src/pdc31dll/&amp;quot;))

;; On Ubuntu Bionic you have to add this
;; before cl-ncurses initscr call:
(uffi:load-foreign-library &amp;quot;/lib/x86_64-linux-gnu/libncurses.so.5.9&amp;quot;
                           :module &amp;quot;cl-ncurses&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;CL-CHARMS&lt;/h3&gt;&lt;p&gt;&lt;code&gt;CL-Charms&lt;/code&gt; has another problem. It requires the &lt;code&gt;libncurses5-dev&lt;/code&gt; package to be installed on Ubuntu. Without that, it has problem when compiling the CFFI Grovel&apos;s files:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos; lisp&apos;&gt;; cc -o /root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel-tmpBF3HHBTQ.o -c -g -Wall -Wundef -Wsign-compare -Wpointer-arith -O3 -D_LARGEFILE_SOURCE -D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64 -Wunused-parameter -fno-omit-frame-pointer -momit-leaf-frame-pointer -fno-pie -fPIC -I/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.21.0/ /root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel.c
/root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel.c:6:10: fatal error: ncurses.h: No such file or directory
 #include &amp;lt;ncurses.h&amp;gt;
          ^~~~~~~~~~~
compilation terminated.
Unhandled CFFI-GROVEL:GROVEL-ERROR in thread #&amp;lt;error printing a SB-THREAD:THREAD: #&amp;lt;PRINT-NOT-READABLE {10042938A3}&amp;gt;&amp;gt;: Subprocess #&amp;lt;UIOP/LAUNCH-PROGRAM::PROCESS-INFO {100428DCF3}&amp;gt;
 with command (&amp;quot;cc&amp;quot; &amp;quot;-o&amp;quot; &amp;quot;/root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel-tmpBF3HHBTQ.o&amp;quot; &amp;quot;-c&amp;quot; &amp;quot;-g&amp;quot; &amp;quot;-Wall&amp;quot; &amp;quot;-Wundef&amp;quot; &amp;quot;-Wsign-compare&amp;quot; &amp;quot;-Wpointer-arith&amp;quot; &amp;quot;-O3&amp;quot; &amp;quot;-D_LARGEFILE_SOURCE&amp;quot; &amp;quot;-D_LARGEFILE64_SOURCE&amp;quot; &amp;quot;-D_FILE_OFFSET_BITS=64&amp;quot; &amp;quot;-Wunused-parameter&amp;quot; &amp;quot;-fno-omit-frame-pointer&amp;quot; &amp;quot;-momit-leaf-frame-pointer&amp;quot; &amp;quot;-fno-pie&amp;quot; &amp;quot;-fPIC&amp;quot; &amp;quot;-I/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cffi_0.21.0/&amp;quot; &amp;quot;/root/.cache/common-lisp/sbcl-1.5.6-linux-x64/root/.roswell/lisp/quicklisp/dists/quicklisp/software/cl-charms-20200218-git/src/low-level/curses-grovel__grovel.c&amp;quot;)
 exited with error code 1

Backtrace for: #&amp;lt;SB-THREAD:THREAD &amp;quot;main thread&amp;quot; RUNNING {10004F04C3}&amp;gt;
0: (SB-DEBUG::DEBUGGER-DISABLED-HOOK #&amp;lt;CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; {1004291F73}&amp;gt; #&amp;lt;unused argument&amp;gt; :QUIT T)
1: (SB-DEBUG::RUN-HOOK *INVOKE-DEBUGGER-HOOK* #&amp;lt;CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; {1004291F73}&amp;gt;)
2: (INVOKE-DEBUGGER #&amp;lt;CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; {1004291F73}&amp;gt;)
3: (ERROR CFFI-GROVEL:GROVEL-ERROR :FORMAT-CONTROL &amp;quot;~a&amp;quot; :FORMAT-ARGUMENTS (#&amp;lt;UIOP/RUN-PROGRAM:SUBPROCESS-ERROR {10042917F3}&amp;gt;))
4: (CFFI-GROVEL:GROVEL-ERROR &amp;quot;~a&amp;quot; #&amp;lt;UIOP/RUN-PROGRAM:SUBPROCESS-ERROR {10042917F3}&amp;gt;)
5: ((FLET &amp;quot;THUNK&amp;quot; :IN CFFI-GROVEL:PROCESS-GROVEL-FILE))&lt;/code&gt;&lt;/pre&gt;&lt;h3&gt;Possible Solution?&lt;/h3&gt;&lt;p&gt;Probably, &lt;a href=&quot;https://twitter.com/borodust&quot;&gt;@borodust&lt;/a&gt;&apos;s &lt;a href=&quot;https://github.com/borodust/claw&quot;&gt;claw&lt;/a&gt; and &lt;a href=&quot;http://40ants.com/lisp-project-of-the-day/2020/04/0041-bodge-blobs-support.html&quot;&gt;bodge-blobs-support&lt;/a&gt; can solve these issues?&lt;/p&gt;
</description>
        </item>
    </channel>
</rss>