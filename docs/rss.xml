<?xml version="1.0" encoding="ISO-8859-1"?>
<rss version="2.0">
    <channel>
        <title>Common Lisp Project of the Day</title>
        <link>http://40ants.com/lisp-project-of-the-day/</link>
        <generator>xml-emitter</generator>
        <language>en-us</language>
        <item>
            <title>log4cl</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0135-log4cl.html</link>
            <description>&lt;p&gt;This is the mystery why I didn&apos;t review any logging library so far! Probably, because there is a &lt;a href=&quot;https://www.sites.google.com/site/sabraonthehill/comparison-of-lisp-logging-libraries&quot;&gt;great article&lt;/a&gt; exists which compares 8 logging libraries.&lt;/p&gt;
&lt;p&gt;Today I want only mention that my library of choice is &lt;code&gt;log4cl&lt;/code&gt;. Mostly because if it&apos;s great integration with SLIME/SLY which helps when you have a lot&apos;s of &quot;debug&quot; logging in the app, but at some moment want to turn it on only for a function or a package.&lt;/p&gt;
&lt;p&gt;Log4cl has &lt;a href=&quot;https://github.com/sharplispers/log4cl&quot;&gt;great documentation&lt;/a&gt; which demonstrates all its features. Here I&apos;ll provide only a small example of its default logging output and ability to process additional arguments:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (log:config :sane2 :debug)

POFTHEDAY&amp;gt; (defun foo (first-arg second-arg)
             (log:info &amp;quot;Entering into the foo with&amp;quot; first-arg &amp;quot;and&amp;quot; second-arg))

POFTHEDAY&amp;gt; (foo 100500 &amp;quot;Blah&amp;quot;)

 &amp;lt;INFO&amp;gt; [21:04:10] poftheday (foo) -
  Entering into the foo with FIRST-ARG: 100500 and SECOND-ARG: &amp;quot;Blah&amp;quot; 

;; Now I want to process arguments with in format-like style:

POFTHEDAY&amp;gt; (defun foo (first-arg second-arg)
             (log:info &amp;quot;Entering into the (foo ~A ~A)&amp;quot; first-arg second-arg))

POFTHEDAY&amp;gt; (foo 100500 &amp;quot;Blah&amp;quot;)
 &amp;lt;INFO&amp;gt; [21:04:53] poftheday (foo) - Entering into the (foo 100500 Blah)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow I&apos;ll show you addons I&apos;ve made, to make &lt;code&gt;log4cl&lt;/code&gt; even more suitable for production applications.&lt;/p&gt;
</description>
            <pubDate>Sun, 19 Jul 2020 21:07:55 +0300</pubDate>
        </item>
        <item>
            <title>taglib</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0134-taglib.html</link>
            <description>&lt;p&gt;The first post in the #poftheday series was about &lt;code&gt;cl-mpg123&lt;/code&gt; library. It failed on attempt to process metadata of mp3 file. Today we&apos;ll try &lt;code&gt;taglib&lt;/code&gt;. This is the pure CL library to process MP3, MP4, FLAC tags.&lt;/p&gt;
&lt;p&gt;Let&apos;s try it on the file from the zero post!&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (audio-streams:open-audio-file
            &amp;quot;docs/media/0000/file.mp3&amp;quot;)
#&amp;lt;ID3:MP3-FILE {10036524E3}&amp;gt;

POFTHEDAY&amp;gt; (abstract-tag:show-tags *)
/Users/art/projects/poftheday/docs/media/0000/file.mp3
1 frame read, MPEG 1, Layer III, CBR, sample rate: 44,100 Hz, bit rate: 320 Kbps, duration: 7:15
    album: Rogue&amp;#039;s Gallery: Pirate Ballads, Sea Songs, and Chanteys
    artist: Baby Gramps
    comment: ((0 eng  NIL))
    compilation: no
    cover: (Size: 9,870)
    genre: Folk
    lyrics:  
    title: Cape Cod Girls
    track: (1 23)
    year: 2006
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;There is also a possibility to access specific fields:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (audio-streams:open-audio-file
            &amp;quot;docs/media/0000/file.mp3&amp;quot;)
#&amp;lt;ID3:MP3-FILE {10027E6093}&amp;gt;

POFTHEDAY&amp;gt; (id3:id3-header *)
#&amp;lt;ID3:ID3-HEADER {10027E60D3}&amp;gt;

POFTHEDAY&amp;gt; (id3:v21-tag-header *)
#&amp;lt;ID3:V21-TAG-HEADER {10027E6363}&amp;gt;

POFTHEDAY&amp;gt; (id3:album *)
&amp;quot;Rogue&amp;#039;s Gallery: Pirate Ballad&amp;quot;

POFTHEDAY&amp;gt; (id3:title **)
&amp;quot;Cape Cod Girls&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Seems it works very good!&lt;/p&gt;
</description>
            <pubDate>Sat, 18 Jul 2020 22:42:56 +0300</pubDate>
        </item>
        <item>
            <title>open-location-code</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0133-open-location-code.html</link>
            <description>&lt;p&gt;This is an interesting way to encode coordinates on the planet Earth.&lt;/p&gt;
&lt;p&gt;These codes can be short enough to remember them, and they are pronounceable. What is essential – they supported by Google.&lt;/p&gt;
&lt;p&gt;For example, I have an architectural landmark in nearby Bykovo village - the &lt;a href=&quot;https://ru.wikipedia.org/wiki/Усадьба_Быково&quot;&gt;Vorontcov-Dashkov&apos;s mansion&lt;/a&gt;. Its coordinates are &lt;code&gt;55.608093&lt;/code&gt;, &lt;code&gt;38.048927&lt;/code&gt; or &lt;code&gt;55&#xB0;36&apos;29.1&quot;N 38&#xB0;02&apos;56.1&quot;E&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;This building has no address, but we can get an &quot;open location code&quot; for its location on Google Maps:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0133/map.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;J25X+6H&lt;/code&gt; is the shortened open location code for this location.&lt;/p&gt;
&lt;p&gt;You can get the full code using latitude, longitude and one line of Lisp code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:encode
            55.608093
            38.048927)
&amp;quot;9G7WJ25X+6H&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The code &lt;code&gt;9G7WJ25X+6H&lt;/code&gt; is full. It has all information to get back our latitude and longitude:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:decode &amp;quot;9G7WJ25X+6H&amp;quot;)
#&amp;lt;OPEN-LOCATION-CODE:CODE-AREA {1002BF7E13}&amp;gt;
:FULL

POFTHEDAY&amp;gt; (open-location-code:south-west-corner *)
6951/125 (55.608)
304391/8000 (38.048874)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But for short code this will not work:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:decode &amp;quot;J25X+6H&amp;quot;)
#&amp;lt;OPEN-LOCATION-CODE:CODE-AREA {10067CAAB3}&amp;gt;
:SHORT

POFTHEDAY&amp;gt; (open-location-code:south-west-corner *)
76/125 (0.608, 304/5%)
391/8000 (0.048875, 391/80%)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To get the coordinates, you need to &quot;recover&quot; the full code first. This is done using some reference point. For example, we can take the nearest village&apos;s coordinates as the reference point:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (open-location-code:recover
            &amp;quot;J25X+6H&amp;quot;
            55.634068
            38.044629)
&amp;quot;9G7WJ25X+6H&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This is the same code we&apos;ve received from mansion&apos;s coordinates. You can open the Google Maps and search the code &lt;code&gt;9G7WJ25X+6H&lt;/code&gt; to check it. In real life short codes are used together with the name of the nearest city, like &lt;code&gt;J25X+6H Быково, Московская обл.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;That is for today. For me, open location codes were an exciting discovery. Didn&apos;t hear about them before.&lt;/p&gt;
</description>
            <pubDate>Fri, 17 Jul 2020 23:38:24 +0300</pubDate>
        </item>
        <item>
            <title>cl-irc</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0132-cl-irc.html</link>
            <description>&lt;p&gt;Today we&apos;ll write a simple bot to keep a history of the IRC channel. IRC is a chat protocol that existed before Slack, Telegram, etc.&lt;/p&gt;
&lt;p&gt;For the test I&apos;ve installed a local lisp server on my OSX:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[poftheday:~]% brew install ngircd
Updating Homebrew...
...
==&amp;gt; Caveats
==&amp;gt; ngircd
To have launchd start ngircd now and restart at login:
  brew services start ngircd

[poftheday:~]% /usr/local/sbin/ngircd --nodaemon --passive

[poftheday:~]% /usr/local/sbin/ngircd --nodaemon --passive
[66510:5    0] ngIRCd 26-IDENT+IPv6+IRCPLUS+SSL+SYSLOG+ZLIB-x86_64/apple/darwin19.5.0 starting ...
[66510:6    0] Using configuration file &amp;quot;/usr/local/etc/ngircd.conf&amp;quot; ...
[66510:3    0] Can&amp;#039;t read MOTD file &amp;quot;/usr/local/etc/ngircd.motd&amp;quot;: No such file or directory
[66510:4    0] No administrative information configured but required by RFC!
[66510:6    0] ServerUID must not be root(0), using &amp;quot;nobody&amp;quot; instead.
[66510:3    0] Can&amp;#039;t change group ID to nobody(4294967294): Operation not permitted!
[66510:3    0] Can&amp;#039;t drop supplementary group IDs: Operation not permitted!
[66510:3    0] Can&amp;#039;t change user ID to nobody(4294967294): Operation not permitted!
[66510:6    0] Running as user art(1345292665), group LD\Domain Users(593637566), with PID 66510.
[66510:6    0] Not running with changed root directory.
[66510:6    0] IO subsystem: kqueue (initial maxfd 100, masterfd 3).
[66510:6    0] Now listening on [0::]:6667 (socket 6).
[66510:6    0] Now listening on [0.0.0.0]:6667 (socket 8).
[66510:5    0] Server &amp;quot;irc.example.net&amp;quot; (on &amp;quot;poftheday&amp;quot;) ready.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;After that, I&apos;ve installed a command line IRC client &lt;code&gt;ircii&lt;/code&gt; and made two connections to simulate users in the #lisp channel.&lt;/p&gt;
&lt;p&gt;Now it is time to connect our bot to the server and create a thread with the message processing loop:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter
               *conn*
             (cl-irc:connect :nickname &amp;quot;bot&amp;quot;
                             :server &amp;quot;localhost&amp;quot;))

POFTHEDAY&amp;gt; (defparameter *thread*
             (bt:make-thread (lambda ()
                               (cl-irc:read-message-loop *conn*))
                             :name &amp;quot;IRC&amp;quot;))

POFTHEDAY&amp;gt; (cl-irc:join *conn* &amp;quot;#lisp&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;While messages are processed in the thread we are free to experiment in the &lt;code&gt;REPL&lt;/code&gt;. Let&apos;s add a hook to process messages from the channel:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun on-message (msg)
             (log:info &amp;quot;New message&amp;quot; msg))

POFTHEDAY&amp;gt; (cl-irc:add-hook *conn*
                            &amp;#039;cl-irc:irc-privmsg-message
                            &amp;#039;on-message)

;; Now if some of users will write to the channel,
;; the message will be logged to the screen:

POFTHEDAY&amp;gt; 
; No values
 &amp;lt;INFO&amp;gt; [22:35:43] poftheday (on-message) -
  New message POFTHEDAY::MSG: #&amp;lt;CL-IRC:IRC-PRIVMSG-MESSAGE joanna PRIVMSG {1007692DA3}&amp;gt;
  
UNHANDLED-EVENT:3803916943: PRIVMSG: joanna #lisp &amp;quot;Hello lispers!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can modify the &lt;code&gt;on-message&lt;/code&gt; function to save the last message into the global variable to inspect its structure:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; *last-msg*
#&amp;lt;CL-IRC:IRC-PRIVMSG-MESSAGE joanna PRIVMSG {1007703213}&amp;gt;

POFTHEDAY&amp;gt; (describe *)
#&amp;lt;CL-IRC:IRC-PRIVMSG-MESSAGE joanna PRIVMSG {1007703213}&amp;gt;
  [standard-object]

Slots with :INSTANCE allocation:
  SOURCE                         = &amp;quot;joanna&amp;quot;
  USER                           = &amp;quot;~art&amp;quot;
  HOST                           = &amp;quot;localhost&amp;quot;
  COMMAND                        = &amp;quot;PRIVMSG&amp;quot;
  ARGUMENTS                      = (&amp;quot;#lisp&amp;quot; &amp;quot;Hello&amp;quot;)
  CONNECTION                     = #&amp;lt;CL-IRC:CONNECTION localhost {1003918FA3}&amp;gt;
  RECEIVED-TIME                  = 3803917081
  RAW-MESSAGE-STRING             = &amp;quot;:joanna!~art@localhost PRIVMSG #lisp :Hello&#xD;&amp;quot;

;; If user sent a direct message,
;; it will have the bot&amp;#039;s username as the first argument:

POFTHEDAY&amp;gt; (describe *last-msg*)
#&amp;lt;CL-IRC:IRC-PRIVMSG-MESSAGE joanna PRIVMSG {1001600943}&amp;gt;
  [standard-object]

Slots with :INSTANCE allocation:
  SOURCE                         = &amp;quot;joanna&amp;quot;
  USER                           = &amp;quot;~art&amp;quot;
  HOST                           = &amp;quot;localhost&amp;quot;
  COMMAND                        = &amp;quot;PRIVMSG&amp;quot;
  ARGUMENTS                      = (&amp;quot;bot&amp;quot; &amp;quot;Hello. It is Joanna.&amp;quot;)
  CONNECTION                     = #&amp;lt;CL-IRC:CONNECTION localhost {1003918FA3}&amp;gt;
  RECEIVED-TIME                  = 3803917270
  RAW-MESSAGE-STRING             = &amp;quot;:joanna!~art@localhost PRIVMSG bot :Hello. It is Joanna.&#xD;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you intend to make a bot which will reply to the messages, you have to choose either &lt;code&gt;message&lt;/code&gt;&apos;s source slot or the first argument as a destination for the response.&lt;/p&gt;
&lt;p&gt;Most probably &lt;a href=&quot;https://twitter.com/SatoshiShinohai/status/1283761536109023232&quot;&gt;the bug&lt;/a&gt; &lt;a href=&quot;https://twitter.com/SatoshiShinohai&quot;&gt;@SatoshiShinohai&lt;/a&gt; complained about on Twitter is caused by the wrong algorithm for choosing the response&apos;s destination.&lt;/p&gt;
&lt;p&gt;Now let&apos;s redefine our &lt;code&gt;on-message&lt;/code&gt; function to format log messages in an accurate way:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun on-message (msg)
             (log:info &amp;quot;&amp;lt;~A&amp;gt; ~A&amp;quot;
                       (cl-irc:source msg)
                       (second (cl-irc:arguments msg)))
             ;; To let cl-irc know that we&amp;#039;ve processed the event
             ;; we need to return `t&amp;#039;.
             ;; Otherwise it will output &amp;quot;UNHANDLED-EVENT&amp;quot; messages.
             t)
WARNING: redefining POFTHEDAY::ON-MESSAGE in DEFUN
ON-MESSAGE
 &amp;lt;INFO&amp;gt; [22:55:06] poftheday (on-message) - &amp;lt;joanna&amp;gt; Hello everybody!
 &amp;lt;INFO&amp;gt; [22:55:17] poftheday (on-message) - &amp;lt;art&amp;gt; Hello, Joanna!
 &amp;lt;INFO&amp;gt; [22:55:27] poftheday (on-message) -
  &amp;lt;joanna&amp;gt; What is the best book on Common Lisp for newbee?
 &amp;lt;INFO&amp;gt; [22:55:56] poftheday (on-message) - &amp;lt;art&amp;gt; Try the Practical Common Lisp.
 &amp;lt;INFO&amp;gt; [22:56:04] poftheday (on-message) - &amp;lt;joanna&amp;gt; Thanks!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you want to make the bot which responds to the message, then use &lt;code&gt;cl-irc:privmsg&lt;/code&gt; like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; This will send a message to the channel:
POFTHEDAY&amp;gt; (cl-irc:privmsg *conn* &amp;quot;#lisp&amp;quot; &amp;quot;Hello! Bot is in the channel!&amp;quot;)
&amp;quot;PRIVMSG #lisp :Hello! Bot is in the channel!
&amp;quot;

;; and this will send a private message:
POFTHEDAY&amp;gt; (cl-irc:privmsg *conn* &amp;quot;joanna&amp;quot; &amp;quot;Hi Joanna!&amp;quot;)
&amp;quot;PRIVMSG joanna :Hi Joanna!
&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you will download the cl-irc&apos;s sources from &lt;a href=&quot;https://common-lisp.net/project/cl-irc/&quot;&gt;https://common-lisp.net/project/cl-irc/&lt;/a&gt; you&apos;ll find more sofisticated bot in the &lt;code&gt;example&lt;/code&gt; folder.&lt;/p&gt;
&lt;p&gt;One final note, to debug communication between lisp and IRC server set the &lt;code&gt;cl-irc::*debug-p*&lt;/code&gt; variable to true and it will log every message send or received by the bot.&lt;/p&gt;
</description>
            <pubDate>Thu, 16 Jul 2020 23:05:57 +0300</pubDate>
        </item>
        <item>
            <title>piping</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0131-piping.html</link>
            <description>&lt;p&gt;This library in some sense similar to the &lt;code&gt;cl-events&lt;/code&gt;, &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/07/0130-cl-events.html&quot;&gt;reviewed yesterday&lt;/a&gt;. It allows defining pipelines to process messages.&lt;/p&gt;
&lt;p&gt;Each message can be processed sequentially or in parallel. Each node would be an instance of the &lt;code&gt;segment&lt;/code&gt; class. There are two kinds of nodes - intermediate and final.&lt;/p&gt;
&lt;p&gt;Intermediate nodes can filter messages or route them into other pipelines.&lt;/p&gt;
&lt;p&gt;Final nodes are called &lt;code&gt;faucets&lt;/code&gt;. They process the message and stop processing.&lt;/p&gt;
&lt;p&gt;For example here is how we can build a log message processing using &lt;code&gt;piping&lt;/code&gt;. We want to print all &lt;code&gt;ERROR&lt;/code&gt; messages to &lt;code&gt;*error-output*&lt;/code&gt; and to write all messages to the log file.&lt;/p&gt;
&lt;p&gt;To create this pipeline, we need following &lt;code&gt;segments&lt;/code&gt;. Here is &quot;Pipeline&quot; is a chain of &lt;code&gt;segments&lt;/code&gt; to pass the message through:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;Pipeline:
  Print[&amp;quot;full.log&amp;quot;]
  Pipeline: Filter[if ERROR] -&amp;gt; Print[*error-output*]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here is how we can configure this pipeline in Lisp code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *pipe*
             (make-instance &amp;#039;piping:pipeline))

POFTHEDAY&amp;gt; (defparameter *log-printer*
             (piping:add-segment
               *pipe*
               (make-instance &amp;#039;piping:printer
                              :stream (open &amp;quot;full.log&amp;quot;
                                            :direction :output
                                            :if-exists :append
                                            :if-does-not-exist :create))))

;; This adds a sub-pipe where we&amp;#039;ll filter message
;; and print if it stats with &amp;quot;ERROR&amp;quot;:
POFTHEDAY&amp;gt; (piping:add-segment *pipe* :pipe)

POFTHEDAY&amp;gt; (piping:add-segment *pipe*
            (make-instance &amp;#039;piping:predicate-filter
                           :predicate (lambda (message)
                                        (str:starts-with-p &amp;quot;ERROR: &amp;quot; message)))
            &amp;#039;(1))

POFTHEDAY&amp;gt; (piping:add-segment *pipe*
            (make-instance &amp;#039;piping:printer
                           :stream *error-output*)
            &amp;#039;(1))

;; Now we&amp;#039;ll pass two messages through this pipeline:
POFTHEDAY&amp;gt; (piping:pass *pipe*
             &amp;quot;INFO: Hello world!&amp;quot;)

;; This one will be printed to *error-output*:
POFTHEDAY&amp;gt; (piping:pass *pipe*
             &amp;quot;ERROR: Something bad happened!&amp;quot;)

&amp;quot;ERROR: Something bad happened!&amp;quot; 

;; But in file both messages are present:
POFTHEDAY&amp;gt; (force-output (piping:print-stream *log-printer*))

POFTHEDAY&amp;gt; (princ (alexandria:read-file-into-string &amp;quot;full.log&amp;quot;))

&amp;quot;INFO: Hello world!&amp;quot; 
&amp;quot;ERROR: Something bad happened!&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Working on this example, I found two things:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;there is no component to fanout messages into the nested &lt;code&gt;segments&lt;/code&gt; or   sub pipes.&lt;/li&gt;&lt;li&gt;using indices to point to a place where a segment should be added is   very inconvenient.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/Shinmera&quot;&gt;@Shinmera&lt;/a&gt; uses &lt;code&gt;piping&lt;/code&gt; in his logging library &lt;a href=&quot;https://github.com/Shinmera/verbose&quot;&gt;verbose&lt;/a&gt;. I skimmed through its sources and didn&apos;t find if he has some solution of fanout absence problem.&lt;/p&gt;
&lt;p&gt;Definitely, this library can be made a more convenient if somebody is interested to use it for other purposes.&lt;/p&gt;
</description>
            <pubDate>Wed, 15 Jul 2020 23:26:21 +0300</pubDate>
        </item>
        <item>
            <title>cl-events</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0130-cl-events.html</link>
            <description>&lt;p&gt;This is the library by &lt;a href=&quot;https://twitter.com/dead_trickster&quot;&gt;@dead_trickster&lt;/a&gt;. It implements a pub-sub API and allows to:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;create an event object;&lt;/li&gt;&lt;li&gt;subscribe on it;&lt;/li&gt;&lt;li&gt;fire the event.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;CL-Events&lt;/code&gt; provides a way to add a hook point for your application.&lt;/p&gt;
&lt;p&gt;Here is the simplest example. Here we create a single-threaded event where all callbacks will be called sequentially:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *on-click*
             (make-instance &amp;#039;cl-events:event))

POFTHEDAY&amp;gt; (defun the-callback (message)
             ;; pretend, we need some time to process the callback
             (sleep 1)
             (format t &amp;quot;MSG [~A]: ~A~%&amp;quot;
                     (bt:current-thread)
                     message))

POFTHEDAY&amp;gt; (cl-events:event+ *on-click*
                             &amp;#039;the-callback)

POFTHEDAY&amp;gt; (cl-events:event! *on-click*
                             &amp;quot;Button clicked!&amp;quot;)
MSG [#&amp;lt;THREAD &amp;quot;sly-channel-1-mrepl-remote-1&amp;quot; RUNNING {1003955B33}&amp;gt;]: Button clicked!
NIL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;To make them execute in parallel, you only need to replace the type of the event object. Pay attention to the thread&apos;s name in the callback&apos;s output. They are different:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *on-click*
             (make-instance &amp;#039;cl-events:broadcast-event))

POFTHEDAY&amp;gt; (defun the-callback (handler-name message)
             ;; pretend, we need some time to process the callback
             (sleep 1)
             (format t &amp;quot;MSG [~A/~A]: ~A~%&amp;quot;
                     handler-name
                     (bt:current-thread)
                     message))

POFTHEDAY&amp;gt; (cl-events:event+ *on-click*
                             (alexandria:curry &amp;#039;the-callback
                                               &amp;quot;First handler&amp;quot;))

POFTHEDAY&amp;gt; (cl-events:event+ *on-click*
                             (alexandria:curry &amp;#039;the-callback
                                               &amp;quot;Second handler&amp;quot;))

POFTHEDAY&amp;gt; (cl-events:event! *on-click*
                             &amp;quot;Button clicked!&amp;quot;)
NIL
MSG [Second handler/#&amp;lt;THREAD &amp;quot;lparallel&amp;quot; RUNNING {1005A97983}&amp;gt;]: Button clicked!
MSG [First handler/#&amp;lt;THREAD &amp;quot;lparallel&amp;quot; RUNNING {1005A96F93}&amp;gt;]: Button clicked!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, in this case, &lt;code&gt;event!&lt;/code&gt; function returns before all handlers are called.&lt;/p&gt;
&lt;p&gt;In this case, parallel execution is implemented using &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0093-lparallel.html&quot;&gt;lparallel&apos;s thread pool&lt;/a&gt;. There are more executors available and you can implement your own.&lt;/p&gt;
</description>
            <pubDate>Tue, 14 Jul 2020 22:47:14 +0300</pubDate>
        </item>
        <item>
            <title>trivial-with-current-source-form</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0129-trivial-with-current-source-form.html</link>
            <description>&lt;p&gt;This library is a compatibility layer. It helps to provide hints to the Lisp compiler. Hints allow the compiler to show more precise error messages when error happens during the macro-expansion.&lt;/p&gt;
&lt;p&gt;Here is an example I&apos;ve stolen from the library&apos;s documentation. To show you how this works in dynamic, I&apos;ve recorded a GIF image.&lt;/p&gt;
&lt;p&gt;Pay attention, without the hint compiler highlights &quot;even-number-case&quot; top-level form:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0129/with-current-source-form.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;That is it. You just wrap some part of the macro-processing code with &lt;code&gt;with-current-source-form&lt;/code&gt; and say: &quot;Hey, compiler! Here is the s-expr I&apos;m currently processing. If some shit will happen, let the user know.&quot;&lt;/p&gt;
&lt;p&gt;As I said before, this library is a compatibility layer. Only SBCL and Clasp are supported for now. On other implementations, the macro will do nothing.&lt;/p&gt;
</description>
            <pubDate>Mon, 13 Jul 2020 22:17:20 +0300</pubDate>
        </item>
        <item>
            <title>trivial-benchmark</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0128-trivial-benchmark.html</link>
            <description>&lt;p&gt;Some time ago I&apos;ve reviewed the &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0100-the-cost-of-nothing.html&quot;&gt;the-cost-of-nothing&lt;/a&gt; library which allowed you to check the performance of the form execution. &lt;code&gt;Trivial-benchmark&lt;/code&gt; does a similar job but has a few pros and cons.&lt;/p&gt;
&lt;p&gt;The main con is that you have to give it a number of iterations manually, but the pro is that the library provides a way more statistics:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (trivial-benchmark:with-timing (1000000)
             (format nil &amp;quot;Symbol is: ~S&amp;quot; :foo))

-                SAMPLES  TOTAL      MINIMUM   MAXIMUM   MEDIAN    AVERAGE    DEVIATION  
REAL-TIME        1000000  3.78       0         0.169     0         0.000004   0.000207   
RUN-TIME         1000000  3.734      0         0.132     0         0.000004   0.000179   
USER-RUN-TIME    1000000  2.332375   0.000001  0.061505  0.000002  0.000002   0.00011    
SYSTEM-RUN-TIME  1000000  1.398129   0.000001  0.070875  0.000001  0.000001   0.000072   
PAGE-FAULTS      1000000  0          0         0         0         0          0.0        
GC-RUN-TIME      1000000  0.436      0         0.132     0         0.0        0.000168   
BYTES-CONSED     1000000  592388352  0         130976    0         592.38837  4354.098   
EVAL-CALLS       1000000  0          0         0         0         0          0.0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Another cool feature is the ability to define more custom metrics.&lt;/p&gt;
&lt;p&gt;Here is a practical example. We&apos;ll measure a number of SQL queries made during form execution:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; These are owr SQL driver simulation:
POFTHEDAY&amp;gt; (defparameter *num-queries* 0)

POFTHEDAY&amp;gt; (defun execute (query)
             &amp;quot;A fake SQL driver&amp;quot;
             (declare (ignorable query))
             (incf *num-queries*))

;; The application code:
POFTHEDAY&amp;gt; (defun the-view ()
             (execute &amp;quot;SELECT some FROM data&amp;quot;)
             (loop repeat 5
                   do (execute &amp;quot;SELECT some FROM other_data&amp;quot;)))

;; Metric definition is very simple. You just provide a code
;; which returns an absolute value:
POFTHEDAY&amp;gt; (trivial-benchmark:define-delta-metric sql-queries
             *num-queries*)

;; Pay attention to the last line of the report:
POFTHEDAY&amp;gt; (trivial-benchmark:with-timing (100)
             (the-view))
-                SAMPLES  TOTAL     MINIMUM   MAXIMUM   MEDIAN    AVERAGE   DEVIATION  
REAL-TIME        100      0         0         0         0         0         0.0        
RUN-TIME         100      0         0         0         0         0         0.0        
USER-RUN-TIME    100      0.000308  0.000001  0.00012   0.000002  0.000003  0.000012   
SYSTEM-RUN-TIME  100      0.000117  0.000001  0.000002  0.000001  0.000001  0.0        
PAGE-FAULTS      100      0         0         0         0         0         0.0        
GC-RUN-TIME      100      0         0         0         0         0         0.0        
BYTES-CONSED     100      98240     0         65536     0         982.4     7258.1045  
EVAL-CALLS       100      0         0         0         0         0         0.0        
SQL-QUERIES      100      600       6         6         6         6         0.0&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;The &lt;code&gt;trivial-benchmark&lt;/code&gt; is not as accurate as &lt;code&gt;the-cost-of-nothing&lt;/code&gt; because it does not count the overhead, but overhead can be significant because &lt;code&gt;trivial-benchmark&lt;/code&gt; uses generic functions.&lt;/p&gt;
&lt;p&gt;Also when sampling, the &lt;code&gt;trivial-benchmark&lt;/code&gt; executes the form only once. That is why the measurements for a very fast code will be even more inaccurate.&lt;/p&gt;
&lt;p&gt;Another interesting feature is the ability to define benchmark suites to measure performance regression of some parts of your code. I won&apos;t show you an example of such a suite. Just go and read nice documentation, written by @Shinmera:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Shinmera/trivial-benchmark#benchmark-suites&quot;&gt;https://github.com/Shinmera/trivial-benchmark#benchmark-suites&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Sun, 12 Jul 2020 23:11:25 +0300</pubDate>
        </item>
        <item>
            <title>chameleon</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0127-chameleon.html</link>
            <description>&lt;p&gt;Chameleon is a configuration management library. It allows us to define a bunch of options and their values for different profiles. After that, you can switch between profiles.&lt;/p&gt;
&lt;p&gt;It works like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (chameleon:defconfig
             (port 8000 &amp;quot;Port to listen on&amp;quot;)
             (log-level :info &amp;quot;The log level for log4cl&amp;quot;))

POFTHEDAY&amp;gt; (chameleon:defprofile :dev)

POFTHEDAY&amp;gt; (chameleon:defprofile :production
             (port 80)
             (log-level :warn))

POFTHEDAY&amp;gt; (setf (active-profile) :production)
:PRODUCTION
POFTHEDAY&amp;gt; (port)
80

POFTHEDAY&amp;gt; (log-level)
:WARN

POFTHEDAY&amp;gt; (active-profile)
:PRODUCTION

;; Now switching to development mode:
POFTHEDAY&amp;gt; (setf (active-profile) :dev)
:DEV

POFTHEDAY&amp;gt; (port)
8000

POFTHEDAY&amp;gt; (log-level)
:INFO&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;I&apos;ve investigated the &lt;code&gt;chameleon&apos;s&lt;/code&gt; code and think it can be made better and simpler using &lt;code&gt;CLOS&lt;/code&gt; instances for profiles instead of hash maps.&lt;/p&gt;
&lt;p&gt;If you know other Lisp systems for configuration management, please, let me know.&lt;/p&gt;
</description>
            <pubDate>Sat, 11 Jul 2020 21:23:05 +0300</pubDate>
        </item>
        <item>
            <title>with-output-to-stream</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0126-with-output-to-stream.html</link>
            <description>&lt;p&gt;This is a &quot;trivial&quot; library by &lt;a href=&quot;https://twitter.com/HexstreamSoft&quot;&gt;@HexstreamSoft&lt;/a&gt;. It simplifies the writing of the functions which would like to accept a stream argument as &lt;code&gt;format&lt;/code&gt; function does.&lt;/p&gt;
&lt;p&gt;CL&apos;s &lt;code&gt;format&lt;/code&gt; function accepts as the first parameter a &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;t&lt;/code&gt; or a stream object. In first case it returns a string and in second - outputs to &lt;code&gt;*standard-output*&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When you are writing a custom function with similar semantics, you have to handle all these cases by hand. Here is where &lt;code&gt;with-output-to-stream&lt;/code&gt; helps you:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun log-info (obj &amp;amp;key (stream t))
             (with-output-to-stream:with-output-to-stream (s stream)
               (write-string &amp;quot;INFO &amp;quot; s)
               (write obj :stream s)
               (terpri s)))

;; Here is we return result as a string:
POFTHEDAY&amp;gt; (log-info 100500 :stream nil)
&amp;quot;INFO 100500
&amp;quot;

;; This will output to *standard-output*:
POFTHEDAY&amp;gt; (log-info 100500 :stream t)
INFO 100500
NIL

;; But you can pass any stream as the argument:
POFTHEDAY&amp;gt; (log-info 100500 :stream *error-output*)
INFO 100500
NIL

POFTHEDAY&amp;gt; (with-output-to-string (s)
             (log-info 100500 :stream s)
             (log-info 42 :stream s))
&amp;quot;INFO 100500
INFO 42
&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it for today.&lt;/p&gt;
</description>
            <pubDate>Fri, 10 Jul 2020 20:41:09 +0300</pubDate>
        </item>
        <item>
            <title>lisp-critic</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0125-lisp-critic.html</link>
            <description>&lt;p&gt;A few weeks ago, &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0097-sblint.html&quot;&gt;I&apos;ve reviewed&lt;/a&gt; the &lt;code&gt;sblint&lt;/code&gt; - a tool to check code quality in terms of warnings from the SBCL compiler. &lt;code&gt;Lisp-critic&lt;/code&gt; is another kind of beast. It checks the code quality in terms of common patterns and idioms.&lt;/p&gt;
&lt;p&gt;For example, it outputs warning when there is only one subform inside the &lt;code&gt;progn&lt;/code&gt; or if you are setting global variables in the function definition:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (lisp-critic:critique
            (progn
              (format t &amp;quot;Hello World!&amp;quot;)))
----------------------------------
Why do you think you need a PROGN?
----------------------------------

POFTHEDAY&amp;gt; (lisp-critic:critique
            (defun start-server ()
              (setf *server*
                    (listen-on :port 8080))
              (values)))
----------------------------------------------------
GLOBALS!! Don&amp;#039;t use global variables, i.e., *SERVER*
----------------------------------------------------&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Lisp-critic&lt;/code&gt; operates on patterns. There are &lt;a href=&quot;https://github.com/g000001/lisp-critic/blob/master/lisp-rules.lisp&quot;&gt;109 built-in patterns&lt;/a&gt; and you can define more:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (length (lisp-critic:get-pattern-names))
109

POFTHEDAY&amp;gt; (rutils:take 10
             (lisp-critic:get-pattern-names))
(LISP-CRITIC::?-FOR-PREDICATE
 LISP-CRITIC::ADD-ZERO
 LISP-CRITIC::APPEND-LIST-LIST
 LISP-CRITIC::APPEND-LIST-LOOP
 LISP-CRITIC::APPEND-LIST-RECURSION
 LISP-CRITIC::APPEND-LIST2-LIST
 LISP-CRITIC::APPLY-FOR-FUNCALL
 LISP-CRITIC::CAR-CDR
 LISP-CRITIC::CONCATENATE-LIST
 LISP-CRITIC::COND-&amp;gt;OR)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Also, you can use &lt;code&gt;lisp-critic:critique-file&lt;/code&gt; to analyze all top-level forms in a file.&lt;/p&gt;
&lt;p&gt;It would be nice to:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;add a command-line tool (like sblint) to check all files in the   project;&lt;/li&gt;&lt;li&gt;to add the ability to ignore some checks for some forms. Probably &lt;code&gt;declaim&lt;/code&gt;   could be used for this purpose?&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Probably adding an integration with SLIME or SLY would also be a good idea.&lt;/p&gt;
&lt;p&gt;This way you&apos;ll be able to hit some shortcuts to receive recommendations from Lisp Critic, or it could happen when you are evaluating a top-level form.&lt;/p&gt;
</description>
            <pubDate>Thu, 09 Jul 2020 23:29:31 +0300</pubDate>
        </item>
        <item>
            <title>cl-spark</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0124-cl-spark.html</link>
            <description>&lt;p&gt;This small utility has nothing common with &lt;a href=&quot;https://spark.apache.org/&quot;&gt;Apache Spark&lt;/a&gt; and big data processing. However, it relates to data plotting.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Cl-spark&lt;/code&gt; allows you to visualize data in the console like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(1 0 1 0))
&amp;quot;&amp;#x2588;&amp;#x2581;&amp;#x2588;&amp;#x2581;&amp;quot;

POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(1 1 2 3 5 8))
&amp;quot;&amp;#x2581;&amp;#x2581;&amp;#x2582;&amp;#x2583;&amp;#x2585;&amp;#x2588;&amp;quot;


POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(0 30 55 80 33 150))
&amp;quot;&amp;#x2581;&amp;#x2582;&amp;#x2583;&amp;#x2584;&amp;#x2582;&amp;#x2588;&amp;quot;

POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(0 30 55 80 33 150)
                           :min -100)
&amp;quot;&amp;#x2583;&amp;#x2584;&amp;#x2585;&amp;#x2586;&amp;#x2584;&amp;#x2588;&amp;quot;
POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(0 30 55 80 33 150)
                           :max 50)
&amp;quot;&amp;#x2581;&amp;#x2585;&amp;#x2588;&amp;#x2588;&amp;#x2585;&amp;#x2588;&amp;quot;
POFTHEDAY&amp;gt; (cl-spark:spark &amp;#039;(0 30 55 80 33 150)
                           :min 30
                           :max 80)
&amp;quot;&amp;#x2581;&amp;#x2581;&amp;#x2584;&amp;#x2588;&amp;#x2581;&amp;#x2588;&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Or like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (cl-spark:spark
            &amp;#039;(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14)
            :key (lambda (x)
                   (sin (* x pi 1/4))))
&amp;quot;&amp;#x2584;&amp;#x2586;&amp;#x2588;&amp;#x2586;&amp;#x2584;&amp;#x2582;&amp;#x2581;&amp;#x2582;&amp;#x2584;&amp;#x2586;&amp;#x2588;&amp;#x2586;&amp;#x2584;&amp;#x2582;&amp;#x2581;&amp;quot;


POFTHEDAY&amp;gt; (cl-spark:vspark
            &amp;#039;(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14)
            :key (lambda (x)
                   (sin (* x pi 1/4)))
            :size 20)
&amp;quot;
-1.0     0.0     1.0
&amp;#x2EB;--------+---------&amp;#x2E7;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2589;
&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2589;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2589;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x2588;&amp;#x258F;
&amp;#x2588;&amp;#x2588;&amp;#x2589;
&amp;#x258F;
&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;It&apos;s repository has a lot more examples. Check it out:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tkych/cl-spark&quot;&gt;https://github.com/tkych/cl-spark&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Wed, 08 Jul 2020 20:57:12 +0300</pubDate>
        </item>
        <item>
            <title>cl-coveralls</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0123-cl-coveralls.html</link>
            <description>&lt;p&gt;I hope, you are writing unit tests for your program. And if you do, then it is really helpful to know which code is covered by tests and which does not.&lt;/p&gt;
&lt;p&gt;Did you know that some CL implementation has tools for measuring code coverage?&lt;/p&gt;
&lt;p&gt;For example, SBCL has a package &lt;a href=&quot;http://www.sbcl.org/manual/#sb_002dcover&quot;&gt;sb-cover&lt;/a&gt;. To create a coverage report you need to turn instrumentation on, recompile the program, run tests and generate the report.&lt;/p&gt;
&lt;p&gt;This is the code from SBCL&apos;s manual:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(declaim (optimize sb-cover:store-coverage-data))

;;; Load some code, ensuring that it&amp;#039;s recompiled
;;; with correct optimization policy.
(asdf:oos &amp;#039;asdf:load-op :cl-ppcre-test :force t)

;;; Run the test suite.
(cl-ppcre-test:test)

;;; Produce a coverage report
(sb-cover:report &amp;quot;/tmp/report/&amp;quot;)

;;; Turn off instrumentation
(declaim (optimize (sb-cover:store-coverage-data 0)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Here are few screenshots of HTML pages I&apos;ve got running &lt;code&gt;sb-cover&lt;/code&gt; against Ultralisp&apos;s code:&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0123/file-list.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img style=&quot;max-width: 100%&quot; src=&quot;../../media/0123/covered-code.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;But today we are talking about cl-coveralls. It helps to build coverage measuring into your CI pipeline. I decided that it is a great moment to add make it check Ultralisp&apos;s code.&lt;/p&gt;
&lt;p&gt;What do you need to collect coverage data of Common Lisp project? Well, you need:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;to set up a CI pipeline on Travis or CircleCI.&lt;/li&gt;&lt;li&gt;register at &lt;a href=&quot;https://coveralls.io/&quot;&gt;https://coveralls.io/&lt;/a&gt; and enable it for your GitHub   repository.&lt;/li&gt;&lt;li&gt;set two environment variables in the CI&apos;s config.&lt;/li&gt;&lt;li&gt;wrap code with a call to coveralls:with-coveralls &lt;a href=&quot;https://github.com/ultralisp/ultralisp/commit/1162659cceb038d3285679c07c5c1440e58e779f#diff-1d37e48f9ceff6d8030570cd36286a61R42&quot;&gt;like that&lt;/a&gt;.&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Here is &lt;a href=&quot;https://github.com/ultralisp/ultralisp/commit/1162659cceb038d3285679c07c5c1440e58e779f&quot;&gt;the diff, required to enable code coverage&lt;/a&gt; measurement for Ultralisp&apos;s tests. And now Coveralls will track if code coverage was improved with each pull-request.&lt;/p&gt;
</description>
            <pubDate>Tue, 07 Jul 2020 22:29:09 +0300</pubDate>
        </item>
        <item>
            <title>path-parse</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0122-path-parse.html</link>
            <description>&lt;p&gt;This is a small utility library by Fernando Borretti. The only function it has is &lt;code&gt;PATH&lt;/code&gt; variable parsing. But it does it really well.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Path-parse&lt;/code&gt; works on Windows and Unix (OSX):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (path-parse:path)

(#P&amp;quot;/Users/art/.roswell/bin/&amp;quot;
 #P&amp;quot;/Users/art/.bin/&amp;quot;
 #P&amp;quot;/Users/art/.dotfiles/bin/&amp;quot;
 #P&amp;quot;/usr/local/bin/&amp;quot;
 #P&amp;quot;/usr/bin/&amp;quot;
 #P&amp;quot;/bin/&amp;quot;
 #P&amp;quot;/usr/sbin/&amp;quot;
 #P&amp;quot;/sbin/&amp;quot;)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is it for today. Tomorrow I&apos;ll try to find something more interesting!&lt;/p&gt;
</description>
            <pubDate>Mon, 06 Jul 2020 21:06:02 +0300</pubDate>
        </item>
        <item>
            <title>cl-skip-list</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0121-cl-skip-list.html</link>
            <description>&lt;p&gt;I found this library a few weeks ago. It implements a &lt;a href=&quot;https://en.wikipedia.org/wiki/Skip_list&quot;&gt;Skip List&lt;/a&gt; data structure. Which is a lock-free and has &lt;code&gt;O(log n)&lt;/code&gt; for lookup, insert and delete operations.&lt;/p&gt;
&lt;p&gt;I wondered if this library will have a better performance in situation when you have to access a dictionary from multiple threads?&lt;/p&gt;
&lt;p&gt;Here is a simple benchmark. We ll create 10 threads and do 10 millions lookup of a value in the dictionary filled by 6600 symbols from the keywords package.&lt;/p&gt;
&lt;p&gt;I&apos;m testing on SBCL 2.0.2 with &lt;code&gt;(declaim (optimize (debug 1) (speed 3)))&lt;/code&gt; options running on the Macbook with 12 cores.&lt;/p&gt;
&lt;p&gt;Let&apos;s run this benchmark using a standard Common Lisp hash table and a lock:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((hash (make-hash-table))
                 (lock (bt:make-lock))
                 (num-operations 10000000)
                 (num-threads 10))
             (do-external-symbols (s :keyword)
               (setf (gethash s hash)
                     (symbol-name s)))
             (setf (gethash :foo hash)
                   &amp;quot;FOO&amp;quot;)
             ;; Now it is time to define a worker function
             (flet ((worker ()
                      (loop with result = nil
                            repeat num-operations
                            do (bt:with-lock-held (lock)
                                 (setf result
                                       (gethash :foo hash)))
                            finally (return result))))
               ;; We&amp;#039;ll create N workers and measure a total time required to finish them all
               (let* ((started-at (get-internal-real-time))
                      (workers (loop repeat num-threads
                                     collect (bt:make-thread #&amp;#039;worker))))
                 (loop for worker in workers
                       do (bt:join-thread worker))
                 ;; Calculate the total time
                 (/ (- (get-internal-real-time) started-at)
                    internal-time-units-per-second))))
2399/100 (23.99)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And now a lock free version using cl-skip-list:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((hash (cl-skip-list:make-skip-list :key-equal #&amp;#039;eql))
                 (num-operations 10000000)
                 (num-threads 10))
             (do-external-symbols (s :keyword)
               (cl-skip-list:skip-list-add hash
                                           s
                                           (symbol-name s)))
             (unless (cl-skip-list:skip-list-lookup hash :foo)
               (cl-skip-list:skip-list-add hash
                                           :foo
                                           &amp;quot;FOO&amp;quot;))
             ;; Now it is time to define a worker function
             (flet ((worker ()
                      (loop with result = nil
                            repeat num-operations
                            do (setf result
                                     (cl-skip-list:skip-list-lookup hash :foo))
                            finally (return result))))
               ;; We&amp;#039;ll create N workers and measure a total time required to finish them all
               (let* ((started-at (get-internal-real-time))
                      (workers (loop repeat num-threads
                                     collect (bt:make-thread #&amp;#039;worker))))
                 (loop for worker in workers
                       do (bt:join-thread worker))
                 ;; Calculate the total time
                 (/ (- (get-internal-real-time) started-at)
                    internal-time-units-per-second))))
45799/1000 (45.799)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;As you see, the version with a lock is twice faster: 46 seconds against 24.&lt;/p&gt;
&lt;p&gt;Are there any reasons to use a lock-free data structure if it does not get you any speed gains?&lt;/p&gt;
</description>
            <pubDate>Sun, 05 Jul 2020 12:39:11 +0300</pubDate>
        </item>
        <item>
            <title>make-hash</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0120-make-hash.html</link>
            <description>&lt;p&gt;This is the most comprehensive library for making hash tables I&apos;ve already seen! And it has wonderful documentation with lots of examples!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make-hash&lt;/code&gt; allows to create hash tables in multiple ways, from different kinds of data structures and even using functions for data transformation. For example, you can create a hash by reading rows from the database.&lt;/p&gt;
&lt;p&gt;I&apos;ll show you only a few examples I especially liked.&lt;/p&gt;
&lt;p&gt;First one is creation hash from a sequence while counting each item. Using this, we can easily count how many times each character is used in a text:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (make-hash:make-hash
            :init-format :keybag
            :initial-contents &amp;quot;Alice loves Bob&amp;quot;)
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 11 {1008943083}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-hash-table *)
#{
  #\A 1
  #\l 2
  #\i 1
  #\c 1
  #\e 2
  #\  2
  #\o 2
  #\v 1
  #\s 1
  #\B 1
  #\b 1
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the next example, we&apos;ll make a smaller hash table from another one while selecting data by keys:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (let ((full-data
                   (make-hash:make-hash
                    :initial-contents
                    &amp;#039;(:foo 1
                      :bar 2
                      :bazz 3
                      :blah 4
                      :minor 5))))
             (make-hash:make-hash
              :init-format :keys
              :init-data full-data
              :initial-contents &amp;#039;(:bar :minor)))
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 2 {10060F6123}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-hash-table *)
#{
   :BAR 2
   :MINOR 5
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And here is how we can build a hash from a data returned by a function. We only need a closure which will return rows of data as values and will return nil at the end.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defun make-rows-iterator ()
             ;; This list will allow us to simulate
             ;; the data storage:
             (let ((rows &amp;#039;((bob 42)
                           (alice 25)
                           (mike 30)
                           (julia 27))))
               (lambda ()
                 (let ((row (car rows)))
                   (setf rows
                         (cdr rows))
                   (values (first row) ;; This is a key
                           (second row))))))

POFTHEDAY&amp;gt; (make-hash:make-hash
            :init-format :function
            :initial-contents (make-rows-iterator))
#&amp;lt;HASH-TABLE :TEST EQL :COUNT 4 {10086FF8E3}&amp;gt;

POFTHEDAY&amp;gt; (rutils:print-hash-table *)
#{
  BOB 42
  ALICE 25
  MIKE 30
  JULIA 27
 }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;make-hash&lt;/code&gt; also provides a configurable reader macro:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(install-hash-reader ())  ; default settings and options
#{:a 1 :b 2 :c 3 :d 4}   
       

(install-hash-reader &amp;#039;(:init-format :pairs)
  :use-dispatch t
  :open-char #\[ :close-char #\])
#[&amp;#039;(:a . 1) &amp;#039;(:b . 2) &amp;#039;(:c . 3) &amp;#039;(:d . 4)] 
       

(install-hash-reader &amp;#039;(:init-format :lists)
  :use-dispatch nil
  :open-char #\{ :close-char #\})
{&amp;#039;(:a 1) &amp;#039;(:b 2) &amp;#039;(:c 3) &amp;#039;(:d 4)}&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;You will find more examples and instructions on how to define your own initialization formats in the library&apos;s documentation:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/genovese/make-hash&quot;&gt;https://github.com/genovese/make-hash&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Let&apos;s thank the #poftheday challenge for the chance to discover such cool Common Lisp library!&lt;/p&gt;
</description>
            <pubDate>Sat, 04 Jul 2020 23:15:08 +0300</pubDate>
        </item>
        <item>
            <title>bourbaki</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0119-bourbaki.html</link>
            <description>&lt;p&gt;This is the system for verifying formal mathematical proofs. As I didn&apos;t use math since the high school and lack time to dive into the lengthy documentation :(&lt;/p&gt;
&lt;p&gt;Here is the code snippet from the example:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;;; Declare the wff type
(symkind &amp;quot;WFF&amp;quot;)

;; The implication symbol
(prim wff &amp;quot;-&amp;gt;&amp;quot; (wff ![x y]))

;; the axioms
(ax &amp;quot;ax1&amp;quot; (wff ![A B])
  (ass [-&amp;gt; A -&amp;gt; B A]))
(ax &amp;quot;ax2&amp;quot; (wff ![A B C])
  (ass [-&amp;gt; -&amp;gt; A -&amp;gt; B C -&amp;gt; -&amp;gt; A B -&amp;gt; A C]))

;; the rule of inference (modus ponens)
(ax &amp;quot;ax-mp&amp;quot; (wff ![A B])
  (hypo [A] [-&amp;gt; A B])
  (ass [B]))

;; theorem: identity law for &amp;#039;-&amp;gt;&amp;#039;
;; compare with id1 in set.mm
(th &amp;quot;id&amp;quot; (wff &amp;quot;A&amp;quot;)
  (ass [-&amp;gt; A A])
  (proof
    [ax1 A [-&amp;gt; A A]]
    [ax2 A [-&amp;gt; A A] A]
    [ax-mp [-&amp;gt; A -&amp;gt; -&amp;gt; A A A]
           [-&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]]
    [ax1 A A]
    [ax-mp [-&amp;gt; A -&amp;gt; A A] [-&amp;gt; A A]]))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If you eval it in the &lt;code&gt;REPL&lt;/code&gt;, then you can verify it and output some information:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;BOURBAKI-USER&amp;gt; (print-theorem !id)
Theorem id:
Variables: A
Distinct variable conditions: 
Hypotheses: 
Assertion: [-&amp;gt; A A]
Proof:
ax1 [A][-&amp;gt; A A]
ax2 [A][-&amp;gt; A A][A]
ax-mp [-&amp;gt; A -&amp;gt; -&amp;gt; A A A][-&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]
ax1 [A][A]
ax-mp [-&amp;gt; A -&amp;gt; A A][-&amp;gt; A A]

BOURBAKI-USER&amp;gt; (show-proof !id)
Proof for id:
ax1 =&amp;gt; [-&amp;gt; A -&amp;gt; -&amp;gt; A A A]
ax2 =&amp;gt; [-&amp;gt; -&amp;gt; A -&amp;gt; -&amp;gt; A A A -&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]
ax-mp =&amp;gt; [-&amp;gt; -&amp;gt; A -&amp;gt; A A -&amp;gt; A A]
ax1 =&amp;gt; [-&amp;gt; A -&amp;gt; A A]
ax-mp =&amp;gt; [-&amp;gt; A A]

BOURBAKI-USER&amp;gt; (verify !id)
Theorem: &amp;quot;ax1&amp;quot;
Theorem: &amp;quot;ax2&amp;quot;
Theorem: &amp;quot;ax-mp&amp;quot;
Theorem: &amp;quot;id&amp;quot;
T&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Bourbaki has a very good documentation. If you are interested in math libraries and don&apos;t know how to spend this weekend - enjoy it:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.quicklisp.org/beta/UNOFFICIAL/docs/bourbaki/doc/bourbaki-3.7.pdf&quot;&gt;https://www.quicklisp.org/beta/UNOFFICIAL/docs/bourbaki/doc/bourbaki-3.7.pdf&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Fri, 03 Jul 2020 21:52:13 +0300</pubDate>
        </item>
        <item>
            <title>cl-tui</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0118-cl-tui.html</link>
            <description>&lt;p&gt;This system is an experimental user interface library for the console. It uses &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0061-cl-charms.html&quot;&gt;cl-charms&lt;/a&gt; under the hood, to call &lt;code&gt;ncurses&lt;/code&gt;. The library is not in Quicklisp yet but is installable from &lt;a href=&quot;https://ultralisp.org&quot;&gt;https://ultralisp.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;It contains a few examples. I&apos;ve modified one to implement a simple chat-like interface:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;text&apos;&gt;&amp;#x250C;&amp;#x2500;&amp;#x2500;Online&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2510;
&amp;#x2502;Bob               &amp;#x2502;
&amp;#x2502;Alice             &amp;#x2502;
&amp;#x2502;Peter             &amp;#x2502;
&amp;#x2502;Lisper 313373     &amp;#x2502;23:08:46 Enter some text.
&amp;#x2502;                  &amp;#x2502;23:08:46 Esc to quit
&amp;#x2502;                  &amp;#x2502;23:08:52 Hello Lisp World!
&amp;#x2502;                  &amp;#x2502;23:09:05 This is a simple chat using
&amp;#x2502;                  &amp;#x2502;23:09:16 cl-tui and charms.
&amp;#x2514;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2500;&amp;#x2518;&amp;gt; Input box&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;cl-tui&lt;/code&gt; allows defining frames which can be stacked together. And you can write text inside the frame. Hope, there will be more primitives for other GUI elements like buttons text inputs, forms etc.&lt;/p&gt;
&lt;p&gt;Here are pieces of the example. First, I defined a &quot;roster&quot; and a function to render it inside a frame. This function also draws a border around:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defvar *roster* &amp;#039;(&amp;quot;Bob&amp;quot;
                   &amp;quot;Alice&amp;quot;
                   &amp;quot;Peter&amp;quot;
                   &amp;quot;Lisper 313373&amp;quot;))

(defun draw-roster (&amp;amp;key frame)
  (draw-box frame)
  (put-text frame 0 3 &amp;quot;Online&amp;quot;)
  
  (loop for name in *roster*
        for row upfrom 1
        do (put-text frame row 1 name)))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Next part is the code defining the application&apos;s layout. It is constructed from nested frames of different types. There is a frame for our roster, a frame to display chat log and to get user&apos;s input:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(define-frame main (container-frame :split-type :horizontal) :on :root)

(define-frame roster (simple-frame :render #&amp;#039;draw-roster) :on main :w 20)

(define-frame chat (container-frame :split-type :vertical) :on main)

(define-frame log (log-frame) :on chat)

;; Edit-frame implements a single-line text editor.
;; It will misbehave if its height is not 1.
(define-frame input (edit-frame :prompt &amp;quot;&amp;gt; &amp;quot;) :on chat :h 1)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We also need two functions to add users input into the chat window and to process keystrokes:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;(defun finish-input ()
  ;; Get text from edit-frame
  (let ((text (get-text &amp;#039;input)))
    ;; Append it to the log-frame
    (append-line &amp;#039;log text)
    ;; And clear the text in edit-frame
    (clear-text &amp;#039;input)))


(defun start ()
  (with-screen ()
    (append-line &amp;#039;log &amp;quot;Enter some text.&amp;quot;)
    (append-line &amp;#039;log &amp;quot;Esc to quit&amp;quot;)
    (loop
      (refresh)
      (let ((key (read-key)))
        (case key
          ;; Esc and Newline are handled here
          (#\Esc (return))
          (#\Newline (finish-input))
          (:key-up (cl-tui:scroll-log &amp;#039;log 1))
          (:key-down (cl-tui:scroll-log &amp;#039;log -1))
          ;; Everything else is sent to the edit-frame.
          (t (handle-key &amp;#039;input key)))))))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;That is all the app.&lt;/p&gt;
&lt;p&gt;Checkout &lt;a href=&quot;https://github.com/naryl/cl-tui&quot;&gt;the repository&lt;/a&gt;. There you&apos;ll find more examples!&lt;/p&gt;
&lt;p&gt;For those, who are interested in using &lt;code&gt;ncurses&lt;/code&gt;, here are reviews of the two lower-level libraries:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0059-cl-ncurses.html&quot;&gt;cl-ncurses&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/05/0061-cl-charms.html&quot;&gt;cl-charms&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
            <pubDate>Thu, 02 Jul 2020 23:21:18 +0300</pubDate>
        </item>
        <item>
            <title>clack-pretend</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/07/0117-clack-pretend.html</link>
            <description>&lt;p&gt;This is the last middleware in our Clack/Lack series. What does it do? It helps during website development remembering last requests you did from the browser and allowing to replay them from the REPL.&lt;/p&gt;
&lt;p&gt;Clack-pretend interposes itself into a Lack middlewares chain. To define the app you need to use a special builder macro and to specify at which point requests and responses should be captured:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (defparameter *app*
             (clack-pretend:pretend-builder (:insert 2)
               :accesslog
               :session
               (lambda (env)
                 (let* ((path (getf env :path-info))
                        (query (getf env :query-string))
                        (message (format nil &amp;quot;Path: ~A, query: ~A&amp;quot;
                                         path query)))
                   (format t &amp;quot;Processing request:~%  ~A~%&amp;quot;
                           message)
                   &amp;#039;(200 (:content-type &amp;quot;text/plain&amp;quot;)
                     (&amp;quot;Hello world!&amp;quot;))))))
*APP*
POFTHEDAY&amp;gt; (defparameter *server*
             (clack:clackup *app*
                            :port 8000))
Hunchentoot server is started.
Listening on 127.0.0.1:8000.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now I&apos;ll make a request using &lt;code&gt;curl&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;bash&apos;&gt;[poftheday] curl -v &amp;#039;http://localhost:8000/some/route?foo=Bar&amp;#039;
&amp;gt; GET /some/route?foo=Bar HTTP/1.1
&amp;gt; Host: localhost:8000
&amp;gt; User-Agent: curl/7.54.0
&amp;gt; Accept: */*
&amp;gt; 
&amp;lt; HTTP/1.1 200 OK
&amp;lt; Date: Wed, 01 Jul 2020 19:23:12 GMT
&amp;lt; Server: Hunchentoot 1.2.38
&amp;lt; Transfer-Encoding: chunked
&amp;lt; Content-Type: text/plain
&amp;lt; Set-Cookie: lack.session=0d629e3a1d2681d99c40f7b2086ec97d53e2b884; path=/; expires=Sat, 31 Dec 2140 14:45:27 GMT&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;And we can look up what was the last request:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack-pretend:last-input)
(:LACK.SESSION.OPTIONS
 (:ID &amp;quot;0d629e3a1d2681d99c40f7b2086ec97d53e2b884&amp;quot;
  :NEW-SESSION T :CHANGE-ID NIL :EXPIRE NIL)
 :LACK.SESSION #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 0 {1005EB8A03}&amp;gt;
 :REQUEST-METHOD :GET
 :SCRIPT-NAME &amp;quot;&amp;quot;
 :PATH-INFO &amp;quot;/some/route&amp;quot;
 :SERVER-NAME &amp;quot;localhost&amp;quot;
 :SERVER-PORT 8000
 :SERVER-PROTOCOL :HTTP/1.1
 :REQUEST-URI &amp;quot;/some/route?foo=Bar&amp;quot;
 :URL-SCHEME &amp;quot;http&amp;quot;
 :REMOTE-ADDR &amp;quot;127.0.0.1&amp;quot;
 :REMOTE-PORT 53671
 :QUERY-STRING &amp;quot;foo=Bar&amp;quot;
 :RAW-BODY #&amp;lt;FLEXI-STREAMS:FLEXI-IO-STREAM {1005EB6FD3}&amp;gt;
 :CONTENT-LENGTH NIL
 :CONTENT-TYPE NIL
 :CLACK.STREAMING T
 :CLACK.IO #&amp;lt;CLACK.HANDLER.HUNCHENTOOT::CLIENT {1005EB7043}&amp;gt;
 :HEADERS #&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 3 {1005EB72C3}&amp;gt;
 :QUERY-PARAMETERS ((&amp;quot;foo&amp;quot; . &amp;quot;Bar&amp;quot;)))

POFTHEDAY&amp;gt; (rutils:hash-table-to-alist
            (getf * :headers))
((&amp;quot;host&amp;quot; . &amp;quot;localhost:8000&amp;quot;)
 (&amp;quot;user-agent&amp;quot; . &amp;quot;curl/7.54.0&amp;quot;)
 (&amp;quot;accept&amp;quot; . &amp;quot;*/*&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now it is time to replay the request from the REPL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack-pretend:run-pretend)
Processing request:
  Path: /some/route, query: foo=Bar
(200 (:CONTENT-TYPE &amp;quot;text/plain&amp;quot;) (&amp;quot;Hello world!&amp;quot;))

;; You can override path to check, it with the same
;; headers and session:
POFTHEDAY&amp;gt; (clack-pretend:run-pretend
            :path-info &amp;quot;/other/path&amp;quot;)
Processing request:
  Path: /other/path, query: foo=Bar
(200 (:CONTENT-TYPE &amp;quot;text/plain&amp;quot;) (&amp;quot;Hello world!&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Seems, &lt;code&gt;clack-pretend&lt;/code&gt; is a great addition for web development with Clack.&lt;/p&gt;
&lt;p&gt;It will be interesting to improve it to store not only the last N successful requests but also to store requests resulting unhandled error. This way you&apos;ll be able to replay errors your users experience in production!&lt;/p&gt;
</description>
            <pubDate>Wed, 01 Jul 2020 22:32:39 +0300</pubDate>
        </item>
        <item>
            <title>clack-static-asset-middleware</title>
            <link>http://40ants.com/lisp-project-of-the-day/2020/06/0115-clack-static-asset-middleware.html</link>
            <description>&lt;p&gt;This middleware in some sense like a builtin &lt;a href=&quot;https://40ants.com/lisp-project-of-the-day/2020/06/0110-lack-middleware-static.html&quot;&gt;lack-middleware-static&lt;/a&gt;, reviewed last week.&lt;/p&gt;
&lt;p&gt;The difference is that this middleware is more suitable for production because implements an infinite cache TTL for static assets.&lt;/p&gt;
&lt;p&gt;An infinite cache TTL trick is useful when you want to speed up your website loading. Here is how it works.&lt;/p&gt;
&lt;p&gt;Your server returns &lt;code&gt;Cache-Control&lt;/code&gt; HTTP header and set static files TTL to some large value like a year to make it cached for a long long period of time.&lt;/p&gt;
&lt;p&gt;But how to expire this cache if you will need to update CSS or JavaScript on your site?&lt;/p&gt;
&lt;p&gt;The only way is to change the URL. This is what &lt;code&gt;lack-middleware-static&lt;/code&gt; does for you. It calculates MD5 hash from the file&apos;s content and makes it a part of the URL.&lt;/p&gt;
&lt;p&gt;When the content of the static file is changed, its URL changed as well. Browser notices that change and reloads the content.&lt;/p&gt;
&lt;p&gt;Middleware provides a special tag for &lt;a href=&quot;https://github.com/mmontone/djula&quot;&gt;Djula&lt;/a&gt; template language. Setting up templates for djula is out of thescope of this post and we&apos;ll use &lt;code&gt;busted-uri-for-path&lt;/code&gt; instead, to create a path to a file including a cache hash.&lt;/p&gt;
&lt;p&gt;First, we need to start our server and configure the middleware. Pay attention to the &lt;code&gt;probe-file&lt;/code&gt; call. Root should be an absolute pathname. With relative pathname, you&apos;ll get a wrong result :(&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (clack:clackup
            (funcall
             clack-static-asset-middleware:*clack-static-asset-middleware*
             (lambda (env)
               (list 200 (list :content-type &amp;quot;text/plain&amp;quot;)
                     (list (format nil
                                   &amp;quot;Access this file: ~A&amp;quot;
                                   (clack-static-asset-middleware:busted-uri-for-path

                                    &amp;quot;site.css&amp;quot;)))))
             :path &amp;quot;static/&amp;quot;
             :root (probe-file &amp;quot;static-files/&amp;quot;))
            :port 9004)
Hunchentoot server is started.
Listening on 127.0.0.1:9004.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we can access our index page to get the static&apos;s URL:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:9004/&amp;quot;)
&amp;quot;Access this file: /static/site_ebb4fccbf8e0590b0fcf44c3748af88d.css&amp;quot;
200&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Pay attention to the file&apos;s suffix. It is an md5 hash from file&apos;s content. This sum is calculated when you start the application. If you&apos;ll change the file, during the next deploy another md5 hash will be generated and browser will reload its content.&lt;/p&gt;
&lt;p&gt;If we&apos;ll access this file, the server will respond with &lt;code&gt;Cache-Control&lt;/code&gt; header and set the TTL to 1 year:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&apos;lisp&apos;&gt;POFTHEDAY&amp;gt; (dex:get &amp;quot;http://localhost:9004/static/site_ebb4fccbf8e0590b0fcf44c3748af88d.css&amp;quot;)
&amp;quot;body {font-size: 10px;}&amp;quot;
200 (8 bits, #xC8, #o310, #b11001000)
#&amp;lt;HASH-TABLE :TEST EQUAL :COUNT 8 {1001E58473}&amp;gt;
#&amp;lt;QURI.URI.HTTP:URI-HTTP http://localhost:9004/static/site_ebb4fccbf8e0590b0fcf44c3748af88d.css&amp;gt;
#&amp;lt;SB-SYS:FD-STREAM for &amp;quot;socket 127.0.0.1:53729, peer: 127.0.0.1:9004&amp;quot; {1001E37873}&amp;gt;

POFTHEDAY&amp;gt; (rutils:hash-table-to-alist #v56:2)
((&amp;quot;date&amp;quot; . &amp;quot;Tue, 30 Jun 2020 19:39:55 GMT&amp;quot;)
 (&amp;quot;server&amp;quot; . &amp;quot;Hunchentoot 1.3.0&amp;quot;)
 (&amp;quot;accept-ranges&amp;quot; . &amp;quot;bytes&amp;quot;)
 (&amp;quot;last-modified&amp;quot; . &amp;quot;Tue, 30 Jun 2020 19:15:56 GMT&amp;quot;)
 (&amp;quot;vary&amp;quot; . &amp;quot;Accept-Encoding&amp;quot;)
 (&amp;quot;cache-control&amp;quot; . &amp;quot;public, max-age=31556926&amp;quot;)
 (&amp;quot;content-length&amp;quot; . &amp;quot;23&amp;quot;)
 (&amp;quot;content-type&amp;quot; . &amp;quot;text/css; charset=utf-8&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Tomorrow we&apos;ll review the last Clack&apos;s middleware. I found only 3 of them on the Quicklisp. If you know about other middlewares, let me know and we&apos;ll continue our journey to the world of web development with Clack!&lt;/p&gt;
</description>
            <pubDate>Tue, 30 Jun 2020 22:57:55 +0300</pubDate>
        </item>
    </channel>
</rss>