<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang='en'>
  <head>
    <meta charset='utf-8' />
    <link rel='alternate' href='/lisp-project-of-the-day/rss.xml' type='application/rss+xml' />
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-162105820-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-162105820-1');
  </script>
  
    <link type='text/css' rel='stylesheet' href='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css' />
    <script src='https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js'></script>
    <script src='https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js'></script>
    <link rel='stylesheet' href='../../highlight/styles/tomorrow-night.css' />
    <script src='../../highlight/highlight.pack.js'></script>
    <script>hljs.initHighlightingOnLoad();
    </script>
  </head>
  <body><div class='container'><div class='row'><header><h1 style='text-align: center'><a href='../../index.html'>Lisp Project of the Day</a></h1></header><div class='col-md-12 col-md-offset-0'><h1>asdf-finalizers</h1><p>This is a library written by <a href="https://twitter.com/ngnghm">François-René Rideau</a> in days when he was maintainer of the ASDF. This library allows you to move a piece of code, generated by a macro to the top-level of the lisp component.</p>
<p>This transformation happens during macro-expansion step.</p>
<p>As example of this technique, "asdf-finalizers" contains a system "list-of" which defines a custom type "list-of":</p>
<pre><code class=' lisp'>POFTHEDAY&gt; (asdf:load-system :list-of)
T
POFTHEDAY&gt; (typep &#039;(1 2 3 4 5)
                  &#039;(list-of:list-of integer))
T
POFTHEDAY&gt; (typep &#039;(1 2 3 4 &quot;Hello Lisp World&quot;)
                  &#039;(list-of:list-of integer))
NIL
POFTHEDAY&gt; (typep &#039;((1 2 3))
                  &#039;(list-of:list-of integer))
NIL
POFTHEDAY&gt; (typep &#039;((1 2 3)
                  (4 5 6))
                  &#039;(list-of:list-of
                    (list-of:list-of integer)))
T
POFTHEDAY&gt; (typep &#039;((1 2 &quot;Not an integer&quot;)
                  (4 5 6))
                  &#039;(list-of:list-of
                    (list-of:list-of integer)))
NIL</code></pre><p>It does this by creating a predicate function on the fly first time when you are using the type specifier. Type definition binds a function to the symbol and returns a type specifier (and list (satisfies list-of-integer-p)).</p>
<p>Of cause for different element types it uses their own predicate names.</p>
<p>To reprodice this type definition we could write such code:</p>
<pre><code class=' lisp'>POFTHEDAY&gt; (deftype my-list-of (type)
             (let* ((name (format nil &quot;LIST-OF-~S-P&quot; type))
                    (predicate (intern name)))
               (format t &quot;Creating predicate ~A for ~A~%&quot; name type)
               (setf (symbol-function predicate)
                     (lambda (x)
                       (loop for c = x
                               then (cdr c)
                             while (consp c)
                             always (typep (car c)
                                           type)
                             finally (return (null c)))))
               `(and list
                     (satisfies ,predicate))))
MY-LIST-OF
POFTHEDAY&gt; (typep &#039;(1 2 3)
                  &#039;(my-list-of string))
Creating predicate LIST-OF-STRING-P for STRING
NIL
POFTHEDAY&gt; (typep &#039;(&quot;foo&quot; &quot;bar&quot;)
                  &#039;(my-list-of string))
T
POFTHEDAY&gt; (typep &#039;(1 2 3)
                  &#039;(my-list-of integer))
Creating predicate LIST-OF-INTEGER-P for INTEGER
T
POFTHEDAY&gt; (typep &#039;(1 2 3)
                  &#039;(my-list-of integer))
T</code></pre><p>But if we'll put this naive type definition into a library "my-list-of", then there will be problems.</p>
<p>During the first loading a system, which uses "my-list-of", everything will be ok. But when you'll try to load it into a fresh Lisp image, this UNDEFINED-FUNCTION error will be signaled:</p>
<pre><code class=' text'>The function MYLIST::LIST-OF-INTEGER-P is undefined.</code></pre><p>This is because SBCL processes "(my-list-of integer)" definitions during macroexpansion step, before compilation. But does not do this when loading a compiled FASL.</p>
<p>In other words, using "(my-list-of integer)" in the code causes side-effects during macro-expansion step. And when you are loading a precompiled code into a fresh Lisp image, these side-effects are not available anymore.</p>
<p>"asdf-finalizer" solves this problem, by placing additional code into the (eval-when (:compile-toplevel :load-toplevel :execute)) block. This code may recreate a side-effect during the :load-toplevel phase.</p>
<p>Here is an original "list-of" type definition:</p>
<pre><code class=' lisp'>(deftype list-of (type)
  (case type
    ((t) &#039;list) ;; a (list-of t) is the same as a regular list.
    ((nil) &#039;null) ;; a (list-of nil) can have no elements, it&#039;s null.
    (otherwise
     (let ((predicate (list-of-predicate-for type)))
       (eval-at-toplevel ;; now, and amongst final-forms if enabled
        `(ensure-list-of-predicate &#039;,type &#039;,predicate)
        `(fboundp &#039;,predicate) ;; hush unnecessary eval-at-toplevel warnings
        &quot;Defining ~S outside of finalized Lisp code&quot; `(list-of ,type))
       
       `(and list (satisfies ,predicate))))))</code></pre><p>It uses a function "eval-at-toplevel", which helps "asdf-finalizer" to collect "(ensure-list-of-predicate 'integer 'list-of-integer-p)" forms into a special dynamic variables.</p>
<p>Later, these collected forms should be injected to the top-level with the call to "asdf-finalizers:final-forms":</p>
<pre><code class=' lisp'>(defpackage :test-list-of
  (:use :cl))
(in-package :test-list-of)

(defun check-list-of ()
  (typep &#039;(1 2 3)
         &#039;(list-of:list-of string)))

(final-forms)</code></pre><p>Also, you'll need to replace :file with :finalized-cl-source-file in components section of your ASDF system definition. This will turn on "top-level forms" collection mechanism for this file.</p>
<p>This call to final-forms will be expanded into the forms, injected into a special variable during the macro-expansion stage:</p>
<pre><code class=' lisp'>(eval-when (:compile-toplevel :load-toplevel :execute)
  (ensure-list-of-predicate &#039;integer
                            &#039;list-of-integer-p)
  (ensure-list-of-predicate &#039;string
                            &#039;list-of-string-p)
  ...)</code></pre><p>Each call to "ensure-list-of-predicate" will recreate a predicate function during when the compiled code will be loaded into the fresh Lisp image.</p>
<p>You can also use this technic to inject any code from macroses into the top-level. Just call "asdf-finalizers:eval-at-toplevel" or "asdf-finalizers:register-final-form" from the macro's code and don't forget to insert "(final-forms)" to the end of files where these macroses will be used.</p>
<p>As a bonus for everybody who is interested to learn how does code processing work in Common Lisp, there is a great <a href="https://twitter.com/ngnghm">@ngnghm</a>'s article about Common Lisp code processing stages and eval-when usage:</p>
<p><a href="https://fare.livejournal.com/146698.html">https://fare.livejournal.com/146698.html</a></p>
</div><footer class='clearfix'><hr /><center><p>Brought to you by 40Ants under&nbsp;<a rel='license' href='http://creativecommons.org/licenses/by-sa/4.0/'><img alt='Creative Commons License' style='border-width:0' src='https://i.creativecommons.org/l/by-sa/4.0/88x31.png' /></a></p></center></footer></div></div>
  </body>
</html>