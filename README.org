# -*- encoding:utf-8 Mode: POLY-ORG;  -*- ---
Here I'll post notes about Quicklisp projects. Also I publish them [[https://twitter.com/search?q=%40svetlyak40wt%20%23poftheday&src=typed_query&f=live][on Twitter account svetlyak40wt]].

* 2020
** March
- 07 March – [[content/2020/03/0000-cl-mpg123.org][cl-mpg123]] ([[https://twitter.com/svetlyak40wt/status/1236275871989878784][twitter]])
- 08 March – [[content/2020/03/0001-rate-monotonic.org][rate-monotonic]] ([[https://twitter.com/svetlyak40wt/status/1236551575159607296][twitter]])
- 09 March – [[content/2020/03/0002-cl-custom-hash-table.org][cl-custom-hash-table]] ([[https://twitter.com/svetlyak40wt/status/1237070320206561282][twitter]])
- 10 March - [[content/2020/03/0003-secure-random.org][secure-random]] ([[https://twitter.com/svetlyak40wt/status/1237395451478851585][twitter]])
- 11 March - [[content/2020/03/0004-physical-quantities.org][physical-quantities]] ([[https://twitter.com/svetlyak40wt/status/1237719603477872640][twitter]])
- 12 March - [[content/2020/03/0005-simple-inferiors.org][simple-inferiors]] ([[https://twitter.com/svetlyak40wt/status/1238071476860989440][twitter]])
- 13 March - [[content/2020/03/0006-unix-opts.org][unix-opts]] ([[https://twitter.com/svetlyak40wt/status/1238386638088212480][twitter]])
- 14 March - [[content/2020/03/0007-access.org][access]] ([[https://twitter.com/svetlyak40wt/status/1238937927222255617][twitter]])
- 15 March - [[content/2020/03/0008-re.org][re]] ([[https://twitter.com/svetlyak40wt/status/1239110401419358210][twitter]])
- 16 March - [[content/2020/03/0009-random-sample.org][random-sample]] ([[https://twitter.com/svetlyak40wt/status/1239446033291194368][twitter]])
- 17 March - [[content/2020/03/0010-ppath.org][ppath]] ([[https://twitter.com/svetlyak40wt/status/1239943718448365569][twitter]])
- 18 March - [[content/2020/03/0011-pango-markup.org][pango-markup]] ([[https://twitter.com/svetlyak40wt/status/1240168844003618816][twitter]])
- 19 March - [[content/2020/03/0012-cl-pack.org][cl-pack]] ([[https://twitter.com/svetlyak40wt/status/1240717258755694592][twitter]])
- 20 March - [[content/2020/03/0013-doplus.org][doplus]] ([[https://twitter.com/svetlyak40wt/status/1241045194927230976][twitter]])
- 21 March - [[content/2020/03/0014-cserial-port.org][cserial-port]] ([[https://twitter.com/svetlyak40wt/status/1241407253804126208][twitter]])
- 22 March - [[content/2020/03/0015-cl-bert.org][cl-bert]] ([[https://twitter.com/svetlyak40wt/status/1241722134797443074][twitter]])
- 23 March - [[content/2020/03/0016-kmrcl.org][kmrcl]] ([[https://twitter.com/svetlyak40wt/status/1242093281330241536][twitter]])
- 24 March - [[content/2020/03/0017-cl-org-mode.org][cl-org-mode]] ([[https://twitter.com/svetlyak40wt/status/1242466873662373889][twitter]])
- 25 March - [[content/2020/03/0018-cl-bootstrap.org][cl-bootstrap]] ([[https://twitter.com/svetlyak40wt/status/1242900031881056256][twitter]])
- 26 March - [[content/2020/03/0019-archive.org][archive]] ([[https://twitter.com/svetlyak40wt/status/1243114779763507200][twitter]])


* Code, used to choose a project

First of all, we need to define a package for our code:

#+BEGIN_SRC lisp
(defpackage #:poftheday
  (:use #:cl #:doplus)
  (:export
   #:choose))
(in-package poftheday)
#+END_SRC

Then a function to select random project among all projects, provided by
Quicklisp. Quicklisp client call them "releases".

#+BEGIN_SRC lisp
(defun choose ()
  (let* ((releases (ql::provided-releases t))
         (idx (random (length releases)))
         (release (nth idx releases)))
    (values
     (ql::project-name release)
     (ql::system-files release))))
#+END_SRC

By the way, this function will choose all projects from all installed
Quicklisp distributions. You can have many of them:

#+BEGIN_SRC lisp :load no :wrap
  CL-USER> (ql-dist:install-dist "http://dist.ultralisp.org/"
                                 :prompt nil)
  CL-USER> (ql-dist:all-dists)
  (#<QL-DIST:DIST quicklisp 2019-08-13> #<QL-DIST:DIST ultralisp 20200307123509>)
#+END_SRC

To make randomizer choose different packages after Lisp restart, we need
to initialize it:

#+BEGIN_SRC lisp

  (setf *random-state*
        (make-random-state t))

#+END_SRC

* Here is how a website is rendered

** Collecting source files

First, we need to read walk all org-mode files in folder "content".
We will keep a relative path pointing to the file and parse this file
with cl-org-mode:

#+BEGIN_SRC lisp

(defclass file ()
  ((filename :initarg :filename
             :type string
             :documentation "A relative path to the source org-mode file."
             :reader get-filename)
   (root :initarg :root
         :documentation "Parsed org-mode document, root node."
         :reader get-root)))


(defmethod print-object ((file file) stream)
  (print-unreadable-object (file stream :type t)
    (format stream "~A" (get-filename file))))


(defun read-files ()
  (uiop:while-collecting (collect)
    (flet ((org-mode-p (name)
             (string-equal (pathname-type name)
                           "org"))
           (make-file (filename)
             (collect
                 (let ((relative-filename
                         (ppath:relpath (pathname-to-string filename)
                                        "content/")))
                   (make-instance 'file
                                  :filename relative-filename
                                  :root (cl-org-mode::read-org-file filename))))))
      (cl-fad:walk-directory "content/"
                             #'make-file
                             :test #'org-mode-p))))
#+END_SRC

** Rendering org-mode to HTML

When source files are collected, we need to render them to HTML inside
the "docs" folder. Github will use content of this folder, to serve the
site at http://40ants.com/lisp-project-of-the-day/

To render the page, we need to extract a title from the first outline
node of org-mode file:

#+BEGIN_SRC lisp

(defun get-title (file)
  ;; Title can ends with tags, we need to remove them
  ;; before returning the value
  (cl-ppcre:regex-replace-all
   " :.*:"
   (cl-org-mode::node.heading
    (cl-org-mode::node.next-node
     (get-root file)))
   ""))

#+END_SRC

To iterate over nodes in org-mode file, we will create a custom clause
for the :doplus library. It was described [[content/2020/03/0013-poftheday.org][in this #poftheday post]].

#+BEGIN_SRC lisp

(defclause in-nodes (file)
  `((with (node
           ;; We need to skip root node and first top-level outline node
           (cl-org-mode::node.next-node
            (cl-org-mode::node.next-node
             (get-root ,file)))))
    (for ,*iteration-variable*
         (being node :then (cl-org-mode::node.next-node
                            ,*iteration-variable*)))
    (stop-when (null ,*iteration-variable*))))

#+END_SRC

Org mode file can contain nodes of different types, we will render them
using this generic function:

#+BEGIN_SRC lisp

(defgeneric render-node (node stream)
  (:documentation "Renders org-mode node into the HTML stream"))

#+END_SRC

Outline node contains a header of a section and should be rendered as
H1, H2, etc:

#+BEGIN_SRC lisp

(defmethod render-node ((node cl-org-mode::outline-node) stream)
  (cl-who:with-html-output (stream)
    (:h1 (cl-who:esc (cl-org-mode::node.heading node)))))

#+END_SRC

Text node contains code snippets, we need to wrap them into
<code> tags and add a syntax highlighting:

#+BEGIN_SRC lisp

(defmethod render-node ((node cl-org-mode::src-node) stream)
  (cl-who:with-html-output (stream)
    (:pre
     (:code
      (cl-who:esc (cl-org-mode::node.text node))))))

(defmethod render-node ((node cl-org-mode::closing-delimiter-node) stream)
  ;; Closing delimiters for source code blocks should be ignored.
  )

#+END_SRC

In text node we need to process links and images:

#+BEGIN_SRC lisp

(defmethod render-node ((node cl-org-mode::text-node) stream)
  (cl-who:with-html-output (stream)
    (cl-who:esc (cl-org-mode::node.text node))))

#+END_SRC

#+BEGIN_SRC lisp

(defun make-output-filename (filename)
  (ppath:join "docs"
              (format nil "~A.html" (car (ppath:splitext filename)))))

(defun render-file (file)
  (let ((filename (make-output-filename (get-filename file)))
        (title (get-title file)))
    (ensure-directories-exist filename)
    
    (alexandria:with-output-to-file (stream filename :if-exists :supersede)
      (cl-who:with-html-output (stream)
        (:html
         (:body
          (:h1 :class "title"
               (cl-who:str title))
          (doplus:do+ (for node (in-nodes file))
            (render-node node stream))))))))
  
#+END_SRC

Also, we need a entry-point function which will do all the job - read
files and write html:

#+BEGIN_SRC lisp

(defun render-site ()
  (mapc #'render-file
        (read-files)))

#+END_SRC

** Some utilities
***  Converting pathnames to strings

To work with files we will use [[content/2020/03/0010-ppath.org][ppath]]. This library is able to make
relative path. However, it operates with strings, not pathnames.

#+BEGIN_SRC lisp

(defun pathname-to-string (p)
  (format nil "~A" p))

#+END_SRC

* Good candidates for review
- a bunch of hu.dwim.* systems seems can be very interesting. We can
  make "A Week of DWIM.HU"!
