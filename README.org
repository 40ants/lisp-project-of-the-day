# -*- encoding:utf-8 Mode: POLY-ORG;  -*- ---
Here I'll post notes about Quicklisp projects. Also I publish them [[https://twitter.com/search?q=%40svetlyak40wt%20%23poftheday&src=typed_query&f=live][on
Twitter account svetlyak40wt]].

[[https://github.com/40ants/lisp-project-of-the-day/workflows/CI/badge.svg?branch=master]]

* 2020
** June
- 01 June - [[content/2020/06/0086-pythonic-string-reader.org][pythonic-string-reader]] ([[https://twitter.com/svetlyak40wt/status/1267519478511874052][twitter]])
- 02 June - [[content/2020/06/0087-cl-cron.org][cl-cron]] ([[https://twitter.com/svetlyak40wt/status/1267908838470160393][twitter]])
- 03 June - [[content/2020/06/0088-group-by.org][group-by]] ([[https://twitter.com/svetlyak40wt/status/1268237575426318338][twitter]])
- 04 June - [[content/2020/06/0089-lambda-fiddle.org][lambda-fiddle]] ([[http://40ants.com/lisp-project-of-the-day/2020/05/0067-parse-declarations.html][twitter]])
- 05 June - [[content/2020/06/0090-defmain.org][defmain]] ([[https://twitter.com/svetlyak40wt/status/1268991267490484224][twitter]])
- 06 June - [[content/2020/06/0091-defclass-std.org][defclass-std]] ([[https://twitter.com/svetlyak40wt/status/1269343729724338181][twitter]])
- 07 June - [[content/2020/06/0092-lime.org][lime]] ([[https://twitter.com/svetlyak40wt/status/1269742654277005312][twitter]])
- 08 June - [[content/2020/06/0093-lparallel.org][lparallel]] ([[https://twitter.com/svetlyak40wt/status/1270024901227929602][twitter]])
- 09 June - [[content/2020/06/0094-lfarm.org][lfarm]] ([[https://twitter.com/svetlyak40wt/status/1270417617166258176][twitter]])
- 10 June - [[content/2020/06/0095-cl-gearman][cl-gearman]] ([[https://twitter.com/svetlyak40wt/status/1270782560096989184][twitter]])
- 11 June - [[content/2020/06/0096-cl-reddit.org][cl-reddit]] ([[https://twitter.com/svetlyak40wt/status/1271181659057070083][twitter]])
- 12 June - [[content/2020/06/0097-sblint.org][sblint]] ([[https://twitter.com/svetlyak40wt/status/1271542482338304001][twitter]])

** May
- 01 May - [[content/2020/05/0055-cl-heredoc.org][cl-heredoc]] ([[https://twitter.com/svetlyak40wt/status/1256294437010931712][twitter]])
- 02 May - [[content/2020/05/0056-trivial-indent.org][trivial-indent]] ([[https://twitter.com/svetlyak40wt/status/1256668072422899713][twitter]])
- 03 May - [[content/2020/05/0057-pretty-function.org][pretty-function]] ([[https://twitter.com/svetlyak40wt/status/1257048413427978241][twitter]])
- 04 May - [[content/2020/05/0058-atomics.org][atomics]] ([[https://twitter.com/svetlyak40wt/status/1257279361348239360][twitter]])
- 05 May - [[content/2020/05/0059-cl-ncurses.org][cl-ncurses]] ([[https://twitter.com/svetlyak40wt/status/1257769475002322945][twitter]])
- 06 May - [[content/2020/05/0060-clawk.org][clawk]] ([[https://twitter.com/svetlyak40wt/status/1258113663128518660][twitter]])
- 07 May - [[content/2020/05/0061-cl-charms.org][cl-charms]] ([[https://twitter.com/svetlyak40wt/status/1258483627530346496][twitter]])
- 08 May - [[content/2020/05/0062-magic-ed.org][magic-ed]] ([[https://twitter.com/svetlyak40wt/status/1258841379582738436][twitter]])
- 09 May - [[content/2020/05/0063-asdf-viz.org][asdf-viz]] ([[https://twitter.com/svetlyak40wt/status/1259217595699466241][twitter]])
- 10 May - [[content/2020/05/0064-xml-emitter.org][xml-emitter]] ([[https://twitter.com/svetlyak40wt/status/1259503402230390784][twitter]])
- 11 May - [[content/2020/05/0065-rutils.org][rutils]] ([[https://twitter.com/svetlyak40wt/status/1259893019131682824][twitter]])
- 12 May - [[content/2020/05/0066-str.org][str]] ([[https://twitter.com/svetlyak40wt/status/1260279004067749888][twitter]])
- 13 May - [[content/2020/05/0067-parse-declarations.org][parse-declarations]] ([[https://twitter.com/svetlyak40wt/status/1260645157289881600][twitter]])
- 14 May - [[content/2020/05/0068-cl-utilities.org][cl-utilities]] ([[https://twitter.com/svetlyak40wt/status/1261011829746274304][twitter]])
- 15 May - [[content/2020/05/0069-osicat.org][osicat]] ([[https://twitter.com/svetlyak40wt/status/1261392055743311873][twitter]])
- 16 May - [[content/2020/05/0070-split-sequence.org][split-sequence]] ([[https://twitter.com/svetlyak40wt/status/1261735950213943302][twitter]])
- 17 May - [[content/2020/05/0071-parenscript.org][parenscript]] ([[https://twitter.com/svetlyak40wt/status/1262100811640967169][twitter]])
- 18 May - [[content/2020/05/0072-plump.org][plump]] ([[https://twitter.com/svetlyak40wt/status/1262443990021963777][twitter]])
- 19 May - [[content/2020/05/0073-clss.org][clss]] ([[https://twitter.com/svetlyak40wt/status/1262820171741265921][twitter]])
- 20 May - [[content/2020/05/0074-lquery.org][lquery]] ([[https://twitter.com/svetlyak40wt/status/1263152708468518913][twitter]])
- 21 May - [[content/2020/05/0075-cl-who.org][cl-who]] ([[https://twitter.com/svetlyak40wt/status/1263532054525902848][twitter]])
- 22 May - [[content/2020/05/0076-cl-change-case.org][cl-change-case]] ([[https://twitter.com/svetlyak40wt/status/1263898979282141184][twitter]])
- 23 May - [[content/2020/05/0077-named-readtables.org][named-readtables]] ([[https://twitter.com/svetlyak40wt/status/1264257101175689218][twitter]])
- 24 May - [[content/2020/05/0078-trivial-ssh.org][trivial-ssh]] ([[https://twitter.com/svetlyak40wt/status/1264615051912151041][twitter]])
- 25 May - [[content/2020/05/0079-cl-collider.org][cl-collider]] ([[https://twitter.com/svetlyak40wt/status/1264970668854120449][twitter]])
- 26 May - [[content/2020/05/0080-jose.org][jose]] ([[https://twitter.com/svetlyak40wt/status/1265325558000484354][twitter]])
- 27 May - [[content/2020/05/0081-cl-ppcre-unicode.org][cl-ppcre-unicode]] ([[https://twitter.com/svetlyak40wt/status/1265695892285292545][twitter]])
- 28 May - [[content/2020/28/0082-data-table.org][data-table]] ([[https://twitter.com/svetlyak40wt/status/1266117466096369664][twitter]])
- 29 May - [[content/2020/05/0083-assoc-utils.org][assoc-utils]] ([[https://twitter.com/svetlyak40wt/status/1266431240925843456][twitter]])
- 30 May - [[content/2020/0084-cl-ascii-table.org][cl-ascii-table]] ([[https://twitter.com/svetlyak40wt/status/1266805748748767232][twitter]])
- 31 May - [[content/2020/05/0085-simplified-types.org][simplified-types]] ([[https://twitter.com/svetlyak40wt/status/1267165838039285760][twitter]])

** April
- 01 April - [[content/2020/04/0025-april.org][april]] ([[https://twitter.com/svetlyak40wt/status/1245315377397186568][twitter]])
- 02 April - [[content/2020/04/0026-periods.org][periods]] ([[https://twitter.com/svetlyak40wt/status/1245693772316528641][twitter]])
- 03 April - [[content/2020/04/0027-golden-utils.org][golden-utils]] ([[https://twitter.com/svetlyak40wt/status/1246106685745311777][twitter]])
- 04 April - [[content/2020/04/0028-cl-conspack.org][cl-conspack]] ([[https://twitter.com/svetlyak40wt/status/1246429190439739399][twitter]])
- 05 April - [[content/2020/04/0029-skippy][skippy]] ([[https://twitter.com/svetlyak40wt/status/1246779138335289346][twitter]])
- 06 April - [[content/2020/03/0030-skippy-renderer.org][skippy-renderer & zpng]] ([[https://twitter.com/svetlyak40wt/status/1247269224860581896][twitter]])
- 07 April - [[content/2020/04/0031-lispqr.org][lispqr]] ([[https://twitter.com/svetlyak40wt/status/1247548175352823808][twitter]])
- 08 April - [[content/2020/04/0032-buildnode.org][buildnode]] ([[https://twitter.com/svetlyak40wt/status/1247931828071211008][twitter]])
- 09 April - [[content/2020/04/0033-trivialib.type-unify.org][trivialib.type-unify]] ([[https://twitter.com/svetlyak40wt/status/1248304050778583040][twitter]])
- 10 April - [[content/2020/04/0034-cl-progress-bar.org][cl-progress-bar]] ([[https://twitter.com/svetlyak40wt/status/1248662624465833989][twitter]])
- 11 April - [[content/2020/04/0035-trivial-mmap.org][trivial-mmap]] ([[https://twitter.com/svetlyak40wt/status/1249021775742226432][twitter]])
- 12 April - [[content/2020/04/0036-mtlisp.org][mtlisp]] ([[https://twitter.com/svetlyak40wt/status/1249437833858867200][twitter]])
- 13 April - [[content/2020/04/0037-deploy.org][deploy]] ([[https://twitter.com/svetlyak40wt/status/1249776210709708801][twitter]])
- 14 April - [[content/2020/04/0038-asdf-linguist.org][asdf-linguist]] ([[https://twitter.com/svetlyak40wt/status/1250125216447152128][twitter]])
- 15 April - [[content/2020/04/0039-com.google.base.org][com.google.base]] ([[https://twitter.com/svetlyak40wt/status/1250523505382363137][twitter]])
- 16 April - [[content/2020/04/0040-asdf-finalizers.org][asdf-finalizers]] ([[https://twitter.com/svetlyak40wt/status/1250840036184113155][twitter]])
- 17 April - [[content/2020/04/0041-bodge-blobs-support.org][bodge-blobs-support]] ([[https://twitter.com/svetlyak40wt/status/1251183079072432129][twitter]])
- 18 April - [[content/2020/04/0042-trivial-package-manager.org][trivial-package-manager]] ([[https://twitter.com/svetlyak40wt/status/1251518621165248512][twitter]])
- 19 April - [[content/2020/04/0043-hu.dwim.asdf.org][hu.dwim.asdf]] ([[https://twitter.com/svetlyak40wt/status/1251946744356777991][twitter]])
- 20 April - [[content/2020/04/0044-hu.dwim.walker.org][hu.dwim.walker]] ([[https://twitter.com/svetlyak40wt/status/1252332579526709249][twitter]])
- 21 April - [[content/2020/04/0045-cl-lexer.org][cl-lexer]] ([[https://twitter.com/svetlyak40wt/status/1252668190968238081][twitter]])
- 22 April - [[content/2020/04/0046-arrows.org][arrows]] ([[https://twitter.com/svetlyak40wt/status/1253050884461932551][twitter]])
- 23 April - [[content/2020/04/0047-constantfold.org][constantfold]] ([[https://twitter.com/svetlyak40wt/status/1253405484465479680][twitter]])
- 24 April - [[content/2020/04/0048-find-port.org][find-port]] ([[https://twitter.com/svetlyak40wt/status/1253742586927480832][twitter]])
- 25 April - [[content/2020/04/0049-print-html.org][print-html]] ([[https://twitter.com/svetlyak40wt/status/1254090822192152577][twitter]])
- 26 April - [[content/2020/04/0050-literate-lisp.org][literate-lisp]] ([[https://twitter.com/svetlyak40wt/status/1254493004695560194][twitter]])
- 27 April - [[content/2020/04/0051-should-test.org][should-test]] ([[https://twitter.com/svetlyak40wt/status/1254838764913950721][twitter]])
- 28 April - [[content/2020/04/0052-beast.org][beast]] ([[https://twitter.com/svetlyak40wt/status/1255227547379531777][twitter]])
- 29 April - [[content/2020/04/0053-cl-locale.org][cl-locale]] ([[https://twitter.com/svetlyak40wt/status/1255599103255420933][twitter]])
- 30 April - [[content/2020/04/0054-hu.dwim.def.org][hu.dwim.def]] ([[https://twitter.com/svetlyak40wt/status/1255941098905755649][twitter]])

** March
- 07 March â€“ [[content/2020/03/0000-cl-mpg123.org][cl-mpg123]] ([[https://twitter.com/svetlyak40wt/status/1236275871989878784][twitter]])
- 08 March â€“ [[content/2020/03/0001-rate-monotonic.org][rate-monotonic]] ([[https://twitter.com/svetlyak40wt/status/1236551575159607296][twitter]])
- 09 March â€“ [[content/2020/03/0002-cl-custom-hash-table.org][cl-custom-hash-table]] ([[https://twitter.com/svetlyak40wt/status/1237070320206561282][twitter]])
- 10 March - [[content/2020/03/0003-secure-random.org][secure-random]] ([[https://twitter.com/svetlyak40wt/status/1237395451478851585][twitter]])
- 11 March - [[content/2020/03/0004-physical-quantities.org][physical-quantities]] ([[https://twitter.com/svetlyak40wt/status/1237719603477872640][twitter]])
- 12 March - [[content/2020/03/0005-simple-inferiors.org][simple-inferiors]] ([[https://twitter.com/svetlyak40wt/status/1238071476860989440][twitter]])
- 13 March - [[content/2020/03/0006-unix-opts.org][unix-opts]] ([[https://twitter.com/svetlyak40wt/status/1238386638088212480][twitter]])
- 14 March - [[content/2020/03/0007-access.org][access]] ([[https://twitter.com/svetlyak40wt/status/1238937927222255617][twitter]])
- 15 March - [[content/2020/03/0008-re.org][re]] ([[https://twitter.com/svetlyak40wt/status/1239110401419358210][twitter]])
- 16 March - [[content/2020/03/0009-random-sample.org][random-sample]] ([[https://twitter.com/svetlyak40wt/status/1239446033291194368][twitter]])
- 17 March - [[content/2020/03/0010-ppath.org][ppath]] ([[https://twitter.com/svetlyak40wt/status/1239943718448365569][twitter]])
- 18 March - [[content/2020/03/0011-pango-markup.org][pango-markup]] ([[https://twitter.com/svetlyak40wt/status/1240168844003618816][twitter]])
- 19 March - [[content/2020/03/0012-cl-pack.org][cl-pack]] ([[https://twitter.com/svetlyak40wt/status/1240717258755694592][twitter]])
- 20 March - [[content/2020/03/0013-doplus.org][doplus]] ([[https://twitter.com/svetlyak40wt/status/1241045194927230976][twitter]])
- 21 March - [[content/2020/03/0014-cserial-port.org][cserial-port]] ([[https://twitter.com/svetlyak40wt/status/1241407253804126208][twitter]])
- 22 March - [[content/2020/03/0015-cl-bert.org][cl-bert]] ([[https://twitter.com/svetlyak40wt/status/1241722134797443074][twitter]])
- 23 March - [[content/2020/03/0016-kmrcl.org][kmrcl]] ([[https://twitter.com/svetlyak40wt/status/1242093281330241536][twitter]])
- 24 March - [[content/2020/03/0017-cl-org-mode.org][cl-org-mode]] ([[https://twitter.com/svetlyak40wt/status/1242466873662373889][twitter]])
- 25 March - [[content/2020/03/0018-cl-bootstrap.org][cl-bootstrap]] ([[https://twitter.com/svetlyak40wt/status/1242900031881056256][twitter]])
- 26 March - [[content/2020/03/0019-archive.org][archive]] ([[https://twitter.com/svetlyak40wt/status/1243114779763507200][twitter]])
- 27 March - [[content/2020/03/0020-cl-hash-table-destructuring.org][cl-hash-table-destructuring]] ([[https://twitter.com/svetlyak40wt/status/1243506491040116737][twitter]])
- 28 March - [[content/2020/03/0021-lass.org][lass]] ([[https://twitter.com/svetlyak40wt/status/1243862908217569283][twitter]])
- 29 March - [[content/2020/03/0022-bubble-operator-upwards.org][bubble-operator-upwards]] ([[https://twitter.com/svetlyak40wt/status/1244319074353643520][twitter]])
- 30 March - [[content/2020/03/0023-softdrink.org][softdrink]] ([[https://twitter.com/svetlyak40wt/status/1244581585246195712][twitter]])
- 31 March - [[content/2020/03/0024-chronicity.org][chronicity]] ([[https://twitter.com/svetlyak40wt/status/1244917161237401603][twitter]])

* Code, used to choose a project

First of all, we need to define a package for our code:

#+BEGIN_SRC lisp
(defpackage #:poftheday
  (:use #:cl)
  (:import-from #:rutils
                #:iter
                #:with
                #:fmt)
  (:export
   #:choose))
(in-package poftheday)
#+END_SRC

Then a function to select random project among all projects, provided by
Quicklisp. Quicklisp client call them "releases".

#+BEGIN_SRC lisp
(defun choose ()
  (let* ((releases (ql::provided-releases t))
         (idx (random (length releases)))
         (release (nth idx releases)))
    (values
     (ql::project-name release)
     (ql::system-files release))))
#+END_SRC

By the way, this function will choose all projects from all installed
Quicklisp distributions. You can have many of them:

#+BEGIN_SRC lisp :load no :wrap
  CL-USER> (ql-dist:install-dist "http://dist.ultralisp.org/"
                                 :prompt nil)
  CL-USER> (ql-dist:all-dists)
  (#<QL-DIST:DIST quicklisp 2019-08-13> #<QL-DIST:DIST ultralisp 20200307123509>)
#+END_SRC

To make randomizer choose different packages after Lisp restart, we need
to initialize it:

#+BEGIN_SRC lisp

  (setf *random-state*
        (make-random-state t))

#+END_SRC

* Here is how a website is rendered

** Collecting source files

First, we need to read walk all org-mode files in folder "content".
We will keep a relative path pointing to the file and parse this file
with cl-org-mode:

#+BEGIN_SRC lisp

(defclass file ()
  ((filename :initarg :filename
             :type string
             :documentation "A relative path to the source org-mode file."
             :reader get-filename)
   (root :initarg :root
         :documentation "Parsed org-mode document, root node."
         :reader get-root)))


(defmethod print-object ((file file) stream)
  (print-unreadable-object (file stream :type t)
    (format stream "~A" (get-filename file))))


(defun read-files ()
  (uiop:while-collecting (collect)
    (flet ((org-mode-p (name)
             (string-equal (pathname-type name)
                           "org"))
           (make-file (filename)
             (collect
                 (let ((relative-filename
                         (ppath:relpath (pathname-to-string filename)
                                        "content/")))
                   (make-instance 'file
                                  :filename relative-filename
                                  :root (cl-org-mode::read-org-file filename))))))
      (cl-fad:walk-directory "content/"
                             #'make-file
                             :test #'org-mode-p))))
#+END_SRC

** Rendering org-mode to HTML

*** A page skeleton
For each page we need a skeleton with header, footer and necessary
Bootstrap styles.

With "cl-who" easiest way to create template is to use lisp macro like
that:

#+BEGIN_SRC lisp

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *google-code* "
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src=\"https://www.googletagmanager.com/gtag/js?id=UA-162105820-1\"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-162105820-1');
  </script>
  "))


(defvar *index-uri* nil
  "This is a path to the site's top level. When it is nil, consider we are on the front page.")


(defun construct-uri (uri &rest args)
  (if *index-uri*
      (concatenate 'string
                   *index-uri*
                   (apply #'rutils:fmt uri args))
      (apply #'rutils:fmt uri args)))


(defmacro app-page ((stream &key title index-uri (site-title "Lisp Project of the Day")) &body body)
  `(let ((*index-uri* ,index-uri))
     (cl-who:with-html-output (*standard-output* ,stream :prologue t :indent t)
       (:html :lang "en"
         (:head
          (:meta :charset "utf-8")
          ,@(when title
              `((:title (cl-who:esc ,title))))
          (:link :rel "alternate"
                 :href "https://40ants.com/lisp-project-of-the-day/rss.xml"
                 :type "application/rss+xml")
          ,*google-code*
          (:link
           :type "text/css"
           :rel "stylesheet"
           :href  ,cl-bootstrap:*bootstrap-css-url*)
          (:script :src ,cl-bootstrap:*jquery-url*)
          (:script :src ,cl-bootstrap:*bootstrap-js-url*)
          (:link :rel "stylesheet"
                 :href "../../highlight/styles/tomorrow-night.css")
          (:script :src "../../highlight/highlight.pack.js")
          (:script "hljs.initHighlightingOnLoad();")
          (:style "
.tags .label {
    margin-right: 1em;
}
.posts tr {
    line-height: 1.7em;
}
.posts tr td.number {
    font-weight: bold;
    padding-right: 0.7em;
}
.posts tr td.tags {
    padding-left: 0.7em;
}
h1 .tags {
    font-size: 1.2rem;
    position: relative;
    left: 1.5rem;
    top: -1.5rem;
}
.tags a {
    text-decoration: none;
}
"))
         (:body 
          (cl-bootstrap:bs-container ()
            (cl-bootstrap:bs-row
              (:a :href "https://40ants.com/lisp-project-of-the-day/rss.xml"
                  :style "display: block; float: right;"
                  (:img :alt "RSS Feed"
                        :src "https://40ants.com/lisp-project-of-the-day/media/images/rss.png"))
              (:header
               (:h1 :style "text-align: center"
                    (if ,index-uri
                        (cl-who:htm
                         (:a :href (rutils:fmt "~Aindex.html" ,index-uri)
                             (cl-who:esc ,site-title)))
                        (cl-who:esc ,site-title)))
               ,@(when title
                   `((:h2 :style "text-align: center"
                          (cl-who:esc ,title)))))
              (cl-bootstrap:bs-col-md ()
                (:center
                 (:h3 "You can support this project by donating at:")
                 (:a :href "https://www.patreon.com/bePatron?u=33868637"
                     (:img :alt "Donate using Patreon"
                           :src "https://40ants.com/lisp-project-of-the-day/media/images/patreon-btn.png"
                           :width "160"))
                 (:a :href "https://liberapay.com/poftheday/donate"
                     (:img :alt "Donate using Liberapay"
                           :src "https://liberapay.com/assets/widgets/donate.svg")))
                ,@body))
            (:div
             (:hr)
             (:center
              (:p (cl-who:str "Brought to you by 40Ants under&nbsp;")
                  (:a :rel "license"
                      :href "http://creativecommons.org/licenses/by-sa/4.0/"
                      (:img :alt "Creative Commons License"
                            :style "border-width:0"
                            :src "https://i.creativecommons.org/l/by-sa/4.0/88x31.png")))))))))))

#+END_SRC
*** Generation of separate pages for articles

When source files are collected, we need to render them to HTML inside
the "docs" folder. Github will use content of this folder, to serve the
site at http://40ants.com/lisp-project-of-the-day/

To render the page, we need to extract a title from the first outline
node of org-mode file:

#+BEGIN_SRC lisp

(defun remove-tags (title)
  (cl-ppcre:regex-replace-all " *:.*:$" title ""))

(defun extract-tags (title)
  (declare (type simple-string title))
  (when (find #\: title :test #'char=)
    (mapcar (alexandria:curry #'str:replace-all "_" "-")
            (str:split #\:
                       (cl-ppcre:regex-replace-all ".*?:(.*):$" title "\\1")))))

(defun get-title (file)
  ;; Title can ends with tags, we need to extract them
  ;; and return as a second value.   
  (let ((full-title (cl-org-mode::node.heading
                     (cl-org-mode::node.next-node
                      (get-root file)))))
    (values (remove-tags full-title)
            (extract-tags full-title))))

#+END_SRC

I'll need to render HTML in two modes. First one - for the web page, and
second - for RSS feed. For RSS feed I need to omit the first H1 header
and a table of properties.

#+BEGIN_SRC lisp

(defvar *rss-mode* nil)

#+END_SRC

Org mode file can contain nodes of different types, we will render them
using this generic function:

#+BEGIN_SRC lisp

(defgeneric render-node (node stream)
  (:documentation "Renders org-mode node into the HTML stream"))

#+END_SRC

Outline node contains a header of a section and should be rendered as
H1, H2, etc:

#+BEGIN_SRC lisp

(defmethod render-node ((node cl-org-mode::outline-node) stream)
  (cl-who:with-html-output (stream)
    ;; First node is a title
    (with ((level (1- (length (cl-org-mode::node.heading-level-indicator node))))
           (full-title (cl-org-mode::node.heading node))
           (title (remove-tags full-title)))
      (ecase level
        (1 (unless *rss-mode*
             (cl-who:htm
              (:h1 (cl-who:esc title)
                   (:span :class "tags"
                          (loop for tag in (extract-tags full-title)
                          do (cl-who:htm
                              (:a :href (construct-uri "tags/~A.html" tag)
                                  (cl-bootstrap:bs-label ()
                                    (cl-who:esc tag))))))))))
        (2 (cl-who:htm
            (:h2 (cl-who:esc title))))
        (3 (cl-who:htm
            (:h3 (cl-who:esc title)))))))
  (call-render-for-all-children node stream))

#+END_SRC

First outline of the article can have properties. These properties
describe the state of the project, if it has documentation, how active
it is, etc. These properties have grades:

- :) everything is good
- :| means, for example, that documentation exists as a short readme and
  dont cover all functionality
- :( the project lack of this category at all.

#+BEGIN_SRC lisp

(defun smile->unicode (text)
  (arrows:->>
      text
    (str:replace-all ":)" "ðŸ˜€")
    (str:replace-all ":|" "ðŸ¤¨")
    (str:replace-all ":(" "ðŸ¥º")))

(defmethod render-node ((node cl-org-mode::properties-node) stream)
  (unless *rss-mode*
    (cl-who:with-html-output (stream)
      (:table :style "position: relative; float: right; background-color: #F1F1F1; padding: 1em; margin-left: 1em; margin-bottom: 1em; border: 1px solid #D1D1D1;"
              (mapcar
               (lambda (item)
                 (render-node item stream))
               (cl-org-mode::node.children node))))))

(defmethod render-node ((node cl-org-mode::property-node) stream)
  (cl-who:with-html-output (stream)
    (:tr
     (:td :style "padding-left: 0.5rem; padding-right: 0.5rem"
          (cl-who:esc
           (cl-org-mode::property-node.property node)))
     (:td :style "padding-left: 0.5rem; padding-right: 0.5rem; border-left: 1px solid #DDD"
          (cl-who:esc
           (smile->unicode
            (cl-org-mode::property-node.value node)))))))

#+END_SRC

Text node contains code snippets, we need to wrap them into
<code> tags and add a syntax highlighting:

#+BEGIN_SRC lisp

(defmethod render-node ((node cl-org-mode::src-node) stream)
  (cl-who:with-html-output (stream)
    (:pre
     (:code :class (string-trim (list #\Newline)
                                (cl-org-mode::node.emacs-mode node))
            (cl-who:esc (str:trim
                         (cl-org-mode::node.text node)))))))

(defmethod render-node ((node cl-org-mode::closing-delimiter-node) stream)
  ;; Closing delimiters for source code blocks should be ignored.
  )

#+END_SRC

In text node we need to process paragraphs, links, images and quotes. We
will use a separate function to process text like this:

#+BEGIN_QUOTE
Today's Common Lisp project of the Day is: rate-monotonic.

It is a periodic thread scheduler inspired by RTEMS:

http://quickdocs.org/rate-monotonic/
#+END_QUOTE

into HTML:

#+BEGIN_QUOTE
<p>Today's Common Lisp project of the Day is: rate-monotonic.</p>

<p>It is a periodic thread scheduler inspired by RTEMS:</p>

<a href="http://quickdocs.org/rate-monotonic/">http://quickdocs.org/rate-monotonic/</a>
#+END_QUOTE

To do this, we'll write a simple state machine, which will read
text line by line and wrap it's pieces in appropriate HTML tags:

#+BEGIN_SRC lisp

(defun replace-images (text)
  (cl-ppcre:regex-replace-all
   "\\[\\[(.*?\\.(png|jpg|gif))\\]\\]"
   text
   "<img style=\"max-width: 100%\" src=\"\\1\"/>"))

(defun replace-links (text)
  (cl-ppcre:regex-replace-all
   "\\[\\[(.*?)\\]\\[(.*?)\\]\\]"
   text
   "<a href=\"\\1\">\\2</a>"))

(defun replace-raw-urls (text)
  (cl-ppcre:regex-replace-all
   "(^| )(https?://.*?)[,.!]?( |$)"
   text
   "\\1<a href=\"\\2\">\\2</a>\\3"))

(defun replace-inline-code (text)
  (cl-ppcre:regex-replace-all
   "~(.*?)~"
   text
   "<code>\\1</code>"))

(defun replace-org-mode-markup-with-html (text)
  (replace-inline-code
   (replace-raw-urls
    (replace-links
     (replace-images
      text)))))

(defun render-text (text stream)
  (let ((buffer nil)
        (reading-quote nil)
        (reading-list nil))
    (labels
        ((write-paragraph ()
           (cl-who:with-html-output (stream)
             (:p (cl-who:str
                  ;; Here we don't escape the text, because
                  ;; it is from trusted source and will contain
                  ;; links to the images
                  (replace-org-mode-markup-with-html
                   (str:join " " (nreverse buffer))))))
           (write-char #\Newline stream)
           (setf buffer nil))
         (write-quote ()
           (cl-who:with-html-output (stream)
             (:blockquote
              (:pre
               (cl-who:esc
                (str:join #\Newline (nreverse buffer))))))
           (write-char #\Newline stream)
           (setf buffer nil))
         (write-list ()
           (cl-who:with-html-output (stream)
             (:ul
              (loop for item in (reverse buffer)
                    do (cl-who:htm
                        (:li (cl-who:str (replace-org-mode-markup-with-html item)))))))
           (write-char #\Newline stream)
           (setf buffer nil))
         (process (line)
           (cond
             ((and (str:starts-with-p "- " line)
                   (not reading-quote))
              (push (subseq line 2)
                    buffer)
              (setf reading-list t))
             ((and reading-list
                   (string= line ""))
              (write-list)
              (setf reading-list nil))
             (reading-list
              (setf buffer
                    (list*
                     (format nil "~A ~A"
                             (car buffer)
                             line)
                     (cdr buffer))))
             ((string-equal line
                            "#+BEGIN_QUOTE")
              (setf reading-quote t))
             ((string-equal line
                            "#+END_QUOTE")
              (setf reading-quote nil)
              (write-quote))
             ((not (string= line ""))
              (push line buffer))
             ((and (not reading-quote)
                   (and (string= line "")
                        buffer))
              (write-paragraph)))))
      (mapc #'process
            (str:split #\Newline text)))))

#+END_SRC

Now, we will use this text processing function to render all text nodes
in our org-mode files:

#+BEGIN_SRC lisp

(defmethod render-node ((node cl-org-mode::text-node) stream)
  (render-text (cl-org-mode::node.text node)
               stream))

#+END_SRC

Now it is time to write a code which will render all org mode files into HTML:

#+BEGIN_SRC lisp

(defun make-output-filename (file)
  (check-type file file)
  (ppath:join "docs"
              (format nil "~A.html" (car (ppath:splitext (get-filename file))))))

(defmethod render-node ((file file) stream)
  (render-node (get-root file)
               stream))

(defun call-render-for-all-children (node stream)
  (loop for child in (cl-org-mode::node.children node)
        do (render-node child
                        stream)))

(defmethod render-node ((file cl-org-mode::org-file) stream)
  (call-render-for-all-children file stream))

(defun render-file (file)
  (with ((filename (make-output-filename file))
         (title (get-title file)))
    (ensure-directories-exist filename)

    (alexandria:with-output-to-file (stream filename :if-exists :supersede)
      (app-page (stream :index-uri "../../"
                        :title title)
        (cl-who:with-html-output (stream)
          (render-node file stream)
          (write-string "
<script src=\"https://utteranc.es/client.js\"
        repo=\"40ants/lisp-project-of-the-day\"
        issue-term=\"title\"
        label=\"comments\"
        theme=\"github-light\"
        crossorigin=\"anonymous\"
        async>
</script>
" stream))))))
  
#+END_SRC

*** Writing RSS feed

We want to show in RSS only posts, published at Twitter. This
information can be extracted from the README.org, because there I'm
adding a link to the tweet. If there is a link, the post is published.

So, we have to find all list items inside "2020" heading and choose only
those, having a link to the twitter.

#+BEGIN_SRC lisp

(defun find-not-published-systems ()
  (let* ((file (cl-org-mode::read-org-file "README.org"))
         (years (loop for node = file then (cl-org-mode::node.next-node node)
                      while node
                      when (and (typep node 'cl-org-mode::outline-node)
                                (str:starts-with-p "20"
                                                   (cl-org-mode::node.heading node)))
                      collect node))
         (months (loop for year in years
                       appending (cl-org-mode::node.children year)))
         (text-nodes (loop for month in months
                           appending (cl-org-mode::node.children month)))
         (texts (loop for node in text-nodes
                      collect (cl-org-mode::node.text node)))
         (lines (loop for text in texts
                      appending (str:split #\Newline text))))
    (loop for line in lines
          when (and (str:starts-with-p "-" line)
                    ;; If there are two links, then the second link is to the twitter post.
                    ;; In this case this post is published.
                    (= (str:count-substring "[[" line)
                       1))
          appending (str:split " & "
                               (cl-ppcre:regex-replace
                                ".*?\\]\\[(.*?)\\].*"
                                line
                                "\\1")))))

#+END_SRC

Also, for each file we need to know when it was created. Without a date,
many RSS clients will display feed in a wrong ways.

Next function get's the timestamp of the commit with "publish" keyword
in a text. Or the timestamp of the first commit where the file
was added to the repository.

As the second value, it returns a commit message a timestamp was take
from. This was useful for debugging:

#+BEGIN_SRC lisp

(defun get-file-timestamp (file)
  (let* ((all-commits (with-output-to-string (*standard-output*)
                        (legit:git-log :paths (fmt "content/~A"
                                                   (get-filename file))
                                       :reverse t
                                       :format "%at %s")))
         (lines (str:split #\Newline all-commits))
         (first-timestamp
           (parse-integer (first (str:split #\Space
                                            (first lines))))))
    (local-time:unix-to-timestamp first-timestamp)))

#+END_SRC

#+BEGIN_SRC lisp

(defun render-rss (files)
  (alexandria:with-output-to-file (stream "docs/rss.xml"
                                          :if-exists :supersede)
    (let ((base-url "http://40ants.com/lisp-project-of-the-day/")
          (not-published (find-not-published-systems)))
      (flet ((is-not-published (file)
               (let ((title (get-title file))
                     (filename (get-filename file)))
                 (or (member title
                             not-published
                             :test #'string-equal)
                     (str:containsp "draft"
                                    filename)))))
        (xml-emitter:with-rss2 (stream)
          (xml-emitter:rss-channel-header "Common Lisp Project of the Day"
                                          base-url)
          (loop for file in (rutils:take 20 (reverse
                                             (remove-if #'is-not-published
                                                        files)))
                for title = (get-title file)
                for uri = (get-uri file)
                for full-url = (format nil "~A~A" base-url uri)
                for description = (make-description file)
                for timestamp = (get-file-timestamp file)
                do (xml-emitter:rss-item title
                                         :description description
                                         :link full-url
                                         :pubdate (local-time:format-rfc1123-timestring
                                                   nil timestamp))))))))

#+END_SRC

*** Generating index page

On index page we want to output a list of all articles.
Probably later, we'll want to print only the latest and to create a tags
based catalogue, but now a simple list is enough.

We'll use few helpers to create urls and titles for the index page:

#+BEGIN_SRC lisp

(defun strip-doc-folder (filename)
  "Removes doc/ from beginning of the filename"
  (cond
    ((str:starts-with-p "docs/" filename)
     (subseq filename 5))
    (t filename)))

(defun get-uri (file)
  "Returns a link like 2020/03/001-some.html"
  (strip-doc-folder (make-output-filename file)))


(defun get-title-for-index (file)
  (rutils:with ((title tags (get-title file))
                (filename (get-filename file))
                (splitted (ppath:split filename))
                (only-file (cdr splitted))
                (number (first (str:split #\- only-file))))
    (values title number tags)))

#+END_SRC

We'll reuse this function for the front page and for tag pages:

#+BEGIN_SRC lisp
  
(defun render-index-page (files filename &key
                                           (index-uri nil)
                                           (path "docs")
                                           (title "Latest posts"))
  (let ((filename (ppath:join path
                              (rutils:fmt "~A.html"
                                          filename)))
        (not-published (find-not-published-systems)))
    (ensure-directories-exist filename)
    
    (flet ((is-not-published (file)
             (let ((title (get-title file)))
               (member title
                       not-published
                       :test #'string-equal))))
      (alexandria:with-output-to-file (stream filename :if-exists :supersede)
        (app-page (stream :index-uri index-uri)
          (:section :style "margin-left: auto; margin-right: auto; margin-top: 2em; width: 50%"
                    (:h3 :style "margin-left: 1.6em"
                         title)
                    (:table :class "posts"
                            (loop for file in (reverse files)
                                  for uri = (get-uri file)
                                  do (cl-who:htm
                                      (:tr
                                       (multiple-value-bind (title number tags)
                                           (get-title-for-index file)
                                  
                                         (unless (string-equal number
                                                               "draft")
                                           (cl-who:with-html-output (stream)
                                             (:td :class "number"
                                                  (cl-who:esc (format nil "#~A" number)))
                                      
                                             (:td (:a :href (construct-uri uri)
                                                      (cl-who:esc title)))

                                             (:td :class "tags"
                                                  (loop for tag in tags
                                                        do (cl-who:htm
                                                            (:a :href (construct-uri "tags/~A.html" tag)
                                                                (cl-bootstrap:bs-label ()
                                                                  (cl-who:esc tag)))))
                                                  (when (is-not-published file)
                                                    (cl-bootstrap:bs-label-danger
                                                      (cl-who:esc "draft")))))))))))))))
    (values)))


(defun render-index (files)
  (render-index-page files "index"))

#+END_SRC

*** Generating of tag pages

    For each tag we want to generate a separate page where will be
    listed only posts having a tag.

    First, we need a function to collect a set of tags, used by all posts:

#+BEGIN_SRC lisp

(defun get-all-tags (files)
  (let (results)
    (iter outer
      (:for file :in files)
      (with ((_ tags (get-title file)))
        (declare (ignorable _))
        (iter (:for tag :in tags)
          (pushnew tag results :test #'string-equal))))
    results))

#+END_SRC

Also we need a function to filter files having specific tag:

#+BEGIN_SRC lisp

(defun get-files-with-tag (files tag)
  (iter (:for file :in files)
    (with ((_ tags (get-title file)))
      (declare (ignorable _))
      (when (member tag tags :test #'string-equal)
        (:collect file)))))

#+END_SRC

Now we can write a function which will render a one page:

#+BEGIN_SRC lisp

(defun render-tag (all-files tag)
  (render-index-page (get-files-with-tag all-files tag)
                     tag
                     :path "docs/tags/"
                     :index-uri "../"
                     :title (rutils:fmt "Posts with tag \"~A\""
                                        tag)))

(defun render-all-tag-pages (all-files)
  (mapcar (alexandria:curry #'render-tag all-files)
          (get-all-tags all-files)))

#+END_SRC

*** Also, we need a function to render the page with a Patreon patron's listing

#+BEGIN_SRC lisp

(defun render-patrons ()
  (let ((filename (ppath:join "docs"
                              "patrons"
                              "index.html")))
    (alexandria:with-output-to-file (stream filename :if-exists :supersede)
      (app-page (stream :index-uri "../")
        (:section :style " margin-left: auto; margin-right: auto; margin-top: 2em; width: 50%"
                  (:h3 :style "margin-left: 1.6em"
                       "Project Patrons")
                  (:ul :style "list-style: none;"
                       (:li "There is not any patrons yet. Become the first one!")))))
    (values)))

#+END_SRC

*** Main function to render the whole site

Also, we need a entry-point function which will do all the job - read
files and write html:

#+BEGIN_SRC lisp

(defun render-site (&key (no-tags nil))
  (let ((files (read-files)))
    (mapc #'render-file files)
    (render-index files)
    (unless no-tags
      (render-all-tag-pages files))
    (render-patrons)
    (render-rss files)
    (values)))

#+END_SRC


** Some utilities
*** Org-mode helpers

#+BEGIN_SRC lisp

(defun make-description (file)
  (let ((*rss-mode* t))
    (with-output-to-string (s)
      (render-node file s))))

#+END_SRC

*** A hack to make cl-org-mode work with lowercased begin_src

    #+begin_src lisp

    (defclass lowercased-src-node (cl-org-mode::src-node)
             ()
             (:default-initargs 
              :opening-delimiter "#+begin_src"
              :closing-delimiter (format nil "~%#+end_src")
              :text nil
              :include-end-node nil))
    
    (defmethod cl-org-mode::node-dispatchers ((node cl-org-mode::org-node))
      (or cl-org-mode::*dispatchers* 
          (mapcar #'make-instance '(lowercased-src-node
                                    cl-org-mode::src-node
                                    cl-org-mode::properties-node
                                    cl-org-mode::outline-node))))

#+end_src

[[https://common-lisp.net/project/cl-org-mode/][Cl-org-mode]] from the Quicklisp is a 10 years old library which
[[https://gitlab.common-lisp.net/cl-org-mode/cl-org-mode][seems unmaintained]]. Probably it is better to move to a library I've
found [[https://github.com/deepfire/cl-org-mode][on the GitHub]] or to [[https://github.com/Ferada/cl-org-mode-parser][this library]].

*** Converting pathnames to strings

To work with files we will use [[content/2020/03/0010-ppath.org][ppath]]. This library is able to make
relative path. However, it operates with strings, not pathnames.

#+BEGIN_SRC lisp

(defun pathname-to-string (p)
  (format nil "~A" p))

#+END_SRC

* A way to find interesting stats from Quicklisp
This morning I decided to do a week of ASDF extensions review. There is
incomplete [[https://common-lisp.net/project/asdf/#extensions][listing of ASDF extensions]] in it's documentation, but how
to find all available ASDF extensions? Obviously, by parsing all "*.asd"
files, and extracting their ":defsystem-depends-on".

#+BEGIN_SRC lisp

(defun install-all-quicklisp ()
  (loop with dist = (ql-dist:find-dist "quicklisp")
        with releases = (ql-dist:provided-releases dist)
        for release in releases
        do (ql-dist:install release)))

(defun get-software-dir ()
  (let ((dist (ql-dist:find-dist "quicklisp")))
    (ql-dist:relative-to dist
                         (make-pathname :directory
                                        (list :relative "software")))))

(defun grep-defsystem-depends ()
  "Returns lines produced by grep"
  (str:split #\Newline
             (with-output-to-string (s)
               (uiop:run-program (format nil "find ~A -name '*.asd' -print0 | xargs -0 grep -i defsystem-depends-on"
                                         (get-software-dir))
                                 :output s))))

(defun extract-systems (line)
  (when (str:contains? "defsystem-depends-on"
                       line)
    (loop with names = (str:words
                        (cl-ppcre:regex-replace
                         ".*:defsystem-depends-on.*\\((.*?)\\).*"
                         line
                         "\\1"))
          for name in names
          collect (string-trim "\":#"
                               name))))

(defun get-asdf-extensions (&key show-paths)
  (loop with result = (make-hash-table :test #'equal)
        for line in (grep-defsystem-depends)
        for systems = (extract-systems line)
        do (loop for system in systems
                 do (push line (gethash system result nil)))
        finally  (return
                   (loop with sorted = (sort (alexandria:hash-table-alist result)
                                             #'>
                                             :key (lambda (item)
                                                    (length (cdr item))))
                         for (system . lines) in sorted
                         collect (cons system (if show-paths
                                                  lines
                                                  (length lines)))))))
#+END_SRC
* Good candidates for review
- a bunch of hu.dwim.* systems seems can be very interesting. We can
  make "A Week of DWIM.HU"!

  - defclass-star - a more clever defclass
  - serializer - flexible and fast object serialization/deserialization
  - stefil - a test framework that just doesn't get in the way
  - computed-class - functional reactive programming for classes, local variables, etc.
  - quasi-quote - efficient templating
  - rdbms - database access (mostly for Postgres)
  - perec - persistent CLOS
  - web-server
  -logger
- there are many interesting ~darts.lib.*~ libraries [[https://github.com/deterministic-arts?tab=repositories][on the GitHub]].
- https://github.com/ruricolist/vernacular - interesting system to
  extend Lisp with other syntax
- [[http://www.wuwei.name/][wuwei]] - stateful ajax framework based on continuations.
- [[https://docs.stevelosh.com/bobbin/usage/][bobbin]] - text wrapping utility
- http://quickdocs.org/parse-float/
- http://quickdocs.org/legit
- https://github.com/Shinmera/modularize
- http://quickdocs.org/modularize-hooks/
- https://github.com/markcox80/lisp-executable
- https://github.com/kidd/cl-vcr
- http://clast.sourceforge.net/
- https://github.com/s-expressionists/Trucler
- https://github.com/bufferswap/ViralityEngine
- http://quickdocs.org/cl-mechanize/
* Thanks
  In this project I've used RSS Icon by [[https://www.iconfinder.com/AlexAPR][Alex Prunici]].
