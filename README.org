# -*- encoding:utf-8 Mode: POLY-ORG;  -*- ---
Here I'll post notes about Quicklisp projects. Also I publish them [[https://twitter.com/search?q=%40svetlyak40wt%20%23poftheday&src=typed_query&f=live][on Twitter account svetlyak40wt]].

* 2020
** April
- 01 April - [[content/2020/04/0025-april.org][april]] ([[https://twitter.com/svetlyak40wt/status/1245315377397186568][twitter]])
- 02 April - [[content/2020/04/0026-periods.org][periods]] ([[https://twitter.com/svetlyak40wt/status/1245693772316528641][twitter]])
- 03 April - [[content/2020/04/0027-golden-utils.org][golden-utils]] ([[https://twitter.com/svetlyak40wt/status/1246106685745311777][twitter]])
- 04 April - [[content/2020/04/0028-cl-conspack.org][cl-conspack]] ([[https://twitter.com/svetlyak40wt/status/1246429190439739399][twitter]])
- 05 April - [[content/2020/04/0029-skippy][skippy]] ([[https://twitter.com/svetlyak40wt/status/1246779138335289346][twitter]])
- 06 April - [[content/2020/03/0030-skippy-renderer.org][skippy-renderer & zpng]] ([[https://twitter.com/svetlyak40wt/status/1247269224860581896][twitter]])
- 07 April - [[content/2020/04/0031-lispqr.org][lispqr]] ([[https://twitter.com/svetlyak40wt/status/1247548175352823808][twitter]])
- 08 April - [[content/2020/04/0032-buildnode.org][buildnode]] ([[https://twitter.com/svetlyak40wt/status/1247931828071211008][twitter]])
- 09 April - [[content/2020/04/0033-trivialib.type-unify.org][trivialib.type-unify]] ([[https://twitter.com/svetlyak40wt/status/1248304050778583040][twitter]])
- 10 April - [[content/2020/04/0034-cl-progress-bar.org][cl-progress-bar]] ([[https://twitter.com/svetlyak40wt/status/1248662624465833989][twitter]])
- 11 April - [[content/2020/04/0035-trivial-mmap.org][trivial-mmap]] ([[https://twitter.com/svetlyak40wt/status/1249021775742226432][twitter]])
- 12 April - [[content/2020/04/0036-mtlisp.org][mtlisp]] ([[https://twitter.com/svetlyak40wt/status/1249437833858867200][twitter]])
- 13 April - [[content/2020/04/0037-deploy.org][deploy]] ([[https://twitter.com/svetlyak40wt/status/1249776210709708801][twitter]])
- 14 April - [[content/2020/04/0038-asdf-linguist.org][asdf-linguist]] ([[https://twitter.com/svetlyak40wt/status/1250125216447152128][twitter]])
- 15 April - [[content/2020/04/0039-com.google.base.org][com.google.base]] ([[https://twitter.com/svetlyak40wt/status/1250523505382363137][twitter]])
- 16 April - [[content/2020/04/0040-asdf-finalizers.org][asdf-finalizers]] ([[https://twitter.com/svetlyak40wt/status/1250840036184113155][twitter]])
- 17 April - [[contents/2020/04/0041-bodge-blobs-support.org][bodge-blobs-support]] ([[https://twitter.com/svetlyak40wt/status/1251183079072432129][twitter]])
- 18 April - [[content/2020/04/0042-trivial-package-manager.org][trivial-package-manager]] ([[https://twitter.com/svetlyak40wt/status/1251518621165248512][twitter]])
- 19 April - [[content/2020/04/0043-hu.dwim.asdf.org][hu.dwim.asdf]] ([[https://twitter.com/svetlyak40wt/status/1251946744356777991][twitter]])
- 20 April - [[content/2020/04/0044-hu.dwim.walker.org][hu.dwim.walker]] ([[https://twitter.com/svetlyak40wt/status/1252332579526709249][twitter]])
- 21 April - [[content/2020/04/0045-cl-lexer.org][cl-lexer]] ([[https://twitter.com/svetlyak40wt/status/1252668190968238081][twitter]])
- 22 April - [[content/2020/04/0046-arrows.org][arrows]] ([[https://twitter.com/svetlyak40wt/status/1253050884461932551][twitter]])
- 23 April - [[content/2020/04/0047-constantfold.org][constantfold]] ([[https://twitter.com/svetlyak40wt/status/1253405484465479680][twitter]])
- 24 April - [[content/2020/04/0048-find-port.org][find-port]] ([[https://twitter.com/svetlyak40wt/status/1253742586927480832][twitter]])
- 25 April - [[content/2020/04/0049-print-html.org][print-html]] ([[https://twitter.com/svetlyak40wt/status/1254090822192152577][twitter]])
- 26 April - [[content/2020/04/0050-literate-lisp.org][literate-lisp]] ([[https://twitter.com/svetlyak40wt/status/1254493004695560194][twitter]])


** March
- 07 March – [[content/2020/03/0000-cl-mpg123.org][cl-mpg123]] ([[https://twitter.com/svetlyak40wt/status/1236275871989878784][twitter]])
- 08 March – [[content/2020/03/0001-rate-monotonic.org][rate-monotonic]] ([[https://twitter.com/svetlyak40wt/status/1236551575159607296][twitter]])
- 09 March – [[content/2020/03/0002-cl-custom-hash-table.org][cl-custom-hash-table]] ([[https://twitter.com/svetlyak40wt/status/1237070320206561282][twitter]])
- 10 March - [[content/2020/03/0003-secure-random.org][secure-random]] ([[https://twitter.com/svetlyak40wt/status/1237395451478851585][twitter]])
- 11 March - [[content/2020/03/0004-physical-quantities.org][physical-quantities]] ([[https://twitter.com/svetlyak40wt/status/1237719603477872640][twitter]])
- 12 March - [[content/2020/03/0005-simple-inferiors.org][simple-inferiors]] ([[https://twitter.com/svetlyak40wt/status/1238071476860989440][twitter]])
- 13 March - [[content/2020/03/0006-unix-opts.org][unix-opts]] ([[https://twitter.com/svetlyak40wt/status/1238386638088212480][twitter]])
- 14 March - [[content/2020/03/0007-access.org][access]] ([[https://twitter.com/svetlyak40wt/status/1238937927222255617][twitter]])
- 15 March - [[content/2020/03/0008-re.org][re]] ([[https://twitter.com/svetlyak40wt/status/1239110401419358210][twitter]])
- 16 March - [[content/2020/03/0009-random-sample.org][random-sample]] ([[https://twitter.com/svetlyak40wt/status/1239446033291194368][twitter]])
- 17 March - [[content/2020/03/0010-ppath.org][ppath]] ([[https://twitter.com/svetlyak40wt/status/1239943718448365569][twitter]])
- 18 March - [[content/2020/03/0011-pango-markup.org][pango-markup]] ([[https://twitter.com/svetlyak40wt/status/1240168844003618816][twitter]])
- 19 March - [[content/2020/03/0012-cl-pack.org][cl-pack]] ([[https://twitter.com/svetlyak40wt/status/1240717258755694592][twitter]])
- 20 March - [[content/2020/03/0013-doplus.org][doplus]] ([[https://twitter.com/svetlyak40wt/status/1241045194927230976][twitter]])
- 21 March - [[content/2020/03/0014-cserial-port.org][cserial-port]] ([[https://twitter.com/svetlyak40wt/status/1241407253804126208][twitter]])
- 22 March - [[content/2020/03/0015-cl-bert.org][cl-bert]] ([[https://twitter.com/svetlyak40wt/status/1241722134797443074][twitter]])
- 23 March - [[content/2020/03/0016-kmrcl.org][kmrcl]] ([[https://twitter.com/svetlyak40wt/status/1242093281330241536][twitter]])
- 24 March - [[content/2020/03/0017-cl-org-mode.org][cl-org-mode]] ([[https://twitter.com/svetlyak40wt/status/1242466873662373889][twitter]])
- 25 March - [[content/2020/03/0018-cl-bootstrap.org][cl-bootstrap]] ([[https://twitter.com/svetlyak40wt/status/1242900031881056256][twitter]])
- 26 March - [[content/2020/03/0019-archive.org][archive]] ([[https://twitter.com/svetlyak40wt/status/1243114779763507200][twitter]])
- 27 March - [[content/2020/03/0020-cl-hash-table-destructuring.org][cl-hash-table-destructuring]] ([[https://twitter.com/svetlyak40wt/status/1243506491040116737][twitter]])
- 28 March - [[content/2020/03/0021-lass.org][lass]] ([[https://twitter.com/svetlyak40wt/status/1243862908217569283][twitter]])
- 29 March - [[content/2020/03/0022-bubble-operator-upwards.org][bubble-operator-upwards]] ([[https://twitter.com/svetlyak40wt/status/1244319074353643520][twitter]])
- 30 March - [[content/2020/03/0023-softdrink.org][softdrink]] ([[https://twitter.com/svetlyak40wt/status/1244581585246195712][twitter]])
- 31 March - [[content/2020/03/0024-chronicity.org][chronicity]] ([[https://twitter.com/svetlyak40wt/status/1244917161237401603][twitter]])

* Code, used to choose a project

First of all, we need to define a package for our code:

#+BEGIN_SRC lisp
(defpackage #:poftheday
  (:use #:cl #:doplus)
  (:export
   #:choose))
(in-package poftheday)
#+END_SRC

Then a function to select random project among all projects, provided by
Quicklisp. Quicklisp client call them "releases".

#+BEGIN_SRC lisp
(defun choose ()
  (let* ((releases (ql::provided-releases t))
         (idx (random (length releases)))
         (release (nth idx releases)))
    (values
     (ql::project-name release)
     (ql::system-files release))))
#+END_SRC

By the way, this function will choose all projects from all installed
Quicklisp distributions. You can have many of them:

#+BEGIN_SRC lisp :load no :wrap
  CL-USER> (ql-dist:install-dist "http://dist.ultralisp.org/"
                                 :prompt nil)
  CL-USER> (ql-dist:all-dists)
  (#<QL-DIST:DIST quicklisp 2019-08-13> #<QL-DIST:DIST ultralisp 20200307123509>)
#+END_SRC

To make randomizer choose different packages after Lisp restart, we need
to initialize it:

#+BEGIN_SRC lisp

  (setf *random-state*
        (make-random-state t))

#+END_SRC

* Here is how a website is rendered

** Collecting source files

First, we need to read walk all org-mode files in folder "content".
We will keep a relative path pointing to the file and parse this file
with cl-org-mode:

#+BEGIN_SRC lisp

(defclass file ()
  ((filename :initarg :filename
             :type string
             :documentation "A relative path to the source org-mode file."
             :reader get-filename)
   (root :initarg :root
         :documentation "Parsed org-mode document, root node."
         :reader get-root)))


(defmethod print-object ((file file) stream)
  (print-unreadable-object (file stream :type t)
    (format stream "~A" (get-filename file))))


(defun read-files ()
  (uiop:while-collecting (collect)
    (flet ((org-mode-p (name)
             (string-equal (pathname-type name)
                           "org"))
           (make-file (filename)
             (collect
                 (let ((relative-filename
                         (ppath:relpath (pathname-to-string filename)
                                        "content/")))
                   (make-instance 'file
                                  :filename relative-filename
                                  :root (cl-org-mode::read-org-file filename))))))
      (cl-fad:walk-directory "content/"
                             #'make-file
                             :test #'org-mode-p))))
#+END_SRC

** Rendering org-mode to HTML

***  A page skeleton
For each page we need a skeleton with header, footer and necessary
Bootstrap styles.

With "cl-who" easiest way to create template is to use lisp macro like
that:

#+BEGIN_SRC lisp

(eval-when (:compile-toplevel :load-toplevel :execute)
  (defparameter *google-code* "
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src=\"https://www.googletagmanager.com/gtag/js?id=UA-162105820-1\"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'UA-162105820-1');
  </script>
  "))

(defmacro app-page ((stream &key title index-uri (site-title "Lisp Project of the Day")) &body body)
  (let ((site-title
          (cond
            (index-uri
             (list (list :a :href index-uri
                         site-title)))
            (t
             (list site-title)))))
    `(cl-who:with-html-output (*standard-output* ,stream :prologue t :indent t)
       (:html :lang "en"
              (:head
               (:meta :charset "utf-8")
               ,@(when title
                   `((:title ,title)))
               (:link :rel "alternate"
                      :href "/lisp-project-of-the-day/rss.xml"
                      :type "application/rss+xml")
               ,*google-code*
               (:link
                :type "text/css"
                :rel "stylesheet"
                :href  ,cl-bootstrap:*bootstrap-css-url*)
               (:script :src ,cl-bootstrap:*jquery-url*)
               (:script :src ,cl-bootstrap:*bootstrap-js-url*)
               (:link :rel "stylesheet"
                      :href "../../highlight/styles/tomorrow-night.css")
               (:script :src "../../highlight/highlight.pack.js")
               (:script "hljs.initHighlightingOnLoad();"))
              (:body 
               (cl-bootstrap:bs-container ()
                 (cl-bootstrap:bs-row
                   (:header
                    (:h1 :style "text-align: center"
                         ,@site-title)
                    ,@(when title
                        `((:h2 :style "text-align: center"
                               (cl-who:esc ,title)))))
                   (cl-bootstrap:bs-col-md ()
                     (:center
                      (:h3 "You can support this project by donating at:")
                      (:a :href "https://www.patreon.com/bePatron?u=33868637"
                          (:img :alt "Donate using Patreon"
                                :src "http://40ants.com/lisp-project-of-the-day/media/images/patreon-btn.png"
                                :width "160"))
                      (:a :href "https://liberapay.com/poftheday/donate"
                          (:img :alt "Donate using Liberapay"
                                :src "https://liberapay.com/assets/widgets/donate.svg")))
                     ,@body))
                 (:div
                  (:hr)
                  (:center
                   (:p (cl-who:str "Brought to you by 40Ants under&nbsp;")
                       (:a :rel "license"
                           :href "http://creativecommons.org/licenses/by-sa/4.0/"
                           (:img :alt "Creative Commons License"
                                 :style "border-width:0"
                                 :src "https://i.creativecommons.org/l/by-sa/4.0/88x31.png")))))))))))

#+END_SRC
***  Generation of separate pages for articles

When source files are collected, we need to render them to HTML inside
the "docs" folder. Github will use content of this folder, to serve the
site at http://40ants.com/lisp-project-of-the-day/

To render the page, we need to extract a title from the first outline
node of org-mode file:

#+BEGIN_SRC lisp

(defun remove-tags (title)
  (cl-ppcre:regex-replace-all " *:.*:$" title ""))


(defun get-title (file)
  ;; Title can ends with tags, we need to remove them
  ;; before returning the value
  (remove-tags
   (cl-org-mode::node.heading
    (cl-org-mode::node.next-node
     (get-root file)))))

#+END_SRC

To iterate over nodes in org-mode file, we will create a custom clause
for the :doplus library. It was described [[content/2020/03/0013-poftheday.org][in this #poftheday post]].

#+BEGIN_SRC lisp

(defclause in-nodes (file)
  `((with (node
           ;; We need to skip root node and first top-level outline node
           (cl-org-mode::node.next-node
            (cl-org-mode::node.next-node
             (get-root ,file)))))
    (for ,*iteration-variable*
         (being node :then (cl-org-mode::node.next-node
                            ,*iteration-variable*)))
    (stop-when (null ,*iteration-variable*))))

#+END_SRC

Org mode file can contain nodes of different types, we will render them
using this generic function:

#+BEGIN_SRC lisp

(defgeneric render-node (node stream)
  (:documentation "Renders org-mode node into the HTML stream"))

#+END_SRC

Outline node contains a header of a section and should be rendered as
H1, H2, etc:

#+BEGIN_SRC lisp

(defmethod render-node ((node cl-org-mode::outline-node) stream)
  (cl-who:with-html-output (stream)
    (:h1 (cl-who:esc (remove-tags
                      (cl-org-mode::node.heading node)))))
  (call-render-for-all-children node stream))

#+END_SRC

First outline of the article can have properties. These properties
describe the state of the project, if it has documentation, how active
it is, etc. These properties have grades:

- :) everything is good
- :| means, for example, that documentation exists as a short readme and
  dont cover all functionality
- :( the project lack of this category at all.

#+BEGIN_SRC lisp 

(defmethod render-node ((node cl-org-mode::properties-node) stream)
  (cl-who:with-html-output (stream)
    (:table :style "position: relative; float: right; background-color: #F1F1F1; padding: 1em; margin-left: 1em; margin-bottom: 1em; border: 1px solid #D1D1D1;"
     (mapcar
      (lambda (item)
        (render-node item stream))
      (cl-org-mode::node.children node)))))

(defmethod render-node ((node cl-org-mode::property-node) stream)
  (cl-who:with-html-output (stream)
    (:tr
     (:td :style "padding-left: 0.5rem; padding-right: 0.5rem"
          (cl-who:esc
           (cl-org-mode::property-node.property node)))
     (:td :style "padding-left: 0.5rem; padding-right: 0.5rem; border-left: 1px solid #DDD"
          (cl-who:esc
           (cl-org-mode::property-node.value node))))))

#+END_SRC

Text node contains code snippets, we need to wrap them into
<code> tags and add a syntax highlighting:

#+BEGIN_SRC lisp

(defmethod render-node ((node cl-org-mode::src-node) stream)
  (cl-who:with-html-output (stream)
    (:pre
     (:code :class (string-trim (list #\Newline)
                                (cl-org-mode::node.emacs-mode node))
            (cl-who:esc (str:trim
                         (cl-org-mode::node.text node)))))))

(defmethod render-node ((node cl-org-mode::closing-delimiter-node) stream)
  ;; Closing delimiters for source code blocks should be ignored.
  )

#+END_SRC

In text node we need to process paragraphs, links, images and quotes. We
will use a separate function to process text like this:

#+BEGIN_QUOTE
Today's Common Lisp project of the Day is: rate-monotonic.

It is a periodic thread scheduler inspired by RTEMS:

http://quickdocs.org/rate-monotonic/
#+END_QUOTE

into HTML:

#+BEGIN_QUOTE
<p>Today's Common Lisp project of the Day is: rate-monotonic.</p>

<p>It is a periodic thread scheduler inspired by RTEMS:</p>

<a href="http://quickdocs.org/rate-monotonic/">http://quickdocs.org/rate-monotonic/</a>
#+END_QUOTE

To do this, we'll write a simple state machine, which will read
text line by line and wrap it's pieces in appropriate HTML tags:

#+BEGIN_SRC lisp

(defun replace-images (text)
  (cl-ppcre:regex-replace-all
   "\\[\\[(.*?\\.(png|jpg|gif))\\]\\]"
   text
   "<img style=\"max-width: 100%\" src=\"\\1\"/>"))

(defun replace-links (text)
  (cl-ppcre:regex-replace-all
   "\\[\\[(.*?)\\]\\[(.*?)\\]\\]"
   text
   "<a href=\"\\1\">\\2</a>"))

(defun replace-raw-urls (text)
  (cl-ppcre:regex-replace-all
   "(^| )(https?://.*?)[,.!]?( |$)"
   text
   "\\1<a href=\"\\2\">\\2</a>\\3"))

(defun replace-inline-code (text)
  (cl-ppcre:regex-replace-all
   "~(.*?)~"
   text
   "<code>\\1</code>"))

(defun replace-org-mode-markup-with-html (text)
  (replace-inline-code
   (replace-raw-urls
    (replace-links
     (replace-images
      text)))))

(defun render-text (text stream)
  (let ((buffer nil)
        (reading-quote nil)
        (reading-list nil))
    (labels
        ((write-paragraph ()
           (cl-who:with-html-output (stream)
             (:p (cl-who:str
                  ;; Here we don't escape the text, because
                  ;; it is from trusted source and will contain
                  ;; links to the images
                  (replace-org-mode-markup-with-html
                   (str:join " " (nreverse buffer))))))
           (write-char #\Newline stream)
           (setf buffer nil))
         (write-quote ()
           (cl-who:with-html-output (stream)
             (:blockquote
              (:pre
               (cl-who:esc
                (str:join #\Newline (nreverse buffer))))))
           (write-char #\Newline stream)
           (setf buffer nil))
         (write-list ()
           (cl-who:with-html-output (stream)
             (:ul
              (loop for item in (reverse buffer)
                    do (cl-who:htm
                        (:li (cl-who:str (replace-org-mode-markup-with-html item)))))))
           (write-char #\Newline stream)
           (setf buffer nil))
         (process (line)
           (cond
             ((and (str:starts-with-p "- " line)
                   (not reading-quote))
              (push (subseq line 2)
                    buffer)
              (setf reading-list t))
             ((and reading-list
                   (string= line ""))
              (write-list)
              (setf reading-list nil))
             (reading-list
              (setf buffer
                    (list*
                     (format nil "~A ~A"
                             (car buffer)
                             line)
                     (cdr buffer))))
             ((string-equal line
                            "#+BEGIN_QUOTE")
              (setf reading-quote t))
             ((string-equal line
                            "#+END_QUOTE")
              (setf reading-quote nil)
              (write-quote))
             ((not (string= line ""))
              (push line buffer))
             ((and (not reading-quote)
                   (and (string= line "")
                        buffer))
              (write-paragraph)))))
      (mapc #'process
            (str:split #\Newline text)))))

#+END_SRC

Now, we will use this text processing function to render all text nodes
in our org-mode files:

#+BEGIN_SRC lisp

(defmethod render-node ((node cl-org-mode::text-node) stream)
  (render-text (cl-org-mode::node.text node)
               stream))

#+END_SRC

Now it is time to write a code which will render all org mode files into HTML:

#+BEGIN_SRC lisp

(defun make-output-filename (file)
  (check-type file file)
  (ppath:join "docs"
              (format nil "~A.html" (car (ppath:splitext (get-filename file))))))

(defmethod render-node ((file file) stream)
  (render-node (get-root file)
               stream))

(defun call-render-for-all-children (node stream)
  (loop for child in (cl-org-mode::node.children node)
        do (render-node child
                        stream)))

(defmethod render-node ((file cl-org-mode::org-file) stream)
  (call-render-for-all-children file stream))

(defun render-file (file)
  (let ((filename (make-output-filename file)))
    (ensure-directories-exist filename)
    
    (alexandria:with-output-to-file (stream filename :if-exists :supersede)
      (app-page (stream :index-uri "../../index.html")
        (cl-who:with-html-output (stream)
          (render-node file stream))))))
  
#+END_SRC

***  Writing RSS feed

We want to show in RSS only posts, published at Twitter. This
information can be extracted from the README.org, because there I'm
adding a link to the tweet. If there is a link, the post is published.

So, we have to find all list items inside "2020" heading and choose only
those, having a link to the twitter.

#+BEGIN_SRC lisp

(defun find-not-published-systems ()
  (let* ((file (cl-org-mode::read-org-file "README.org"))
         (years (loop for node = file then (cl-org-mode::node.next-node node)
                      while node
                      when (and (typep node 'cl-org-mode::outline-node)
                                (str:starts-with-p "20"
                                                   (cl-org-mode::node.heading node)))
                      collect node))
         (months (loop for year in years
                       appending (cl-org-mode::node.children year)))
         (text-nodes (loop for month in months
                           appending (cl-org-mode::node.children month)))
         (texts (loop for node in text-nodes
                      collect (cl-org-mode::node.text node)))
         (lines (loop for text in texts
                      appending (str:split #\Newline text))))
    (loop for line in lines
          when (and (str:starts-with-p "-" line)
                    ;; If there are two links, then the second link is to the twitter post.
                    ;; In this case this post is published.
                    (= (str:count-substring "[[" line)
                       1))
          appending (str:split " & "
                               (cl-ppcre:regex-replace
                                ".*?\\]\\[(.*?)\\].*"
                                line
                                "\\1")))))

#+END_SRC

#+BEGIN_SRC lisp

(defun render-rss (files)
  (alexandria:with-output-to-file (stream "docs/rss.xml"
                                          :if-exists :supersede)
    (let ((base-url "http://40ants.com/lisp-project-of-the-day/")
          (not-published (find-not-published-systems)))
      (flet ((is-not-published (file)
               (let ((title (get-title file))
                     (filename (get-filename file)))
                 (or (member title
                             not-published
                             :test #'string-equal)
                     (str:containsp "draft"
                                    filename)))))
        (xml-emitter:with-rss2 (stream)
          (xml-emitter:rss-channel-header "Common Lisp Project of the Day"
                                          base-url)
          (loop for file in (rutils:take 20 (reverse
                                             (remove-if #'is-not-published
                                                        files)))
                for title = (get-title file)
                for uri = (get-uri file)
                for full-url = (format nil "~A~A" base-url uri)
                for description = (make-description file)
                do (xml-emitter:rss-item title
                                         :description description
                                         :link full-url)))))))

#+END_SRC

***  Generating index page

On index page we want to output a list of all articles.
Probably later, we'll want to print only the latest and to create a tags
based catalogue, but now a simple list is enough.

We'll use few helpers to create urls and titles for the index page:

#+BEGIN_SRC lisp

(defun strip-doc-folder (filename)
  "Removes doc/ from beginning of the filename"
  (cond
    ((str:starts-with-p "docs/" filename)
     (subseq filename 5))
    (t filename)))

(defun get-uri (file)
  "Returns a link like 2020/03/001-some.html"
  (strip-doc-folder (make-output-filename file)))


(defun get-title-for-index (file)
  (let* ((title (get-title file))
         (filename (get-filename file))
         (splitted (ppath:split filename))
         (only-file (cdr splitted))
         (number (first (str:split #\- only-file))))
    (values title number)))

#+END_SRC

#+BEGIN_SRC lisp
  
(defun render-index (files)
  (let ((filename (ppath:join "docs"
                              "index.html"))
        (not-published (find-not-published-systems)))
    (flet ((is-not-published (file)
             (let ((title (get-title file)))
               (member title
                       not-published
                       :test #'string-equal))))
      (alexandria:with-output-to-file (stream filename :if-exists :supersede)
        (app-page (stream)
          (:section :style " margin-left: auto; margin-right: auto; margin-top: 2em; width: 50%"
                    (:h3 :style "margin-left: 1.6em"
                         "Latest post")
                    (:ul :style "list-style: none;"
                     (loop for file in (reverse files)
                           for url = (get-uri file)
                           do (multiple-value-bind (title number)
                                  (get-title-for-index file)
                                
                                (unless (string-equal number
                                                      "draft")
                                  (cl-who:with-html-output (stream)
                                    (:li (:span :style "font-weight: bold; margin-right: 0.7em"
                                                (cl-who:esc (format nil "#~A" number)))
                                         (:a :href url
                                             (cl-who:esc title))
                                         (when (is-not-published file)
                                           (cl-who:str " (draft)"))))))))))))
    (values)))

#+END_SRC

*** Also, we need a function to render the page with a Patreon patron's listing

#+BEGIN_SRC lisp

(defun render-patrons ()
  (let ((filename (ppath:join "docs"
                              "patrons"
                              "index.html")))
    (alexandria:with-output-to-file (stream filename :if-exists :supersede)
      (app-page (stream :index-uri "../")
        (:section :style " margin-left: auto; margin-right: auto; margin-top: 2em; width: 50%"
                  (:h3 :style "margin-left: 1.6em"
                       "Project Patrons")
                  (:ul :style "list-style: none;"
                       (:li "There is not any patrons yet. Become the first one!")))))
    (values)))

#+END_SRC

***  Main function to render the whole site

Also, we need a entry-point function which will do all the job - read
files and write html:

#+BEGIN_SRC lisp

(defun render-site ()
  (let ((files (read-files)))
    (mapc #'render-file files)
    (render-index files)
    (render-patrons)
    (render-rss files)
    (values)))

#+END_SRC


** Some utilities

***  Org-mode helpers

#+BEGIN_SRC lisp

(defun get-first-text-node (file)
  "We'll use this function to get an article description for the readme"
  (doplus:do+ (for node (in-nodes file))
    (when (typep node 'cl-org-mode::text-node)
      (return-from get-first-text-node node))))


(defun make-description (file)
  (replace-org-mode-markup-with-html
   (cl-org-mode::node.text
    (get-first-text-node file))))

#+END_SRC

***  Converting pathnames to strings

To work with files we will use [[content/2020/03/0010-ppath.org][ppath]]. This library is able to make
relative path. However, it operates with strings, not pathnames.

#+BEGIN_SRC lisp

(defun pathname-to-string (p)
  (format nil "~A" p))

#+END_SRC

* A way to find interesting stats from Quicklisp
This morning I decided to do a week of ASDF extensions review. There is
incomplete [[https://common-lisp.net/project/asdf/#extensions][listing of ASDF extensions]] in it's documentation, but how
to find all available ASDF extensions? Obviously, by parsing all "*.asd"
files, and extracting their ":defsystem-depends-on".

#+BEGIN_SRC lisp

(defun install-all-quicklisp ()
  (loop with dist = (ql-dist:find-dist "quicklisp")
        with releases = (ql-dist:provided-releases dist)
        for release in releases
        do (ql-dist:install release)))

(defun get-software-dir ()
  (let ((dist (ql-dist:find-dist "quicklisp")))
    (ql-dist:relative-to dist
                         (make-pathname :directory
                                        (list :relative "software")))))

(defun grep-defsystem-depends ()
  "Returns lines produced by grep"
  (str:split #\Newline
             (with-output-to-string (s)
               (uiop:run-program (format nil "find ~A -name '*.asd' -print0 | xargs -0 grep -i defsystem-depends-on"
                                         (get-software-dir))
                                 :output s))))

(defun extract-systems (line)
  (when (str:contains? "defsystem-depends-on"
                       line)
    (loop with names = (str:words
                        (cl-ppcre:regex-replace
                         ".*:defsystem-depends-on.*\\((.*?)\\).*"
                         line
                         "\\1"))
          for name in names
          collect (string-trim "\":#"
                               name))))

(defun get-asdf-extensions (&key show-paths)
  (loop with result = (make-hash-table :test #'equal)
        for line in (grep-defsystem-depends)
        for systems = (extract-systems line)
        do (loop for system in systems
                 do (push line (gethash system result nil)))
        finally  (return
                   (loop with sorted = (sort (alexandria:hash-table-alist result)
                                             #'>
                                             :key (lambda (item)
                                                    (length (cdr item))))
                         for (system . lines) in sorted
                         collect (cons system (if show-paths
                                                  lines
                                                  (length lines)))))))
#+END_SRC
* Good candidates for review
- a bunch of hu.dwim.* systems seems can be very interesting. We can
  make "A Week of DWIM.HU"!
- https://github.com/ruricolist/vernacular - interesting system to
  extend Lisp with other syntax
- [[http://www.wuwei.name/][wuwei]] - stateful ajax framework based on continuations.

ASDF extensions:

#+BEGIN_SRC text

hu.dwim.asdf - 150  +
prove-asdf - 133    ?
asdf-encodings - 29 +
cffi-grovel - 27    +
qt-libs - 22        ?
asdf-package-system - 16
iolib.asdf - 13     + interesting way to muffle sb-int:package-at-variance condition (https://github.com/sionescu/iolib/blame/master/src/base/asdf.lisp, http://www.sbcl.org/manual/#Package-Variance)
trivial-package-manager - 12 +
iolib.conf - 11
trivial-features - 10        +
bodge-blobs-support - 9      +
com.google.base - 7          * - надо выяснить, как используется
cffi/c2ffi - 6
qtools - 5
prove - 4
cl-mpi-asdf-integration - 3
protobuf - 3
simplet-asdf - 3 (test runner)
asdf - 3
iolib.grovel - 3
cl-test-more - 3
asdf-finalizers - 2          *
deploy - 2                   *
gendl-asdf - 2
literate-lisp - 2            +
iolib.base - 2
modularize - 2               +
cacau-asdf - 2
overlord - 1
cl-protobufs - 1
quickutil-client-management - 1
eco - 1
paren-files - 1
asdf-dependency-grovel - 1
asdf-linguist - 1            *
zacl - 1
closure-template - 1
f2cl-asdf - 1
fiveam - 1
bytecurry.asdf-ext - 1
clos-fixtures - 1
rte - 1 (regular-type-expression)  ?
ci-utils-features - 1
cffi-toolchain - 1
wild-package-inferred-system - 1

#+END_SRC
